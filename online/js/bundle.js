(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw ((a.code = "MODULE_NOT_FOUND"), a);
        }
        var p = (n[i] = { exports: {} });
        e[i][0].call(
          p.exports,
          function (r) {
            var n = e[i][1][r];
            return o(n || r);
          },
          p,
          p.exports,
          r,
          e,
          n,
          t,
        );
      }
      return n[i].exports;
    }
    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
    return o;
  }
  return r;
})()(
  {
    1: [
      function (require, module, exports) {
        /* eslint-disable no-unused-vars */
        "use strict";

        const validateSchema = require("./validators/schema");
        const validateSpec = require("./validators/spec");
        const normalizeArgs = require("@apidevtools/json-schema-ref-parser/lib/normalize-args");
        const util = require("./util");
        const Options = require("./options");
        const maybe = require("call-me-maybe");
        const { ono } = require("@jsdevtools/ono");
        const $RefParser = require("@apidevtools/json-schema-ref-parser");
        const dereference = require("@apidevtools/json-schema-ref-parser/lib/dereference");

        module.exports = SwaggerParser;

        /**
         * This class parses a Swagger 2.0 or 3.0 API, resolves its JSON references and their resolved values,
         * and provides methods for traversing, dereferencing, and validating the API.
         *
         * @class
         * @augments $RefParser
         */
        function SwaggerParser() {
          $RefParser.apply(this, arguments);
        }

        util.inherits(SwaggerParser, $RefParser);
        SwaggerParser.parse = $RefParser.parse;
        SwaggerParser.resolve = $RefParser.resolve;
        SwaggerParser.bundle = $RefParser.bundle;
        SwaggerParser.dereference = $RefParser.dereference;

        /**
         * Alias {@link $RefParser#schema} as {@link SwaggerParser#api}
         */
        Object.defineProperty(SwaggerParser.prototype, "api", {
          configurable: true,
          enumerable: true,
          get() {
            return this.schema;
          },
        });

        /**
         * Parses the given Swagger API.
         * This method does not resolve any JSON references.
         * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
         *
         * @param {string} [path] - The file path or URL of the JSON schema
         * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.
         * @param {ParserOptions} [options] - Options that determine how the API is parsed
         * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.
         * @returns {Promise} - The returned promise resolves with the parsed API object.
         */
        SwaggerParser.prototype.parse = async function (path, api, options, callback) {
          let args = normalizeArgs(arguments);
          args.options = new Options(args.options);

          try {
            let schema = await $RefParser.prototype.parse.call(this, args.path, args.schema, args.options);

            if (schema.swagger) {
              // Verify that the parsed object is a Swagger API
              if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {
                throw ono.syntax(`${args.path || args.schema} is not a valid Swagger API definition`);
              } else if (typeof schema.swagger === "number") {
                // This is a very common mistake, so give a helpful error message
                throw ono.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
              } else if (typeof schema.info.version === "number") {
                // This is a very common mistake, so give a helpful error message
                throw ono.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
              } else if (schema.swagger !== "2.0") {
                throw ono.syntax(`Unrecognized Swagger version: ${schema.swagger}. Expected 2.0`);
              }
            } else {
              let supportedVersions = ["3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0"];

              // Verify that the parsed object is a Openapi API
              if (schema.openapi === undefined || schema.info === undefined) {
                throw ono.syntax(`${args.path || args.schema} is not a valid Openapi API definition`);
              } else if (schema.paths === undefined) {
                if (schema.openapi === "3.1.0") {
                  if (schema.webhooks === undefined) {
                    throw ono.syntax(`${args.path || args.schema} is not a valid Openapi API definition`);
                  }
                } else {
                  throw ono.syntax(`${args.path || args.schema} is not a valid Openapi API definition`);
                }
              } else if (typeof schema.openapi === "number") {
                // This is a very common mistake, so give a helpful error message
                throw ono.syntax('Openapi version number must be a string (e.g. "3.0.0") not a number.');
              } else if (typeof schema.info.version === "number") {
                // This is a very common mistake, so give a helpful error message
                throw ono.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
              } else if (supportedVersions.indexOf(schema.openapi) === -1) {
                throw ono.syntax(
                  `Unsupported OpenAPI version: ${schema.openapi}. ` +
                    `Swagger Parser only supports versions ${supportedVersions.join(", ")}`,
                );
              }

              // This is an OpenAPI v3 schema, check if the "servers" have any relative paths and
              // fix them if the content was pulled from a web resource
              util.fixOasRelativeServers(schema, args.path);
            }

            // Looks good!
            return maybe(args.callback, Promise.resolve(schema));
          } catch (err) {
            return maybe(args.callback, Promise.reject(err));
          }
        };

        /**
         * Parses, dereferences, and validates the given Swagger API.
         * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.
         *
         * @param {string} [path] - The file path or URL of the JSON schema
         * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.
         * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated
         * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.
         * @returns {Promise} - The returned promise resolves with the parsed API object.
         */
        SwaggerParser.validate = function (path, api, options, callback) {
          let Class = this; // eslint-disable-line consistent-this
          let instance = new Class();
          return instance.validate.apply(instance, arguments);
        };

        /**
         * Parses, dereferences, and validates the given Swagger API.
         * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.
         *
         * @param {string} [path] - The file path or URL of the JSON schema
         * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.
         * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated
         * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.
         * @returns {Promise} - The returned promise resolves with the parsed API object.
         */
        SwaggerParser.prototype.validate = async function (path, api, options, callback) {
          let me = this;
          let args = normalizeArgs(arguments);
          args.options = new Options(args.options);

          // ZSchema doesn't support circular objects, so don't dereference circular $refs yet
          // (see https://github.com/zaggino/z-schema/issues/137)
          let circular$RefOption = args.options.dereference.circular;
          args.options.validate.schema && (args.options.dereference.circular = "ignore");

          try {
            await this.dereference(args.path, args.schema, args.options);

            // Restore the original options, now that we're done dereferencing
            args.options.dereference.circular = circular$RefOption;

            if (args.options.validate.schema) {
              // Validate the API against the Swagger schema
              // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet
              validateSchema(me.api);

              if (me.$refs.circular) {
                if (circular$RefOption === true) {
                  // The API has circular references,
                  // so we need to do a second-pass to fully-dereference it
                  dereference(me, args.options);
                } else if (circular$RefOption === false) {
                  // The API has circular references, and they're not allowed, so throw an error
                  throw ono.reference("The API contains circular references");
                }
              }
            }

            if (args.options.validate.spec) {
              // Validate the API against the Swagger spec
              validateSpec(me.api);
            }

            return maybe(args.callback, Promise.resolve(me.schema));
          } catch (err) {
            return maybe(args.callback, Promise.reject(err));
          }
        };

        /**
         * The Swagger object
         * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swagger-object
         *
         * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject
         */
      },
      {
        "./options": 2,
        "./util": 3,
        "./validators/schema": 4,
        "./validators/spec": 5,
        "@apidevtools/json-schema-ref-parser": 8,
        "@apidevtools/json-schema-ref-parser/lib/dereference": 7,
        "@apidevtools/json-schema-ref-parser/lib/normalize-args": 9,
        "@jsdevtools/ono": 33,
        "call-me-maybe": 134,
      },
    ],
    2: [
      function (require, module, exports) {
        "use strict";

        const $RefParserOptions = require("@apidevtools/json-schema-ref-parser/lib/options");
        const schemaValidator = require("./validators/schema");
        const specValidator = require("./validators/spec");
        const util = require("util");

        module.exports = ParserOptions;

        /**
         * Options that determine how Swagger APIs are parsed, resolved, dereferenced, and validated.
         *
         * @param {object|ParserOptions} [_options] - Overridden options
         * @class
         * @augments $RefParserOptions
         */
        function ParserOptions(_options) {
          $RefParserOptions.call(this, ParserOptions.defaults);
          $RefParserOptions.apply(this, arguments);
        }

        ParserOptions.defaults = {
          /**
           * Determines how the API definition will be validated.
           *
           * You can add additional validators of your own, replace an existing one with
           * your own implemenation, or disable any validator by setting it to false.
           */
          validate: {
            schema: schemaValidator,
            spec: specValidator,
          },
        };

        util.inherits(ParserOptions, $RefParserOptions);
      },
      {
        "./validators/schema": 4,
        "./validators/spec": 5,
        "@apidevtools/json-schema-ref-parser/lib/options": 10,
        util: 204,
      },
    ],
    3: [
      function (require, module, exports) {
        "use strict";

        const util = require("util");
        const url = require("@apidevtools/json-schema-ref-parser/lib/util/url");

        exports.format = util.format;
        exports.inherits = util.inherits;

        /**
         * Regular Expression that matches Swagger path params.
         */
        exports.swaggerParamRegExp = /\{([^/}]+)}/g;

        /**
         * List of HTTP verbs used for OperationItem as per the Swagger specification
         */
        const operationsList = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];

        /**
         * This function takes in a Server object, checks if it has relative path
         * and then fixes it as per the path url
         *
         * @param {object} server - The server object to be fixed
         * @param {string} path - The path (an http/https url) from where the file was downloaded
         * @returns {object} - The fixed server object
         */
        function fixServers(server, path) {
          // Server url starting with "/" tells that it is not an http(s) url
          if (server.url && server.url.startsWith("/")) {
            const inUrl = url.parse(path);
            const finalUrl = inUrl.protocol + "//" + inUrl.hostname + server.url;
            server.url = finalUrl;
            return server;
          }
        }

        /**
         * This function helps fix the relative servers in the API definition file
         * be at root, path or operation's level
         */
        function fixOasRelativeServers(schema, filePath) {
          if (schema.openapi && filePath && (filePath.startsWith("http:") || filePath.startsWith("https:"))) {
            /**
             * From OpenAPI v3 spec for Server object's url property: "REQUIRED. A URL to the target host.
             * This URL supports Server Variables and MAY be relative, to indicate that the host location is relative to the location where
             * the OpenAPI document is being served."
             * Further, the spec says that "servers" property can show up at root level, in 'Path Item' object or in 'Operation' object.
             * However, interpretation of the spec says that relative paths for servers should take into account the hostname that
             * serves the OpenAPI file.
             */
            if (schema.servers) {
              schema.servers.map((server) => fixServers(server, filePath)); // Root level servers array's fixup
            }

            // Path, Operation, or Webhook level servers array's fixup
            ["paths", "webhooks"].forEach((component) => {
              Object.keys(schema[component] || []).forEach((path) => {
                const pathItem = schema[component][path];
                Object.keys(pathItem).forEach((opItem) => {
                  if (opItem === "servers") {
                    // servers at pathitem level
                    pathItem[opItem].map((server) => fixServers(server, filePath));
                  } else if (operationsList.includes(opItem)) {
                    // servers at operation level
                    if (pathItem[opItem].servers) {
                      pathItem[opItem].servers.map((server) => fixServers(server, filePath));
                    }
                  }
                });
              });
            });
          } else {
            // Do nothing and return
          }
        }

        exports.fixOasRelativeServers = fixOasRelativeServers;
      },
      { "@apidevtools/json-schema-ref-parser/lib/util/url": 24, util: 204 },
    ],
    4: [
      function (require, module, exports) {
        "use strict";

        const util = require("../util");
        const { ono } = require("@jsdevtools/ono");
        const AjvDraft4 = require("ajv-draft-04");
        const Ajv = require("ajv/dist/2020");
        const { openapi } = require("@apidevtools/openapi-schemas");

        module.exports = validateSchema;

        /**
         * Validates the given Swagger API against the Swagger 2.0 or OpenAPI 3.0 and 3.1 schemas.
         *
         * @param {SwaggerObject} api
         */
        function validateSchema(api) {
          let ajv;

          // Choose the appropriate schema (Swagger or OpenAPI)
          let schema;

          if (api.swagger) {
            schema = openapi.v2;
            ajv = initializeAjv();
          } else {
            if (api.openapi.startsWith("3.1")) {
              schema = openapi.v31;

              // There's a bug with Ajv in how it handles `$dynamicRef` in the way that it's used within the 3.1 schema so we
              // need to do some adhoc workarounds.
              // https://github.com/OAI/OpenAPI-Specification/issues/2689
              // https://github.com/ajv-validator/ajv/issues/1573
              const schemaDynamicRef = schema.$defs.schema;
              delete schemaDynamicRef.$dynamicAnchor;

              schema.$defs.components.properties.schemas.additionalProperties = schemaDynamicRef;
              schema.$defs.header.dependentSchemas.schema.properties.schema = schemaDynamicRef;
              schema.$defs["media-type"].properties.schema = schemaDynamicRef;
              schema.$defs.parameter.properties.schema = schemaDynamicRef;

              ajv = initializeAjv(false);
            } else {
              schema = openapi.v3;
              ajv = initializeAjv();
            }
          }

          // Validate against the schema
          let isValid = ajv.validate(schema, api);
          if (!isValid) {
            let err = ajv.errors;
            let message = "Swagger schema validation failed.\n" + formatAjvError(err);
            throw ono.syntax(err, { details: err }, message);
          }
        }

        /**
         * Determines which version of Ajv to load and prepares it for use.
         *
         * @param {bool} draft04
         * @returns {Ajv}
         */
        function initializeAjv(draft04 = true) {
          const opts = {
            allErrors: true,
            strict: false,
            validateFormats: false,
          };

          if (draft04) {
            return new AjvDraft4(opts);
          }

          return new Ajv(opts);
        }

        /**
         * Run through a set of Ajv errors and compile them into an error message string.
         *
         * @param {object[]}  errors     - The Ajv errors
         * @param {string}    [indent]   - The whitespace used to indent the error message
         * @returns {string}
         */
        function formatAjvError(errors, indent) {
          indent = indent || "  ";
          let message = "";
          for (let error of errors) {
            message += util.format(
              `${indent}#${error.instancePath.length ? error.instancePath : "/"} ${error.message}\n`,
            );
          }
          return message;
        }
      },
      {
        "../util": 3,
        "@apidevtools/openapi-schemas": 25,
        "@jsdevtools/ono": 33,
        "ajv-draft-04": 40,
        "ajv/dist/2020": 47,
      },
    ],
    5: [
      function (require, module, exports) {
        "use strict";

        const util = require("../util");
        const { ono } = require("@jsdevtools/ono");
        const swaggerMethods = require("@apidevtools/swagger-methods");
        const primitiveTypes = ["array", "boolean", "integer", "number", "string"];
        const schemaTypes = ["array", "boolean", "integer", "number", "string", "object", "null", undefined];

        module.exports = validateSpec;

        /**
         * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.
         *
         * @param {SwaggerObject} api
         */
        function validateSpec(api) {
          if (api.openapi) {
            // We don't (yet) support validating against the OpenAPI spec
            return;
          }

          let paths = Object.keys(api.paths || {});
          let operationIds = [];
          for (let pathName of paths) {
            let path = api.paths[pathName];
            let pathId = "/paths" + pathName;

            if (path && pathName.indexOf("/") === 0) {
              validatePath(api, path, pathId, operationIds);
            }
          }

          let definitions = Object.keys(api.definitions || {});
          for (let definitionName of definitions) {
            let definition = api.definitions[definitionName];
            let definitionId = "/definitions/" + definitionName;
            validateRequiredPropertiesExist(definition, definitionId);
          }
        }

        /**
         * Validates the given path.
         *
         * @param {SwaggerObject} api           - The entire Swagger API object
         * @param {object}        path          - A Path object, from the Swagger API
         * @param {string}        pathId        - A value that uniquely identifies the path
         * @param {string}        operationIds  - An array of collected operationIds found in other paths
         */
        function validatePath(api, path, pathId, operationIds) {
          for (let operationName of swaggerMethods) {
            let operation = path[operationName];
            let operationId = pathId + "/" + operationName;

            if (operation) {
              let declaredOperationId = operation.operationId;
              if (declaredOperationId) {
                if (operationIds.indexOf(declaredOperationId) === -1) {
                  operationIds.push(declaredOperationId);
                } else {
                  throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);
                }
              }
              validateParameters(api, path, pathId, operation, operationId);

              let responses = Object.keys(operation.responses || {});
              for (let responseName of responses) {
                let response = operation.responses[responseName];
                let responseId = operationId + "/responses/" + responseName;
                validateResponse(responseName, response || {}, responseId);
              }
            }
          }
        }

        /**
         * Validates the parameters for the given operation.
         *
         * @param {SwaggerObject} api           - The entire Swagger API object
         * @param {object}        path          - A Path object, from the Swagger API
         * @param {string}        pathId        - A value that uniquely identifies the path
         * @param {object}        operation     - An Operation object, from the Swagger API
         * @param {string}        operationId   - A value that uniquely identifies the operation
         */
        function validateParameters(api, path, pathId, operation, operationId) {
          let pathParams = path.parameters || [];
          let operationParams = operation.parameters || [];

          // Check for duplicate path parameters
          try {
            checkForDuplicates(pathParams);
          } catch (e) {
            throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);
          }

          // Check for duplicate operation parameters
          try {
            checkForDuplicates(operationParams);
          } catch (e) {
            throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);
          }

          // Combine the path and operation parameters,
          // with the operation params taking precedence over the path params
          let params = pathParams.reduce((combinedParams, value) => {
            let duplicate = combinedParams.some((param) => {
              return param.in === value.in && param.name === value.name;
            });
            if (!duplicate) {
              combinedParams.push(value);
            }
            return combinedParams;
          }, operationParams.slice());

          validateBodyParameters(params, operationId);
          validatePathParameters(params, pathId, operationId);
          validateParameterTypes(params, api, operation, operationId);
        }

        /**
         * Validates body and formData parameters for the given operation.
         *
         * @param   {object[]}  params       -  An array of Parameter objects
         * @param   {string}    operationId  -  A value that uniquely identifies the operation
         */
        function validateBodyParameters(params, operationId) {
          let bodyParams = params.filter((param) => {
            return param.in === "body";
          });
          let formParams = params.filter((param) => {
            return param.in === "formData";
          });

          // There can only be one "body" parameter
          if (bodyParams.length > 1) {
            throw ono.syntax(
              `Validation failed. ${operationId} has ${bodyParams.length} body parameters. Only one is allowed.`,
            );
          } else if (bodyParams.length > 0 && formParams.length > 0) {
            // "body" params and "formData" params are mutually exclusive
            throw ono.syntax(
              `Validation failed. ${operationId} has body parameters and formData parameters. Only one or the other is allowed.`,
            );
          }
        }

        /**
         * Validates path parameters for the given path.
         *
         * @param   {object[]}  params        - An array of Parameter objects
         * @param   {string}    pathId        - A value that uniquely identifies the path
         * @param   {string}    operationId   - A value that uniquely identifies the operation
         */
        function validatePathParameters(params, pathId, operationId) {
          // Find all {placeholders} in the path string
          let placeholders = pathId.match(util.swaggerParamRegExp) || [];

          // Check for duplicates
          for (let i = 0; i < placeholders.length; i++) {
            for (let j = i + 1; j < placeholders.length; j++) {
              if (placeholders[i] === placeholders[j]) {
                throw ono.syntax(
                  `Validation failed. ${operationId} has multiple path placeholders named ${placeholders[i]}`,
                );
              }
            }
          }

          params = params.filter((param) => {
            return param.in === "path";
          });

          for (let param of params) {
            if (param.required !== true) {
              throw ono.syntax(
                "Validation failed. Path parameters cannot be optional. " +
                  `Set required=true for the "${param.name}" parameter at ${operationId}`,
              );
            }
            let match = placeholders.indexOf("{" + param.name + "}");
            if (match === -1) {
              throw ono.syntax(
                `Validation failed. ${operationId} has a path parameter named "${param.name}", ` +
                  `but there is no corresponding {${param.name}} in the path string`,
              );
            }
            placeholders.splice(match, 1);
          }

          if (placeholders.length > 0) {
            throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);
          }
        }

        /**
         * Validates data types of parameters for the given operation.
         *
         * @param   {object[]}  params       -  An array of Parameter objects
         * @param   {object}    api          -  The entire Swagger API object
         * @param   {object}    operation    -  An Operation object, from the Swagger API
         * @param   {string}    operationId  -  A value that uniquely identifies the operation
         */
        function validateParameterTypes(params, api, operation, operationId) {
          for (let param of params) {
            let parameterId = operationId + "/parameters/" + param.name;
            let schema, validTypes;

            switch (param.in) {
              case "body":
                schema = param.schema;
                validTypes = schemaTypes;
                break;
              case "formData":
                schema = param;
                validTypes = primitiveTypes.concat("file");
                break;
              default:
                schema = param;
                validTypes = primitiveTypes;
            }

            validateSchema(schema, parameterId, validTypes);
            validateRequiredPropertiesExist(schema, parameterId);

            if (schema.type === "file") {
              // "file" params must consume at least one of these MIME types
              let formData = /multipart\/(.*\+)?form-data/;
              let urlEncoded = /application\/(.*\+)?x-www-form-urlencoded/;

              let consumes = operation.consumes || api.consumes || [];

              let hasValidMimeType = consumes.some((consume) => {
                return formData.test(consume) || urlEncoded.test(consume);
              });

              if (!hasValidMimeType) {
                throw ono.syntax(
                  `Validation failed. ${operationId} has a file parameter, so it must consume multipart/form-data ` +
                    "or application/x-www-form-urlencoded",
                );
              }
            }
          }
        }

        /**
         * Checks the given parameter list for duplicates, and throws an error if found.
         *
         * @param   {object[]}  params  - An array of Parameter objects
         */
        function checkForDuplicates(params) {
          for (let i = 0; i < params.length - 1; i++) {
            let outer = params[i];
            for (let j = i + 1; j < params.length; j++) {
              let inner = params[j];
              if (outer.name === inner.name && outer.in === inner.in) {
                throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named "${outer.name}"`);
              }
            }
          }
        }

        /**
         * Validates the given response object.
         *
         * @param   {string}    code        -  The HTTP response code (or "default")
         * @param   {object}    response    -  A Response object, from the Swagger API
         * @param   {string}    responseId  -  A value that uniquely identifies the response
         */
        function validateResponse(code, response, responseId) {
          if (code !== "default" && (code < 100 || code > 599)) {
            throw ono.syntax(`Validation failed. ${responseId} has an invalid response code (${code})`);
          }

          let headers = Object.keys(response.headers || {});
          for (let headerName of headers) {
            let header = response.headers[headerName];
            let headerId = responseId + "/headers/" + headerName;
            validateSchema(header, headerId, primitiveTypes);
          }

          if (response.schema) {
            let validTypes = schemaTypes.concat("file");
            if (validTypes.indexOf(response.schema.type) === -1) {
              throw ono.syntax(
                `Validation failed. ${responseId} has an invalid response schema type (${response.schema.type})`,
              );
            } else {
              validateSchema(response.schema, responseId + "/schema", validTypes);
            }
          }
        }

        /**
         * Validates the given Swagger schema object.
         *
         * @param {object}    schema      - A Schema object, from the Swagger API
         * @param {string}    schemaId    - A value that uniquely identifies the schema object
         * @param {string[]}  validTypes  - An array of the allowed schema types
         */
        function validateSchema(schema, schemaId, validTypes) {
          if (validTypes.indexOf(schema.type) === -1) {
            throw ono.syntax(`Validation failed. ${schemaId} has an invalid type (${schema.type})`);
          }

          if (schema.type === "array" && !schema.items) {
            throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an "items" schema`);
          }
        }

        /**
         * Validates that the declared properties of the given Swagger schema object actually exist.
         *
         * @param {object}    schema      - A Schema object, from the Swagger API
         * @param {string}    schemaId    - A value that uniquely identifies the schema object
         */
        function validateRequiredPropertiesExist(schema, schemaId) {
          /**
           * Recursively collects all properties of the schema and its ancestors. They are added to the props object.
           */
          function collectProperties(schemaObj, props) {
            if (schemaObj.properties) {
              for (let property in schemaObj.properties) {
                if (schemaObj.properties.hasOwnProperty(property)) {
                  props[property] = schemaObj.properties[property];
                }
              }
            }
            if (schemaObj.allOf) {
              for (let parent of schemaObj.allOf) {
                collectProperties(parent, props);
              }
            }
          }

          if (schema.required && Array.isArray(schema.required)) {
            let props = {};
            collectProperties(schema, props);
            for (let requiredProperty of schema.required) {
              if (!props[requiredProperty]) {
                throw ono.syntax(
                  `Validation failed. Property '${requiredProperty}' listed as required but does not exist in '${schemaId}'`,
                );
              }
            }
          }
        }
      },
      { "../util": 3, "@apidevtools/swagger-methods": 30, "@jsdevtools/ono": 33 },
    ],
    6: [
      function (require, module, exports) {
        "use strict";

        const $Ref = require("./ref");
        const Pointer = require("./pointer");
        const url = require("./util/url");

        module.exports = bundle;

        /**
         * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that
         * only has *internal* references, not any *external* references.
         * This method mutates the JSON schema object, adding new references and re-mapping existing ones.
         *
         * @param {$RefParser} parser
         * @param {$RefParserOptions} options
         */
        function bundle(parser, options) {
          // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);

          // Build an inventory of all $ref pointers in the JSON Schema
          let inventory = [];
          crawl(parser, "schema", parser.$refs._root$Ref.path + "#", "#", 0, inventory, parser.$refs, options);

          // Remap all $ref pointers
          remap(inventory);
        }

        /**
         * Recursively crawls the given value, and inventories all JSON references.
         *
         * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.
         * @param {string} key - The property key of `parent` to be crawled
         * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash
         * @param {string} pathFromRoot - The path of the property being crawled, from the schema root
         * @param {object[]} inventory - An array of already-inventoried $ref pointers
         * @param {$Refs} $refs
         * @param {$RefParserOptions} options
         */
        function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {
          let obj = key === null ? parent : parent[key];

          if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
            if ($Ref.isAllowed$Ref(obj)) {
              inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);
            } else {
              // Crawl the object in a specific order that's optimized for bundling.
              // This is important because it determines how `pathFromRoot` gets built,
              // which later determines which keys get dereferenced and which ones get remapped
              let keys = Object.keys(obj).sort((a, b) => {
                // Most people will expect references to be bundled into the the "definitions" property,
                // so we always crawl that property first, if it exists.
                if (a === "definitions") {
                  return -1;
                } else if (b === "definitions") {
                  return 1;
                } else {
                  // Otherwise, crawl the keys based on their length.
                  // This produces the shortest possible bundled references
                  return a.length - b.length;
                }
              });

              // eslint-disable-next-line no-shadow
              for (let key of keys) {
                let keyPath = Pointer.join(path, key);
                let keyPathFromRoot = Pointer.join(pathFromRoot, key);
                let value = obj[key];

                if ($Ref.isAllowed$Ref(value)) {
                  inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);
                } else {
                  crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);
                }
              }
            }
          }
        }

        /**
         * Inventories the given JSON Reference (i.e. records detailed information about it so we can
         * optimize all $refs in the schema), and then crawls the resolved value.
         *
         * @param {object} $refParent - The object that contains a JSON Reference as one of its keys
         * @param {string} $refKey - The key in `$refParent` that is a JSON Reference
         * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash
         * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root
         * @param {object[]} inventory - An array of already-inventoried $ref pointers
         * @param {$Refs} $refs
         * @param {$RefParserOptions} options
         */
        function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {
          let $ref = $refKey === null ? $refParent : $refParent[$refKey];
          let $refPath = url.resolve(path, $ref.$ref);
          let pointer = $refs._resolve($refPath, pathFromRoot, options);
          if (pointer === null) {
            return;
          }

          let depth = Pointer.parse(pathFromRoot).length;
          let file = url.stripHash(pointer.path);
          let hash = url.getHash(pointer.path);
          let external = file !== $refs._root$Ref.path;
          let extended = $Ref.isExtended$Ref($ref);
          indirections += pointer.indirections;

          let existingEntry = findInInventory(inventory, $refParent, $refKey);
          if (existingEntry) {
            // This $Ref has already been inventoried, so we don't need to process it again
            if (depth < existingEntry.depth || indirections < existingEntry.indirections) {
              removeFromInventory(inventory, existingEntry);
            } else {
              return;
            }
          }

          inventory.push({
            $ref, // The JSON Reference (e.g. {$ref: string})
            parent: $refParent, // The object that contains this $ref pointer
            key: $refKey, // The key in `parent` that is the $ref pointer
            pathFromRoot, // The path to the $ref pointer, from the JSON Schema root
            depth, // How far from the JSON Schema root is this $ref pointer?
            file, // The file that the $ref pointer resolves to
            hash, // The hash within `file` that the $ref pointer resolves to
            value: pointer.value, // The resolved value of the $ref pointer
            circular: pointer.circular, // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
            extended, // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
            external, // Does this $ref pointer point to a file other than the main JSON Schema file?
            indirections, // The number of indirect references that were traversed to resolve the value
          });

          // Recursively crawl the resolved value
          if (!existingEntry) {
            crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);
          }
        }

        /**
         * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.
         * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same
         * value are re-mapped to point to the first reference.
         *
         * @example:
         *  {
         *    first: { $ref: somefile.json#/some/part },
         *    second: { $ref: somefile.json#/another/part },
         *    third: { $ref: somefile.json },
         *    fourth: { $ref: somefile.json#/some/part/sub/part }
         *  }
         *
         * In this example, there are four references to the same file, but since the third reference points
         * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be
         * remapped to point inside the third one.
         *
         * On the other hand, if the third reference DIDN'T exist, then the first and second would both need
         * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT
         * need to be dereferenced, because it can be remapped to point inside the first one.
         *
         * @param {object[]} inventory
         */
        function remap(inventory) {
          // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them
          inventory.sort((a, b) => {
            if (a.file !== b.file) {
              // Group all the $refs that point to the same file
              return a.file < b.file ? -1 : +1;
            } else if (a.hash !== b.hash) {
              // Group all the $refs that point to the same part of the file
              return a.hash < b.hash ? -1 : +1;
            } else if (a.circular !== b.circular) {
              // If the $ref points to itself, then sort it higher than other $refs that point to this $ref
              return a.circular ? -1 : +1;
            } else if (a.extended !== b.extended) {
              // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value
              return a.extended ? +1 : -1;
            } else if (a.indirections !== b.indirections) {
              // Sort direct references higher than indirect references
              return a.indirections - b.indirections;
            } else if (a.depth !== b.depth) {
              // Sort $refs by how close they are to the JSON Schema root
              return a.depth - b.depth;
            } else {
              // Determine how far each $ref is from the "definitions" property.
              // Most people will expect references to be bundled into the the "definitions" property if possible.
              let aDefinitionsIndex = a.pathFromRoot.lastIndexOf("/definitions");
              let bDefinitionsIndex = b.pathFromRoot.lastIndexOf("/definitions");

              if (aDefinitionsIndex !== bDefinitionsIndex) {
                // Give higher priority to the $ref that's closer to the "definitions" property
                return bDefinitionsIndex - aDefinitionsIndex;
              } else {
                // All else is equal, so use the shorter path, which will produce the shortest possible reference
                return a.pathFromRoot.length - b.pathFromRoot.length;
              }
            }
          });

          let file, hash, pathFromRoot;
          for (let entry of inventory) {
            // console.log('Re-mapping $ref pointer "%s" at %s', entry.$ref.$ref, entry.pathFromRoot);

            if (!entry.external) {
              // This $ref already resolves to the main JSON Schema file
              entry.$ref.$ref = entry.hash;
            } else if (entry.file === file && entry.hash === hash) {
              // This $ref points to the same value as the prevous $ref, so remap it to the same path
              entry.$ref.$ref = pathFromRoot;
            } else if (entry.file === file && entry.hash.indexOf(hash + "/") === 0) {
              // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path
              entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, "#")));
            } else {
              // We've moved to a new file or new hash
              file = entry.file;
              hash = entry.hash;
              pathFromRoot = entry.pathFromRoot;

              // This is the first $ref to point to this value, so dereference the value.
              // Any other $refs that point to the same value will point to this $ref instead
              entry.$ref = entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);

              if (entry.circular) {
                // This $ref points to itself
                entry.$ref.$ref = entry.pathFromRoot;
              }
            }

            // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');
          }
        }

        /**
         * TODO
         */
        function findInInventory(inventory, $refParent, $refKey) {
          for (let i = 0; i < inventory.length; i++) {
            let existingEntry = inventory[i];
            if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {
              return existingEntry;
            }
          }
        }

        function removeFromInventory(inventory, entry) {
          let index = inventory.indexOf(entry);
          inventory.splice(index, 1);
        }
      },
      { "./pointer": 16, "./ref": 17, "./util/url": 24 },
    ],
    7: [
      function (require, module, exports) {
        "use strict";

        const $Ref = require("./ref");
        const Pointer = require("./pointer");
        const { ono } = require("@jsdevtools/ono");
        const url = require("./util/url");

        module.exports = dereference;

        /**
         * Crawls the JSON schema, finds all JSON references, and dereferences them.
         * This method mutates the JSON schema object, replacing JSON references with their resolved value.
         *
         * @param {$RefParser} parser
         * @param {$RefParserOptions} options
         */
        function dereference(parser, options) {
          // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);
          let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, "#", [], parser.$refs, options);
          parser.$refs.circular = dereferenced.circular;
          parser.schema = dereferenced.value;
        }

        /**
         * Recursively crawls the given value, and dereferences any JSON references.
         *
         * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
         * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
         * @param {string} pathFromRoot - The path of `obj` from the schema root
         * @param {object[]} parents - An array of the parent objects that have already been dereferenced
         * @param {$Refs} $refs
         * @param {$RefParserOptions} options
         * @returns {{value: object, circular: boolean}}
         */
        function crawl(obj, path, pathFromRoot, parents, $refs, options) {
          let dereferenced;
          let result = {
            value: obj,
            circular: false,
          };

          if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
            parents.push(obj);

            if ($Ref.isAllowed$Ref(obj, options)) {
              dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, $refs, options);
              result.circular = dereferenced.circular;
              result.value = dereferenced.value;
            } else {
              for (let key of Object.keys(obj)) {
                let keyPath = Pointer.join(path, key);
                let keyPathFromRoot = Pointer.join(pathFromRoot, key);
                let value = obj[key];
                let circular = false;

                if ($Ref.isAllowed$Ref(value, options)) {
                  dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, $refs, options);
                  circular = dereferenced.circular;
                  // Avoid pointless mutations; breaks frozen objects to no profit
                  if (obj[key] !== dereferenced.value) {
                    obj[key] = dereferenced.value;
                  }
                } else {
                  if (parents.indexOf(value) === -1) {
                    dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, $refs, options);
                    circular = dereferenced.circular;
                    // Avoid pointless mutations; breaks frozen objects to no profit
                    if (obj[key] !== dereferenced.value) {
                      obj[key] = dereferenced.value;
                    }
                  } else {
                    circular = foundCircularReference(keyPath, $refs, options);
                  }
                }

                // Set the "isCircular" flag if this or any other property is circular
                result.circular = result.circular || circular;
              }
            }

            parents.pop();
          }

          return result;
        }

        /**
         * Dereferences the given JSON Reference, and then crawls the resulting value.
         *
         * @param {{$ref: string}} $ref - The JSON Reference to resolve
         * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
         * @param {string} pathFromRoot - The path of `$ref` from the schema root
         * @param {object[]} parents - An array of the parent objects that have already been dereferenced
         * @param {$Refs} $refs
         * @param {$RefParserOptions} options
         * @returns {{value: object, circular: boolean}}
         */
        function dereference$Ref($ref, path, pathFromRoot, parents, $refs, options) {
          // console.log('Dereferencing $ref pointer "%s" at %s', $ref.$ref, path);

          let $refPath = url.resolve(path, $ref.$ref);
          let pointer = $refs._resolve($refPath, path, options);

          if (pointer === null) {
            return {
              circular: false,
              value: null,
            };
          }

          // Check for circular references
          let directCircular = pointer.circular;
          let circular = directCircular || parents.indexOf(pointer.value) !== -1;
          circular && foundCircularReference(path, $refs, options);

          // Dereference the JSON reference
          let dereferencedValue = $Ref.dereference($ref, pointer.value);

          // Crawl the dereferenced value (unless it's circular)
          if (!circular) {
            // Determine if the dereferenced value is circular
            let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, $refs, options);
            circular = dereferenced.circular;
            dereferencedValue = dereferenced.value;
          }

          if (circular && !directCircular && options.dereference.circular === "ignore") {
            // The user has chosen to "ignore" circular references, so don't change the value
            dereferencedValue = $ref;
          }

          if (directCircular) {
            // The pointer is a DIRECT circular reference (i.e. it references itself).
            // So replace the $ref path with the absolute path from the JSON Schema root
            dereferencedValue.$ref = pathFromRoot;
          }

          return {
            circular,
            value: dereferencedValue,
          };
        }

        /**
         * Called when a circular reference is found.
         * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.
         *
         * @param {string} keyPath - The JSON Reference path of the circular reference
         * @param {$Refs} $refs
         * @param {$RefParserOptions} options
         * @returns {boolean} - always returns true, to indicate that a circular reference was found
         */
        function foundCircularReference(keyPath, $refs, options) {
          $refs.circular = true;
          if (!options.dereference.circular) {
            throw ono.reference(`Circular $ref pointer found at ${keyPath}`);
          }
          return true;
        }
      },
      { "./pointer": 16, "./ref": 17, "./util/url": 24, "@jsdevtools/ono": 33 },
    ],
    8: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            /* eslint-disable no-unused-vars */
            "use strict";

            const $Refs = require("./refs");
            const _parse = require("./parse");
            const normalizeArgs = require("./normalize-args");
            const resolveExternal = require("./resolve-external");
            const _bundle = require("./bundle");
            const _dereference = require("./dereference");
            const url = require("./util/url");
            const {
              JSONParserError,
              InvalidPointerError,
              MissingPointerError,
              ResolverError,
              ParserError,
              UnmatchedParserError,
              UnmatchedResolverError,
              isHandledError,
              JSONParserErrorGroup,
            } = require("./util/errors");
            const maybe = require("call-me-maybe");
            const { ono } = require("@jsdevtools/ono");

            module.exports = $RefParser;
            module.exports.default = $RefParser;
            module.exports.JSONParserError = JSONParserError;
            module.exports.InvalidPointerError = InvalidPointerError;
            module.exports.MissingPointerError = MissingPointerError;
            module.exports.ResolverError = ResolverError;
            module.exports.ParserError = ParserError;
            module.exports.UnmatchedParserError = UnmatchedParserError;
            module.exports.UnmatchedResolverError = UnmatchedResolverError;

            /**
             * This class parses a JSON schema, builds a map of its JSON references and their resolved values,
             * and provides methods for traversing, manipulating, and dereferencing those references.
             *
             * @constructor
             */
            function $RefParser() {
              /**
               * The parsed (and possibly dereferenced) JSON schema object
               *
               * @type {object}
               * @readonly
               */
              this.schema = null;

              /**
               * The resolved JSON references
               *
               * @type {$Refs}
               * @readonly
               */
              this.$refs = new $Refs();
            }

            /**
             * Parses the given JSON schema.
             * This method does not resolve any JSON references.
             * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
             * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
             * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
             */
            $RefParser.parse = function parse(path, schema, options, callback) {
              let Class = this; // eslint-disable-line consistent-this
              let instance = new Class();
              return instance.parse.apply(instance, arguments);
            };

            /**
             * Parses the given JSON schema.
             * This method does not resolve any JSON references.
             * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
             * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
             * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
             */
            $RefParser.prototype.parse = async function parse(path, schema, options, callback) {
              let args = normalizeArgs(arguments);
              let promise;

              if (!args.path && !args.schema) {
                let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);
                return maybe(args.callback, Promise.reject(err));
              }

              // Reset everything
              this.schema = null;
              this.$refs = new $Refs();

              // If the path is a filesystem path, then convert it to a URL.
              // NOTE: According to the JSON Reference spec, these should already be URLs,
              // but, in practice, many people use local filesystem paths instead.
              // So we're being generous here and doing the conversion automatically.
              // This is not intended to be a 100% bulletproof solution.
              // If it doesn't work for your use-case, then use a URL instead.
              let pathType = "http";
              if (url.isFileSystemPath(args.path)) {
                args.path = url.fromFileSystemPath(args.path);
                pathType = "file";
              }

              // Resolve the absolute path of the schema
              args.path = url.resolve(url.cwd(), args.path);

              if (args.schema && typeof args.schema === "object") {
                // A schema object was passed-in.
                // So immediately add a new $Ref with the schema object as its value
                let $ref = this.$refs._add(args.path);
                $ref.value = args.schema;
                $ref.pathType = pathType;
                promise = Promise.resolve(args.schema);
              } else {
                // Parse the schema file/url
                promise = _parse(args.path, this.$refs, args.options);
              }

              let me = this;
              try {
                let result = await promise;

                if (result !== null && typeof result === "object" && !Buffer.isBuffer(result)) {
                  me.schema = result;
                  return maybe(args.callback, Promise.resolve(me.schema));
                } else if (args.options.continueOnError) {
                  me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability
                  return maybe(args.callback, Promise.resolve(me.schema));
                } else {
                  throw ono.syntax(`"${me.$refs._root$Ref.path || result}" is not a valid JSON Schema`);
                }
              } catch (err) {
                if (!args.options.continueOnError || !isHandledError(err)) {
                  return maybe(args.callback, Promise.reject(err));
                }

                if (this.$refs._$refs[url.stripHash(args.path)]) {
                  this.$refs._$refs[url.stripHash(args.path)].addError(err);
                }

                return maybe(args.callback, Promise.resolve(null));
              }
            };

            /**
             * Parses the given JSON schema and resolves any JSON references, including references in
             * externally-referenced files.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
             * @param {function} [callback]
             * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
             *
             * @returns {Promise}
             * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
             */
            $RefParser.resolve = function resolve(path, schema, options, callback) {
              let Class = this; // eslint-disable-line consistent-this
              let instance = new Class();
              return instance.resolve.apply(instance, arguments);
            };

            /**
             * Parses the given JSON schema and resolves any JSON references, including references in
             * externally-referenced files.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
             * @param {function} [callback]
             * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
             *
             * @returns {Promise}
             * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
             */
            $RefParser.prototype.resolve = async function resolve(path, schema, options, callback) {
              let me = this;
              let args = normalizeArgs(arguments);

              try {
                await this.parse(args.path, args.schema, args.options);
                await resolveExternal(me, args.options);
                finalize(me);
                return maybe(args.callback, Promise.resolve(me.$refs));
              } catch (err) {
                return maybe(args.callback, Promise.reject(err));
              }
            };

            /**
             * Parses the given JSON schema, resolves any JSON references, and bundles all external references
             * into the main JSON schema. This produces a JSON schema that only has *internal* references,
             * not any *external* references.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
             * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
             * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
             */
            $RefParser.bundle = function bundle(path, schema, options, callback) {
              let Class = this; // eslint-disable-line consistent-this
              let instance = new Class();
              return instance.bundle.apply(instance, arguments);
            };

            /**
             * Parses the given JSON schema, resolves any JSON references, and bundles all external references
             * into the main JSON schema. This produces a JSON schema that only has *internal* references,
             * not any *external* references.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
             * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
             * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
             */
            $RefParser.prototype.bundle = async function bundle(path, schema, options, callback) {
              let me = this;
              let args = normalizeArgs(arguments);

              try {
                await this.resolve(args.path, args.schema, args.options);
                _bundle(me, args.options);
                finalize(me);
                return maybe(args.callback, Promise.resolve(me.schema));
              } catch (err) {
                return maybe(args.callback, Promise.reject(err));
              }
            };

            /**
             * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
             * That is, all JSON references are replaced with their resolved values.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
             * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
             * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
             */
            $RefParser.dereference = function dereference(path, schema, options, callback) {
              let Class = this; // eslint-disable-line consistent-this
              let instance = new Class();
              return instance.dereference.apply(instance, arguments);
            };

            /**
             * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
             * That is, all JSON references are replaced with their resolved values.
             *
             * @param {string} [path] - The file path or URL of the JSON schema
             * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
             * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
             * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
             * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
             */
            $RefParser.prototype.dereference = async function dereference(path, schema, options, callback) {
              let me = this;
              let args = normalizeArgs(arguments);

              try {
                await this.resolve(args.path, args.schema, args.options);
                _dereference(me, args.options);
                finalize(me);
                return maybe(args.callback, Promise.resolve(me.schema));
              } catch (err) {
                return maybe(args.callback, Promise.reject(err));
              }
            };

            function finalize(parser) {
              const errors = JSONParserErrorGroup.getParserErrors(parser);
              if (errors.length > 0) {
                throw new JSONParserErrorGroup(parser);
              }
            }
          }).call(this);
        }).call(this, { isBuffer: require("../../../is-buffer/index.js") });
      },
      {
        "../../../is-buffer/index.js": 140,
        "./bundle": 6,
        "./dereference": 7,
        "./normalize-args": 9,
        "./parse": 11,
        "./refs": 18,
        "./resolve-external": 19,
        "./util/errors": 22,
        "./util/url": 24,
        "@jsdevtools/ono": 33,
        "call-me-maybe": 134,
      },
    ],
    9: [
      function (require, module, exports) {
        "use strict";

        const Options = require("./options");

        module.exports = normalizeArgs;

        /**
         * Normalizes the given arguments, accounting for optional args.
         *
         * @param {Arguments} args
         * @returns {object}
         */
        function normalizeArgs(args) {
          let path, schema, options, callback;
          args = Array.prototype.slice.call(args);

          if (typeof args[args.length - 1] === "function") {
            // The last parameter is a callback function
            callback = args.pop();
          }

          if (typeof args[0] === "string") {
            // The first parameter is the path
            path = args[0];
            if (typeof args[2] === "object") {
              // The second parameter is the schema, and the third parameter is the options
              schema = args[1];
              options = args[2];
            } else {
              // The second parameter is the options
              schema = undefined;
              options = args[1];
            }
          } else {
            // The first parameter is the schema
            path = "";
            schema = args[0];
            options = args[1];
          }

          if (!(options instanceof Options)) {
            options = new Options(options);
          }

          return {
            path,
            schema,
            options,
            callback,
          };
        }
      },
      { "./options": 10 },
    ],
    10: [
      function (require, module, exports) {
        /* eslint lines-around-comment: [2, {beforeBlockComment: false}] */
        "use strict";

        const jsonParser = require("./parsers/json");
        const yamlParser = require("./parsers/yaml");
        const textParser = require("./parsers/text");
        const binaryParser = require("./parsers/binary");
        const fileResolver = require("./resolvers/file");
        const httpResolver = require("./resolvers/http");

        module.exports = $RefParserOptions;

        /**
         * Options that determine how JSON schemas are parsed, resolved, and dereferenced.
         *
         * @param {object|$RefParserOptions} [options] - Overridden options
         * @constructor
         */
        function $RefParserOptions(options) {
          merge(this, $RefParserOptions.defaults);
          merge(this, options);
        }

        $RefParserOptions.defaults = {
          /**
           * Determines how different types of files will be parsed.
           *
           * You can add additional parsers of your own, replace an existing one with
           * your own implementation, or disable any parser by setting it to false.
           */
          parse: {
            json: jsonParser,
            yaml: yamlParser,
            text: textParser,
            binary: binaryParser,
          },

          /**
           * Determines how JSON References will be resolved.
           *
           * You can add additional resolvers of your own, replace an existing one with
           * your own implementation, or disable any resolver by setting it to false.
           */
          resolve: {
            file: fileResolver,
            http: httpResolver,

            /**
             * Determines whether external $ref pointers will be resolved.
             * If this option is disabled, then none of above resolvers will be called.
             * Instead, external $ref pointers will simply be ignored.
             *
             * @type {boolean}
             */
            external: true,
          },

          /**
           * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
           * causes it to keep processing as much as possible and then throw a single error that contains all errors
           * that were encountered.
           */
          continueOnError: false,

          /**
           * Determines the types of JSON references that are allowed.
           */
          dereference: {
            /**
             * Dereference circular (recursive) JSON references?
             * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
             * If "ignore", then circular references will not be dereferenced.
             *
             * @type {boolean|string}
             */
            circular: true,
          },
        };

        /**
         * Merges the properties of the source object into the target object.
         *
         * @param {object} target - The object that we're populating
         * @param {?object} source - The options that are being merged
         * @returns {object}
         */
        function merge(target, source) {
          if (isMergeable(source)) {
            let keys = Object.keys(source);
            for (let i = 0; i < keys.length; i++) {
              let key = keys[i];
              let sourceSetting = source[key];
              let targetSetting = target[key];

              if (isMergeable(sourceSetting)) {
                // It's a nested object, so merge it recursively
                target[key] = merge(targetSetting || {}, sourceSetting);
              } else if (sourceSetting !== undefined) {
                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.
                target[key] = sourceSetting;
              }
            }
          }
          return target;
        }

        /**
         * Determines whether the given value can be merged,
         * or if it is a scalar value that should just override the target value.
         *
         * @param   {*}  val
         * @returns {Boolean}
         */
        function isMergeable(val) {
          return (
            val && typeof val === "object" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date)
          );
        }
      },
      {
        "./parsers/binary": 12,
        "./parsers/json": 13,
        "./parsers/text": 14,
        "./parsers/yaml": 15,
        "./resolvers/file": 20,
        "./resolvers/http": 21,
      },
    ],
    11: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            "use strict";

            const { ono } = require("@jsdevtools/ono");
            const url = require("./util/url");
            const plugins = require("./util/plugins");
            const {
              ResolverError,
              ParserError,
              UnmatchedParserError,
              UnmatchedResolverError,
              isHandledError,
            } = require("./util/errors");

            module.exports = parse;

            /**
             * Reads and parses the specified file path or URL.
             *
             * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context
             * @param {$Refs} $refs
             * @param {$RefParserOptions} options
             *
             * @returns {Promise}
             * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.
             */
            async function parse(path, $refs, options) {
              // Remove the URL fragment, if any
              path = url.stripHash(path);

              // Add a new $Ref for this file, even though we don't have the value yet.
              // This ensures that we don't simultaneously read & parse the same file multiple times
              let $ref = $refs._add(path);

              // This "file object" will be passed to all resolvers and parsers.
              let file = {
                url: path,
                extension: url.getExtension(path),
              };

              // Read the file and then parse the data
              try {
                const resolver = await readFile(file, options, $refs);
                $ref.pathType = resolver.plugin.name;
                file.data = resolver.result;

                const parser = await parseFile(file, options, $refs);
                $ref.value = parser.result;

                return parser.result;
              } catch (err) {
                if (isHandledError(err)) {
                  $ref.value = err;
                }

                throw err;
              }
            }

            /**
             * Reads the given file, using the configured resolver plugins
             *
             * @param {object} file           - An object containing information about the referenced file
             * @param {string} file.url       - The full URL of the referenced file
             * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
             * @param {$RefParserOptions} options
             *
             * @returns {Promise}
             * The promise resolves with the raw file contents and the resolver that was used.
             */
            function readFile(file, options, $refs) {
              return new Promise((resolve, reject) => {
                // console.log('Reading %s', file.url);

                // Find the resolvers that can read this file
                let resolvers = plugins.all(options.resolve);
                resolvers = plugins.filter(resolvers, "canRead", file);

                // Run the resolvers, in order, until one of them succeeds
                plugins.sort(resolvers);
                plugins.run(resolvers, "read", file, $refs).then(resolve, onError);

                function onError(err) {
                  if (!err && options.continueOnError) {
                    // No resolver could be matched
                    reject(new UnmatchedResolverError(file.url));
                  } else if (!err || !("error" in err)) {
                    // Throw a generic, friendly error.
                    reject(ono.syntax(`Unable to resolve $ref pointer "${file.url}"`));
                  }
                  // Throw the original error, if it's one of our own (user-friendly) errors.
                  else if (err.error instanceof ResolverError) {
                    reject(err.error);
                  } else {
                    reject(new ResolverError(err, file.url));
                  }
                }
              });
            }

            /**
             * Parses the given file's contents, using the configured parser plugins.
             *
             * @param {object} file           - An object containing information about the referenced file
             * @param {string} file.url       - The full URL of the referenced file
             * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
             * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
             * @param {$RefParserOptions} options
             *
             * @returns {Promise}
             * The promise resolves with the parsed file contents and the parser that was used.
             */
            function parseFile(file, options, $refs) {
              return new Promise((resolve, reject) => {
                // console.log('Parsing %s', file.url);

                // Find the parsers that can read this file type.
                // If none of the parsers are an exact match for this file, then we'll try ALL of them.
                // This handles situations where the file IS a supported type, just with an unknown extension.
                let allParsers = plugins.all(options.parse);
                let filteredParsers = plugins.filter(allParsers, "canParse", file);
                let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;

                // Run the parsers, in order, until one of them succeeds
                plugins.sort(parsers);
                plugins.run(parsers, "parse", file, $refs).then(onParsed, onError);

                function onParsed(parser) {
                  if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
                    reject(ono.syntax(`Error parsing "${file.url}" as ${parser.plugin.name}. \nParsed value is empty`));
                  } else {
                    resolve(parser);
                  }
                }

                function onError(err) {
                  if (!err && options.continueOnError) {
                    // No resolver could be matched
                    reject(new UnmatchedParserError(file.url));
                  } else if (!err || !("error" in err)) {
                    reject(ono.syntax(`Unable to parse ${file.url}`));
                  } else if (err.error instanceof ParserError) {
                    reject(err.error);
                  } else {
                    reject(new ParserError(err.error.message, file.url));
                  }
                }
              });
            }

            /**
             * Determines whether the parsed value is "empty".
             *
             * @param {*} value
             * @returns {boolean}
             */
            function isEmpty(value) {
              return (
                value === undefined ||
                (typeof value === "object" && Object.keys(value).length === 0) ||
                (typeof value === "string" && value.trim().length === 0) ||
                (Buffer.isBuffer(value) && value.length === 0)
              );
            }
          }).call(this);
        }).call(this, { isBuffer: require("../../../is-buffer/index.js") });
      },
      {
        "../../../is-buffer/index.js": 140,
        "./util/errors": 22,
        "./util/plugins": 23,
        "./util/url": 24,
        "@jsdevtools/ono": 33,
      },
    ],
    12: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            "use strict";

            let BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;

            module.exports = {
              /**
               * The order that this parser will run, in relation to other parsers.
               *
               * @type {number}
               */
              order: 400,

              /**
               * Whether to allow "empty" files (zero bytes).
               *
               * @type {boolean}
               */
              allowEmpty: true,

              /**
               * Determines whether this parser can parse a given file reference.
               * Parsers that return true will be tried, in order, until one successfully parses the file.
               * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
               * every parser will be tried.
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
               * @returns {boolean}
               */
              canParse(file) {
                // Use this parser if the file is a Buffer, and has a known binary extension
                return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
              },

              /**
               * Parses the given data as a Buffer (byte array).
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
               * @returns {Buffer}
               */
              parse(file) {
                if (Buffer.isBuffer(file.data)) {
                  return file.data;
                } else {
                  // This will reject if data is anything other than a string or typed array
                  return Buffer.from(file.data);
                }
              },
            };
          }).call(this);
        }).call(this, require("buffer").Buffer);
      },
      { buffer: 132 },
    ],
    13: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            "use strict";

            const { ParserError } = require("../util/errors");

            module.exports = {
              /**
               * The order that this parser will run, in relation to other parsers.
               *
               * @type {number}
               */
              order: 100,

              /**
               * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
               *
               * @type {boolean}
               */
              allowEmpty: true,

              /**
               * Determines whether this parser can parse a given file reference.
               * Parsers that match will be tried, in order, until one successfully parses the file.
               * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
               * every parser will be tried.
               *
               * @type {RegExp|string|string[]|function}
               */
              canParse: ".json",

              /**
               * Parses the given file as JSON
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
               * @returns {Promise}
               */
              async parse(file) {
                // eslint-disable-line require-await
                let data = file.data;
                if (Buffer.isBuffer(data)) {
                  data = data.toString();
                }

                if (typeof data === "string") {
                  if (data.trim().length === 0) {
                    return; // This mirrors the YAML behavior
                  } else {
                    try {
                      return JSON.parse(data);
                    } catch (e) {
                      throw new ParserError(e.message, file.url);
                    }
                  }
                } else {
                  // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                  return data;
                }
              },
            };
          }).call(this);
        }).call(this, { isBuffer: require("../../../../is-buffer/index.js") });
      },
      { "../../../../is-buffer/index.js": 140, "../util/errors": 22 },
    ],
    14: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            "use strict";

            const { ParserError } = require("../util/errors");

            let TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;

            module.exports = {
              /**
               * The order that this parser will run, in relation to other parsers.
               *
               * @type {number}
               */
              order: 300,

              /**
               * Whether to allow "empty" files (zero bytes).
               *
               * @type {boolean}
               */
              allowEmpty: true,

              /**
               * The encoding that the text is expected to be in.
               *
               * @type {string}
               */
              encoding: "utf8",

              /**
               * Determines whether this parser can parse a given file reference.
               * Parsers that return true will be tried, in order, until one successfully parses the file.
               * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
               * every parser will be tried.
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
               * @returns {boolean}
               */
              canParse(file) {
                // Use this parser if the file is a string or Buffer, and has a known text-based extension
                return (typeof file.data === "string" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
              },

              /**
               * Parses the given file as text
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
               * @returns {string}
               */
              parse(file) {
                if (typeof file.data === "string") {
                  return file.data;
                } else if (Buffer.isBuffer(file.data)) {
                  return file.data.toString(this.encoding);
                } else {
                  throw new ParserError("data is not text", file.url);
                }
              },
            };
          }).call(this);
        }).call(this, { isBuffer: require("../../../../is-buffer/index.js") });
      },
      { "../../../../is-buffer/index.js": 140, "../util/errors": 22 },
    ],
    15: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            "use strict";

            const { ParserError } = require("../util/errors");
            const yaml = require("js-yaml");

            module.exports = {
              /**
               * The order that this parser will run, in relation to other parsers.
               *
               * @type {number}
               */
              order: 200,

              /**
               * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
               *
               * @type {boolean}
               */
              allowEmpty: true,

              /**
               * Determines whether this parser can parse a given file reference.
               * Parsers that match will be tried, in order, until one successfully parses the file.
               * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
               * every parser will be tried.
               *
               * @type {RegExp|string[]|function}
               */
              canParse: [".yaml", ".yml", ".json"], // JSON is valid YAML

              /**
               * Parses the given file as YAML
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
               * @returns {Promise}
               */
              async parse(file) {
                // eslint-disable-line require-await
                let data = file.data;
                if (Buffer.isBuffer(data)) {
                  data = data.toString();
                }

                if (typeof data === "string") {
                  try {
                    return yaml.safeLoad(data);
                  } catch (e) {
                    throw new ParserError(e.message, file.url);
                  }
                } else {
                  // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                  return data;
                }
              },
            };
          }).call(this);
        }).call(this, { isBuffer: require("../../../../is-buffer/index.js") });
      },
      { "../../../../is-buffer/index.js": 140, "../util/errors": 22, "js-yaml": 141 },
    ],
    16: [
      function (require, module, exports) {
        "use strict";

        module.exports = Pointer;

        const $Ref = require("./ref");
        const url = require("./util/url");
        const { JSONParserError, InvalidPointerError, MissingPointerError, isHandledError } = require("./util/errors");
        const slashes = /\//g;
        const tildes = /~/g;
        const escapedSlash = /~1/g;
        const escapedTilde = /~0/g;

        /**
         * This class represents a single JSON pointer and its resolved value.
         *
         * @param {$Ref} $ref
         * @param {string} path
         * @param {string} [friendlyPath] - The original user-specified path (used for error messages)
         * @constructor
         */
        function Pointer($ref, path, friendlyPath) {
          /**
           * The {@link $Ref} object that contains this {@link Pointer} object.
           * @type {$Ref}
           */
          this.$ref = $ref;

          /**
           * The file path or URL, containing the JSON pointer in the hash.
           * This path is relative to the path of the main JSON schema file.
           * @type {string}
           */
          this.path = path;

          /**
           * The original path or URL, used for error messages.
           * @type {string}
           */
          this.originalPath = friendlyPath || path;

          /**
           * The value of the JSON pointer.
           * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
           * @type {?*}
           */
          this.value = undefined;

          /**
           * Indicates whether the pointer references itself.
           * @type {boolean}
           */
          this.circular = false;

          /**
           * The number of indirect references that were traversed to resolve the value.
           * Resolving a single pointer may require resolving multiple $Refs.
           * @type {number}
           */
          this.indirections = 0;
        }

        /**
         * Resolves the value of a nested property within the given object.
         *
         * @param {*} obj - The object that will be crawled
         * @param {$RefParserOptions} options
         * @param {string} pathFromRoot - the path of place that initiated resolving
         *
         * @returns {Pointer}
         * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.
         * If resolving this value required resolving other JSON references, then
         * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path
         * of the resolved value.
         */
        Pointer.prototype.resolve = function (obj, options, pathFromRoot) {
          let tokens = Pointer.parse(this.path, this.originalPath);

          // Crawl the object, one token at a time
          this.value = unwrapOrThrow(obj);

          for (let i = 0; i < tokens.length; i++) {
            if (resolveIf$Ref(this, options)) {
              // The $ref path has changed, so append the remaining tokens to the path
              this.path = Pointer.join(this.path, tokens.slice(i));
            }

            if (typeof this.value === "object" && this.value !== null && "$ref" in this.value) {
              return this;
            }

            let token = tokens[i];
            if (this.value[token] === undefined || this.value[token] === null) {
              this.value = null;
              throw new MissingPointerError(token, this.originalPath);
            } else {
              this.value = this.value[token];
            }
          }

          // Resolve the final value
          if (!this.value || (this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot)) {
            resolveIf$Ref(this, options);
          }

          return this;
        };

        /**
         * Sets the value of a nested property within the given object.
         *
         * @param {*} obj - The object that will be crawled
         * @param {*} value - the value to assign
         * @param {$RefParserOptions} options
         *
         * @returns {*}
         * Returns the modified object, or an entirely new object if the entire object is overwritten.
         */
        Pointer.prototype.set = function (obj, value, options) {
          let tokens = Pointer.parse(this.path);
          let token;

          if (tokens.length === 0) {
            // There are no tokens, replace the entire object with the new value
            this.value = value;
            return value;
          }

          // Crawl the object, one token at a time
          this.value = unwrapOrThrow(obj);

          for (let i = 0; i < tokens.length - 1; i++) {
            resolveIf$Ref(this, options);

            token = tokens[i];
            if (this.value && this.value[token] !== undefined) {
              // The token exists
              this.value = this.value[token];
            } else {
              // The token doesn't exist, so create it
              this.value = setValue(this, token, {});
            }
          }

          // Set the value of the final token
          resolveIf$Ref(this, options);
          token = tokens[tokens.length - 1];
          setValue(this, token, value);

          // Return the updated object
          return obj;
        };

        /**
         * Parses a JSON pointer (or a path containing a JSON pointer in the hash)
         * and returns an array of the pointer's tokens.
         * (e.g. "schema.json#/definitions/person/name" => ["definitions", "person", "name"])
         *
         * The pointer is parsed according to RFC 6901
         * {@link https://tools.ietf.org/html/rfc6901#section-3}
         *
         * @param {string} path
         * @param {string} [originalPath]
         * @returns {string[]}
         */
        Pointer.parse = function (path, originalPath) {
          // Get the JSON pointer from the path's hash
          let pointer = url.getHash(path).substr(1);

          // If there's no pointer, then there are no tokens,
          // so return an empty array
          if (!pointer) {
            return [];
          }

          // Split into an array
          pointer = pointer.split("/");

          // Decode each part, according to RFC 6901
          for (let i = 0; i < pointer.length; i++) {
            pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, "/").replace(escapedTilde, "~"));
          }

          if (pointer[0] !== "") {
            throw new InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);
          }

          return pointer.slice(1);
        };

        /**
         * Creates a JSON pointer path, by joining one or more tokens to a base path.
         *
         * @param {string} base - The base path (e.g. "schema.json#/definitions/person")
         * @param {string|string[]} tokens - The token(s) to append (e.g. ["name", "first"])
         * @returns {string}
         */
        Pointer.join = function (base, tokens) {
          // Ensure that the base path contains a hash
          if (base.indexOf("#") === -1) {
            base += "#";
          }

          // Append each token to the base path
          tokens = Array.isArray(tokens) ? tokens : [tokens];
          for (let i = 0; i < tokens.length; i++) {
            let token = tokens[i];
            // Encode the token, according to RFC 6901
            base += "/" + encodeURIComponent(token.replace(tildes, "~0").replace(slashes, "~1"));
          }

          return base;
        };

        /**
         * If the given pointer's {@link Pointer#value} is a JSON reference,
         * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.
         * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the
         * resolution path of the new value.
         *
         * @param {Pointer} pointer
         * @param {$RefParserOptions} options
         * @returns {boolean} - Returns `true` if the resolution path changed
         */
        function resolveIf$Ref(pointer, options) {
          // Is the value a JSON reference? (and allowed?)

          if ($Ref.isAllowed$Ref(pointer.value, options)) {
            let $refPath = url.resolve(pointer.path, pointer.value.$ref);

            if ($refPath === pointer.path) {
              // The value is a reference to itself, so there's nothing to do.
              pointer.circular = true;
            } else {
              let resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);
              pointer.indirections += resolved.indirections + 1;

              if ($Ref.isExtended$Ref(pointer.value)) {
                // This JSON reference "extends" the resolved value, rather than simply pointing to it.
                // So the resolved path does NOT change.  Just the value does.
                pointer.value = $Ref.dereference(pointer.value, resolved.value);
                return false;
              } else {
                // Resolve the reference
                pointer.$ref = resolved.$ref;
                pointer.path = resolved.path;
                pointer.value = resolved.value;
              }

              return true;
            }
          }
        }

        /**
         * Sets the specified token value of the {@link Pointer#value}.
         *
         * The token is evaluated according to RFC 6901.
         * {@link https://tools.ietf.org/html/rfc6901#section-4}
         *
         * @param {Pointer} pointer - The JSON Pointer whose value will be modified
         * @param {string} token - A JSON Pointer token that indicates how to modify `obj`
         * @param {*} value - The value to assign
         * @returns {*} - Returns the assigned value
         */
        function setValue(pointer, token, value) {
          if (pointer.value && typeof pointer.value === "object") {
            if (token === "-" && Array.isArray(pointer.value)) {
              pointer.value.push(value);
            } else {
              pointer.value[token] = value;
            }
          } else {
            throw new JSONParserError(
              `Error assigning $ref pointer "${pointer.path}". \nCannot set "${token}" of a non-object.`,
            );
          }
          return value;
        }

        function unwrapOrThrow(value) {
          if (isHandledError(value)) {
            throw value;
          }

          return value;
        }
      },
      { "./ref": 17, "./util/errors": 22, "./util/url": 24 },
    ],
    17: [
      function (require, module, exports) {
        "use strict";

        module.exports = $Ref;

        const Pointer = require("./pointer");
        const { InvalidPointerError, isHandledError, normalizeError } = require("./util/errors");
        const { safePointerToPath, stripHash, getHash } = require("./util/url");

        /**
         * This class represents a single JSON reference and its resolved value.
         *
         * @constructor
         */
        function $Ref() {
          /**
           * The file path or URL of the referenced file.
           * This path is relative to the path of the main JSON schema file.
           *
           * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.
           * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get
           * specific JSON pointers within the file.
           *
           * @type {string}
           */
          this.path = undefined;

          /**
           * The resolved value of the JSON reference.
           * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
           * @type {?*}
           */
          this.value = undefined;

          /**
           * The {@link $Refs} object that contains this {@link $Ref} object.
           * @type {$Refs}
           */
          this.$refs = undefined;

          /**
           * Indicates the type of {@link $Ref#path} (e.g. "file", "http", etc.)
           * @type {?string}
           */
          this.pathType = undefined;

          /**
           * List of all errors. Undefined if no errors.
           * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}
           */
          this.errors = undefined;
        }

        /**
         * Pushes an error to errors array.
         *
         * @param {Array<JSONParserError | JSONParserErrorGroup>} error - The error to be pushed
         * @returns {void}
         */
        $Ref.prototype.addError = function (err) {
          if (this.errors === undefined) {
            this.errors = [];
          }

          // the path has been almost certainly set at this point,
          // but just in case something went wrong, let's inject path if necessary
          if (Array.isArray(err.errors)) {
            this.errors.push(...err.errors.map(normalizeError));
          } else {
            this.errors.push(normalizeError(err));
          }
        };

        /**
         * Determines whether the given JSON reference exists within this {@link $Ref#value}.
         *
         * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
         * @param {$RefParserOptions} options
         * @returns {boolean}
         */
        $Ref.prototype.exists = function (path, options) {
          try {
            this.resolve(path, options);
            return true;
          } catch (e) {
            return false;
          }
        };

        /**
         * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.
         *
         * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
         * @param {$RefParserOptions} options
         * @returns {*} - Returns the resolved value
         */
        $Ref.prototype.get = function (path, options) {
          return this.resolve(path, options).value;
        };

        /**
         * Resolves the given JSON reference within this {@link $Ref#value}.
         *
         * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
         * @param {$RefParserOptions} options
         * @param {string} friendlyPath - The original user-specified path (used for error messages)
         *  @param {string} pathFromRoot - The path of `obj` from the schema root
         * @returns {Pointer}
         */
        $Ref.prototype.resolve = function (path, options, friendlyPath, pathFromRoot) {
          let pointer = new Pointer(this, path, friendlyPath);
          try {
            return pointer.resolve(this.value, options, pathFromRoot);
          } catch (err) {
            if (!options || !options.continueOnError || !isHandledError(err)) {
              throw err;
            }

            if (err.path === null) {
              err.path = safePointerToPath(getHash(pathFromRoot));
            }

            if (err instanceof InvalidPointerError) {
              // this is a special case - InvalidPointerError is thrown when dereferencing external file,
              // but the issue is caused by the source file that referenced the file that undergoes dereferencing
              err.source = stripHash(pathFromRoot);
            }

            this.addError(err);
            return null;
          }
        };

        /**
         * Sets the value of a nested property within this {@link $Ref#value}.
         * If the property, or any of its parents don't exist, they will be created.
         *
         * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash
         * @param {*} value - The value to assign
         */
        $Ref.prototype.set = function (path, value) {
          let pointer = new Pointer(this, path);
          this.value = pointer.set(this.value, value);
        };

        /**
         * Determines whether the given value is a JSON reference.
         *
         * @param {*} value - The value to inspect
         * @returns {boolean}
         */
        $Ref.is$Ref = function (value) {
          return value && typeof value === "object" && typeof value.$ref === "string" && value.$ref.length > 0;
        };

        /**
         * Determines whether the given value is an external JSON reference.
         *
         * @param {*} value - The value to inspect
         * @returns {boolean}
         */
        $Ref.isExternal$Ref = function (value) {
          return $Ref.is$Ref(value) && value.$ref[0] !== "#";
        };

        /**
         * Determines whether the given value is a JSON reference, and whether it is allowed by the options.
         * For example, if it references an external file, then options.resolve.external must be true.
         *
         * @param {*} value - The value to inspect
         * @param {$RefParserOptions} options
         * @returns {boolean}
         */
        $Ref.isAllowed$Ref = function (value, options) {
          if ($Ref.is$Ref(value)) {
            if (value.$ref.substr(0, 2) === "#/" || value.$ref === "#") {
              // It's a JSON Pointer reference, which is always allowed
              return true;
            } else if (value.$ref[0] !== "#" && (!options || options.resolve.external)) {
              // It's an external reference, which is allowed by the options
              return true;
            }
          }
        };

        /**
         * Determines whether the given value is a JSON reference that "extends" its resolved value.
         * That is, it has extra properties (in addition to "$ref"), so rather than simply pointing to
         * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved
         * value, plus the extra properties.
         *
         * @example:
         *  {
         *    person: {
         *      properties: {
         *        firstName: { type: string }
         *        lastName: { type: string }
         *      }
         *    }
         *    employee: {
         *      properties: {
         *        $ref: #/person/properties
         *        salary: { type: number }
         *      }
         *    }
         *  }
         *
         *  In this example, "employee" is an extended $ref, since it extends "person" with an additional
         *  property (salary).  The result is a NEW value that looks like this:
         *
         *  {
         *    properties: {
         *      firstName: { type: string }
         *      lastName: { type: string }
         *      salary: { type: number }
         *    }
         *  }
         *
         * @param {*} value - The value to inspect
         * @returns {boolean}
         */
        $Ref.isExtended$Ref = function (value) {
          return $Ref.is$Ref(value) && Object.keys(value).length > 1;
        };

        /**
         * Returns the resolved value of a JSON Reference.
         * If necessary, the resolved value is merged with the JSON Reference to create a new object
         *
         * @example:
         *  {
         *    person: {
         *      properties: {
         *        firstName: { type: string }
         *        lastName: { type: string }
         *      }
         *    }
         *    employee: {
         *      properties: {
         *        $ref: #/person/properties
         *        salary: { type: number }
         *      }
         *    }
         *  }
         *
         *  When "person" and "employee" are merged, you end up with the following object:
         *
         *  {
         *    properties: {
         *      firstName: { type: string }
         *      lastName: { type: string }
         *      salary: { type: number }
         *    }
         *  }
         *
         * @param {object} $ref - The JSON reference object (the one with the "$ref" property)
         * @param {*} resolvedValue - The resolved value, which can be any type
         * @returns {*} - Returns the dereferenced value
         */
        $Ref.dereference = function ($ref, resolvedValue) {
          if (resolvedValue && typeof resolvedValue === "object" && $Ref.isExtended$Ref($ref)) {
            let merged = {};
            for (let key of Object.keys($ref)) {
              if (key !== "$ref") {
                merged[key] = $ref[key];
              }
            }

            for (let key of Object.keys(resolvedValue)) {
              if (!(key in merged)) {
                merged[key] = resolvedValue[key];
              }
            }

            return merged;
          } else {
            // Completely replace the original reference with the resolved value
            return resolvedValue;
          }
        };
      },
      { "./pointer": 16, "./util/errors": 22, "./util/url": 24 },
    ],
    18: [
      function (require, module, exports) {
        "use strict";

        const { ono } = require("@jsdevtools/ono");
        const $Ref = require("./ref");
        const url = require("./util/url");

        module.exports = $Refs;

        /**
         * This class is a map of JSON references and their resolved values.
         */
        function $Refs() {
          /**
           * Indicates whether the schema contains any circular references.
           *
           * @type {boolean}
           */
          this.circular = false;

          /**
           * A map of paths/urls to {@link $Ref} objects
           *
           * @type {object}
           * @protected
           */
          this._$refs = {};

          /**
           * The {@link $Ref} object that is the root of the JSON schema.
           *
           * @type {$Ref}
           * @protected
           */
          this._root$Ref = null;
        }

        /**
         * Returns the paths of all the files/URLs that are referenced by the JSON schema,
         * including the schema itself.
         *
         * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
         * @returns {string[]}
         */
        $Refs.prototype.paths = function (types) {
          // eslint-disable-line no-unused-vars
          let paths = getPaths(this._$refs, arguments);
          return paths.map((path) => {
            return path.decoded;
          });
        };

        /**
         * Returns the map of JSON references and their resolved values.
         *
         * @param {...string|string[]} [types] - Only return references of the given types ("file", "http", etc.)
         * @returns {object}
         */
        $Refs.prototype.values = function (types) {
          // eslint-disable-line no-unused-vars
          let $refs = this._$refs;
          let paths = getPaths($refs, arguments);
          return paths.reduce((obj, path) => {
            obj[path.decoded] = $refs[path.encoded].value;
            return obj;
          }, {});
        };

        /**
         * Returns a POJO (plain old JavaScript object) for serialization as JSON.
         *
         * @returns {object}
         */
        $Refs.prototype.toJSON = $Refs.prototype.values;

        /**
         * Determines whether the given JSON reference exists.
         *
         * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
         * @param {$RefParserOptions} [options]
         * @returns {boolean}
         */
        $Refs.prototype.exists = function (path, options) {
          try {
            this._resolve(path, "", options);
            return true;
          } catch (e) {
            return false;
          }
        };

        /**
         * Resolves the given JSON reference and returns the resolved value.
         *
         * @param {string} path - The path being resolved, with a JSON pointer in the hash
         * @param {$RefParserOptions} [options]
         * @returns {*} - Returns the resolved value
         */
        $Refs.prototype.get = function (path, options) {
          return this._resolve(path, "", options).value;
        };

        /**
         * Sets the value of a nested property within this {@link $Ref#value}.
         * If the property, or any of its parents don't exist, they will be created.
         *
         * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash
         * @param {*} value - The value to assign
         */
        $Refs.prototype.set = function (path, value) {
          let absPath = url.resolve(this._root$Ref.path, path);
          let withoutHash = url.stripHash(absPath);
          let $ref = this._$refs[withoutHash];

          if (!$ref) {
            throw ono(`Error resolving $ref pointer "${path}". \n"${withoutHash}" not found.`);
          }

          $ref.set(absPath, value);
        };

        /**
         * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.
         *
         * @param {string} path  - The file path or URL of the referenced file
         */
        $Refs.prototype._add = function (path) {
          let withoutHash = url.stripHash(path);

          let $ref = new $Ref();
          $ref.path = withoutHash;
          $ref.$refs = this;

          this._$refs[withoutHash] = $ref;
          this._root$Ref = this._root$Ref || $ref;

          return $ref;
        };

        /**
         * Resolves the given JSON reference.
         *
         * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
         * @param {string} pathFromRoot - The path of `obj` from the schema root
         * @param {$RefParserOptions} [options]
         * @returns {Pointer}
         * @protected
         */
        $Refs.prototype._resolve = function (path, pathFromRoot, options) {
          let absPath = url.resolve(this._root$Ref.path, path);
          let withoutHash = url.stripHash(absPath);
          let $ref = this._$refs[withoutHash];

          if (!$ref) {
            throw ono(`Error resolving $ref pointer "${path}". \n"${withoutHash}" not found.`);
          }

          return $ref.resolve(absPath, options, path, pathFromRoot);
        };

        /**
         * Returns the specified {@link $Ref} object, or undefined.
         *
         * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
         * @returns {$Ref|undefined}
         * @protected
         */
        $Refs.prototype._get$Ref = function (path) {
          path = url.resolve(this._root$Ref.path, path);
          let withoutHash = url.stripHash(path);
          return this._$refs[withoutHash];
        };

        /**
         * Returns the encoded and decoded paths keys of the given object.
         *
         * @param {object} $refs - The object whose keys are URL-encoded paths
         * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
         * @returns {object[]}
         */
        function getPaths($refs, types) {
          let paths = Object.keys($refs);

          // Filter the paths by type
          types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);
          if (types.length > 0 && types[0]) {
            paths = paths.filter((key) => {
              return types.indexOf($refs[key].pathType) !== -1;
            });
          }

          // Decode local filesystem paths
          return paths.map((path) => {
            return {
              encoded: path,
              decoded: $refs[path].pathType === "file" ? url.toFileSystemPath(path, true) : path,
            };
          });
        }
      },
      { "./ref": 17, "./util/url": 24, "@jsdevtools/ono": 33 },
    ],
    19: [
      function (require, module, exports) {
        "use strict";

        const $Ref = require("./ref");
        const Pointer = require("./pointer");
        const parse = require("./parse");
        const url = require("./util/url");
        const { isHandledError } = require("./util/errors");

        module.exports = resolveExternal;

        /**
         * Crawls the JSON schema, finds all external JSON references, and resolves their values.
         * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.
         *
         * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.
         *
         * @param {$RefParser} parser
         * @param {$RefParserOptions} options
         *
         * @returns {Promise}
         * The promise resolves once all JSON references in the schema have been resolved,
         * including nested references that are contained in externally-referenced files.
         */
        function resolveExternal(parser, options) {
          if (!options.resolve.external) {
            // Nothing to resolve, so exit early
            return Promise.resolve();
          }

          try {
            // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);
            let promises = crawl(parser.schema, parser.$refs._root$Ref.path + "#", parser.$refs, options);
            return Promise.all(promises);
          } catch (e) {
            return Promise.reject(e);
          }
        }

        /**
         * Recursively crawls the given value, and resolves any external JSON references.
         *
         * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
         * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
         * @param {$Refs} $refs
         * @param {$RefParserOptions} options
         *
         * @returns {Promise[]}
         * Returns an array of promises. There will be one promise for each JSON reference in `obj`.
         * If `obj` does not contain any JSON references, then the array will be empty.
         * If any of the JSON references point to files that contain additional JSON references,
         * then the corresponding promise will internally reference an array of promises.
         */
        function crawl(obj, path, $refs, options) {
          let promises = [];

          if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
            if ($Ref.isExternal$Ref(obj)) {
              promises.push(resolve$Ref(obj, path, $refs, options));
            } else {
              for (let key of Object.keys(obj)) {
                let keyPath = Pointer.join(path, key);
                let value = obj[key];

                if ($Ref.isExternal$Ref(value)) {
                  promises.push(resolve$Ref(value, keyPath, $refs, options));
                } else {
                  promises = promises.concat(crawl(value, keyPath, $refs, options));
                }
              }
            }
          }

          return promises;
        }

        /**
         * Resolves the given JSON Reference, and then crawls the resulting value.
         *
         * @param {{$ref: string}} $ref - The JSON Reference to resolve
         * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
         * @param {$Refs} $refs
         * @param {$RefParserOptions} options
         *
         * @returns {Promise}
         * The promise resolves once all JSON references in the object have been resolved,
         * including nested references that are contained in externally-referenced files.
         */
        async function resolve$Ref($ref, path, $refs, options) {
          // console.log('Resolving $ref pointer "%s" at %s', $ref.$ref, path);

          let resolvedPath = url.resolve(path, $ref.$ref);
          let withoutHash = url.stripHash(resolvedPath);

          // Do we already have this $ref?
          $ref = $refs._$refs[withoutHash];
          if ($ref) {
            // We've already parsed this $ref, so use the existing value
            return Promise.resolve($ref.value);
          }

          // Parse the $referenced file/url
          try {
            const result = await parse(resolvedPath, $refs, options);

            // Crawl the parsed value
            // console.log('Resolving $ref pointers in %s', withoutHash);
            let promises = crawl(result, withoutHash + "#", $refs, options);

            return Promise.all(promises);
          } catch (err) {
            if (!options.continueOnError || !isHandledError(err)) {
              throw err;
            }

            if ($refs._$refs[withoutHash]) {
              err.source = url.stripHash(path);
              err.path = url.safePointerToPath(url.getHash(path));
            }

            return [];
          }
        }
      },
      { "./parse": 11, "./pointer": 16, "./ref": 17, "./util/errors": 22, "./util/url": 24 },
    ],
    20: [
      function (require, module, exports) {
        "use strict";
        const fs = require("fs");
        const { ono } = require("@jsdevtools/ono");
        const url = require("../util/url");
        const { ResolverError } = require("../util/errors");

        module.exports = {
          /**
           * The order that this resolver will run, in relation to other resolvers.
           *
           * @type {number}
           */
          order: 100,

          /**
           * Determines whether this resolver can read a given file reference.
           * Resolvers that return true will be tried, in order, until one successfully resolves the file.
           * Resolvers that return false will not be given a chance to resolve the file.
           *
           * @param {object} file           - An object containing information about the referenced file
           * @param {string} file.url       - The full URL of the referenced file
           * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
           * @returns {boolean}
           */
          canRead(file) {
            return url.isFileSystemPath(file.url);
          },

          /**
           * Reads the given file and returns its raw contents as a Buffer.
           *
           * @param {object} file           - An object containing information about the referenced file
           * @param {string} file.url       - The full URL of the referenced file
           * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
           * @returns {Promise<Buffer>}
           */
          read(file) {
            return new Promise((resolve, reject) => {
              let path;
              try {
                path = url.toFileSystemPath(file.url);
              } catch (err) {
                reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));
              }

              // console.log('Opening file: %s', path);

              try {
                fs.readFile(path, (err, data) => {
                  if (err) {
                    reject(new ResolverError(ono(err, `Error opening file "${path}"`), path));
                  } else {
                    resolve(data);
                  }
                });
              } catch (err) {
                reject(new ResolverError(ono(err, `Error opening file "${path}"`), path));
              }
            });
          },
        };
      },
      { "../util/errors": 22, "../util/url": 24, "@jsdevtools/ono": 33, fs: 131 },
    ],
    21: [
      function (require, module, exports) {
        (function (process, Buffer) {
          (function () {
            "use strict";

            const http = require("http");
            const https = require("https");
            const { ono } = require("@jsdevtools/ono");
            const url = require("../util/url");
            const { ResolverError } = require("../util/errors");

            module.exports = {
              /**
               * The order that this resolver will run, in relation to other resolvers.
               *
               * @type {number}
               */
              order: 200,

              /**
               * HTTP headers to send when downloading files.
               *
               * @example:
               * {
               *   "User-Agent": "JSON Schema $Ref Parser",
               *   Accept: "application/json"
               * }
               *
               * @type {object}
               */
              headers: null,

              /**
               * HTTP request timeout (in milliseconds).
               *
               * @type {number}
               */
              timeout: 5000, // 5 seconds

              /**
               * The maximum number of HTTP redirects to follow.
               * To disable automatic following of redirects, set this to zero.
               *
               * @type {number}
               */
              redirects: 5,

              /**
               * The `withCredentials` option of XMLHttpRequest.
               * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
               *
               * @type {boolean}
               */
              withCredentials: false,

              /**
               * Determines whether this resolver can read a given file reference.
               * Resolvers that return true will be tried in order, until one successfully resolves the file.
               * Resolvers that return false will not be given a chance to resolve the file.
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @returns {boolean}
               */
              canRead(file) {
                return url.isHttp(file.url);
              },

              /**
               * Reads the given URL and returns its raw contents as a Buffer.
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @returns {Promise<Buffer>}
               */
              read(file) {
                let u = url.parse(file.url);

                if (process.browser && !u.protocol) {
                  // Use the protocol of the current page
                  u.protocol = url.parse(location.href).protocol;
                }

                return download(u, this);
              },
            };

            /**
             * Downloads the given file.
             *
             * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)
             * @param {object} httpOptions  - The `options.resolve.http` object
             * @param {number} [redirects]  - The redirect URLs that have already been followed
             *
             * @returns {Promise<Buffer>}
             * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.
             */
            function download(u, httpOptions, redirects) {
              return new Promise((resolve, reject) => {
                u = url.parse(u);
                redirects = redirects || [];
                redirects.push(u.href);

                get(u, httpOptions)
                  .then((res) => {
                    if (res.statusCode >= 400) {
                      throw ono({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);
                    } else if (res.statusCode >= 300) {
                      if (redirects.length > httpOptions.redirects) {
                        reject(
                          new ResolverError(
                            ono(
                              { status: res.statusCode },
                              `Error downloading ${redirects[0]}. \nToo many redirects: \n  ${redirects.join(" \n  ")}`,
                            ),
                          ),
                        );
                      } else if (!res.headers.location) {
                        throw ono(
                          { status: res.statusCode },
                          `HTTP ${res.statusCode} redirect with no location header`,
                        );
                      } else {
                        // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);
                        let redirectTo = url.resolve(u, res.headers.location);
                        download(redirectTo, httpOptions, redirects).then(resolve, reject);
                      }
                    } else {
                      resolve(res.body || Buffer.alloc(0));
                    }
                  })
                  .catch((err) => {
                    reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));
                  });
              });
            }

            /**
             * Sends an HTTP GET request.
             *
             * @param {Url} u - A parsed {@link Url} object
             * @param {object} httpOptions - The `options.resolve.http` object
             *
             * @returns {Promise<Response>}
             * The promise resolves with the HTTP Response object.
             */
            function get(u, httpOptions) {
              return new Promise((resolve, reject) => {
                // console.log('GET', u.href);

                let protocol = u.protocol === "https:" ? https : http;
                let req = protocol.get({
                  hostname: u.hostname,
                  port: u.port,
                  path: u.path,
                  auth: u.auth,
                  protocol: u.protocol,
                  headers: httpOptions.headers || {},
                  withCredentials: httpOptions.withCredentials,
                });

                if (typeof req.setTimeout === "function") {
                  req.setTimeout(httpOptions.timeout);
                }

                req.on("timeout", () => {
                  req.abort();
                });

                req.on("error", reject);

                req.once("response", (res) => {
                  res.body = Buffer.alloc(0);

                  res.on("data", (data) => {
                    res.body = Buffer.concat([res.body, Buffer.from(data)]);
                  });

                  res.on("error", reject);

                  res.on("end", () => {
                    resolve(res);
                  });
                });
              });
            }
          }).call(this);
        }).call(this, require("_process"), require("buffer").Buffer);
      },
      {
        "../util/errors": 22,
        "../util/url": 24,
        "@jsdevtools/ono": 33,
        _process: 172,
        buffer: 132,
        http: 192,
        https: 137,
      },
    ],
    22: [
      function (require, module, exports) {
        "use strict";

        const { Ono } = require("@jsdevtools/ono");

        const { stripHash, toFileSystemPath } = require("./url");

        const JSONParserError = (exports.JSONParserError = class JSONParserError extends Error {
          constructor(message, source) {
            super();

            this.code = "EUNKNOWN";
            this.message = message;
            this.source = source;
            this.path = null;

            Ono.extend(this);
          }
        });

        setErrorName(JSONParserError);

        const JSONParserErrorGroup = (exports.JSONParserErrorGroup = class JSONParserErrorGroup extends Error {
          constructor(parser) {
            super();

            this.files = parser;
            this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${toFileSystemPath(parser.$refs._root$Ref.path)}'`;

            Ono.extend(this);
          }

          static getParserErrors(parser) {
            const errors = [];

            for (const $ref of Object.values(parser.$refs._$refs)) {
              if ($ref.errors) {
                errors.push(...$ref.errors);
              }
            }

            return errors;
          }

          get errors() {
            return JSONParserErrorGroup.getParserErrors(this.files);
          }
        });

        setErrorName(JSONParserErrorGroup);

        const ParserError = (exports.ParserError = class ParserError extends JSONParserError {
          constructor(message, source) {
            super(`Error parsing ${source}: ${message}`, source);

            this.code = "EPARSER";
          }
        });

        setErrorName(ParserError);

        const UnmatchedParserError = (exports.UnmatchedParserError = class UnmatchedParserError extends (
          JSONParserError
        ) {
          constructor(source) {
            super(`Could not find parser for "${source}"`, source);

            this.code = "EUNMATCHEDPARSER";
          }
        });

        setErrorName(UnmatchedParserError);

        const ResolverError = (exports.ResolverError = class ResolverError extends JSONParserError {
          constructor(ex, source) {
            super(ex.message || `Error reading file "${source}"`, source);

            this.code = "ERESOLVER";

            if ("code" in ex) {
              this.ioErrorCode = String(ex.code);
            }
          }
        });

        setErrorName(ResolverError);

        const UnmatchedResolverError = (exports.UnmatchedResolverError = class UnmatchedResolverError extends (
          JSONParserError
        ) {
          constructor(source) {
            super(`Could not find resolver for "${source}"`, source);

            this.code = "EUNMATCHEDRESOLVER";
          }
        });

        setErrorName(UnmatchedResolverError);

        const MissingPointerError = (exports.MissingPointerError = class MissingPointerError extends JSONParserError {
          constructor(token, path) {
            super(`Token "${token}" does not exist.`, stripHash(path));

            this.code = "EMISSINGPOINTER";
          }
        });

        setErrorName(MissingPointerError);

        const InvalidPointerError = (exports.InvalidPointerError = class InvalidPointerError extends JSONParserError {
          constructor(pointer, path) {
            super(`Invalid $ref pointer "${pointer}". Pointers must begin with "#/"`, stripHash(path));

            this.code = "EINVALIDPOINTER";
          }
        });

        setErrorName(InvalidPointerError);

        function setErrorName(err) {
          Object.defineProperty(err.prototype, "name", {
            value: err.name,
            enumerable: true,
          });
        }

        exports.isHandledError = function (err) {
          return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;
        };

        exports.normalizeError = function (err) {
          if (err.path === null) {
            err.path = [];
          }

          return err;
        };
      },
      { "./url": 24, "@jsdevtools/ono": 33 },
    ],
    23: [
      function (require, module, exports) {
        "use strict";

        /**
         * Returns the given plugins as an array, rather than an object map.
         * All other methods in this module expect an array of plugins rather than an object map.
         *
         * @param  {object} plugins - A map of plugin objects
         * @return {object[]}
         */
        exports.all = function (plugins) {
          return Object.keys(plugins)
            .filter((key) => {
              return typeof plugins[key] === "object";
            })
            .map((key) => {
              plugins[key].name = key;
              return plugins[key];
            });
        };

        /**
         * Filters the given plugins, returning only the ones return `true` for the given method.
         *
         * @param  {object[]} plugins - An array of plugin objects
         * @param  {string}   method  - The name of the filter method to invoke for each plugin
         * @param  {object}   file    - A file info object, which will be passed to each method
         * @return {object[]}
         */
        exports.filter = function (plugins, method, file) {
          return plugins.filter((plugin) => {
            return !!getResult(plugin, method, file);
          });
        };

        /**
         * Sorts the given plugins, in place, by their `order` property.
         *
         * @param {object[]} plugins - An array of plugin objects
         * @returns {object[]}
         */
        exports.sort = function (plugins) {
          for (let plugin of plugins) {
            plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
          }

          return plugins.sort((a, b) => {
            return a.order - b.order;
          });
        };

        /**
         * Runs the specified method of the given plugins, in order, until one of them returns a successful result.
         * Each method can return a synchronous value, a Promise, or call an error-first callback.
         * If the promise resolves successfully, or the callback is called without an error, then the result
         * is immediately returned and no further plugins are called.
         * If the promise rejects, or the callback is called with an error, then the next plugin is called.
         * If ALL plugins fail, then the last error is thrown.
         *
         * @param {object[]}  plugins - An array of plugin objects
         * @param {string}    method  - The name of the method to invoke for each plugin
         * @param {object}    file    - A file info object, which will be passed to each method
         * @returns {Promise}
         */
        exports.run = function (plugins, method, file, $refs) {
          let plugin,
            lastError,
            index = 0;

          return new Promise((resolve, reject) => {
            runNextPlugin();

            function runNextPlugin() {
              plugin = plugins[index++];
              if (!plugin) {
                // There are no more functions, so re-throw the last error
                return reject(lastError);
              }

              try {
                // console.log('  %s', plugin.name);
                let result = getResult(plugin, method, file, callback, $refs);
                if (result && typeof result.then === "function") {
                  // A promise was returned
                  result.then(onSuccess, onError);
                } else if (result !== undefined) {
                  // A synchronous result was returned
                  onSuccess(result);
                } else if (index === plugins.length) {
                  throw new Error("No promise has been returned or callback has been called.");
                }
              } catch (e) {
                onError(e);
              }
            }

            function callback(err, result) {
              if (err) {
                onError(err);
              } else {
                onSuccess(result);
              }
            }

            function onSuccess(result) {
              // console.log('    success');
              resolve({
                plugin,
                result,
              });
            }

            function onError(error) {
              // console.log('    %s', err.message || err);
              lastError = {
                plugin,
                error,
              };
              runNextPlugin();
            }
          });
        };

        /**
         * Returns the value of the given property.
         * If the property is a function, then the result of the function is returned.
         * If the value is a RegExp, then it will be tested against the file URL.
         * If the value is an aray, then it will be compared against the file extension.
         *
         * @param   {object}   obj        - The object whose property/method is called
         * @param   {string}   prop       - The name of the property/method to invoke
         * @param   {object}   file       - A file info object, which will be passed to the method
         * @param   {function} [callback] - A callback function, which will be passed to the method
         * @returns {*}
         */
        function getResult(obj, prop, file, callback, $refs) {
          let value = obj[prop];

          if (typeof value === "function") {
            return value.apply(obj, [file, callback, $refs]);
          }

          if (!callback) {
            // The synchronous plugin functions (canParse and canRead)
            // allow a "shorthand" syntax, where the user can match
            // files by RegExp or by file extension.
            if (value instanceof RegExp) {
              return value.test(file.url);
            } else if (typeof value === "string") {
              return value === file.extension;
            } else if (Array.isArray(value)) {
              return value.indexOf(file.extension) !== -1;
            }
          }

          return value;
        }
      },
      {},
    ],
    24: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            "use strict";

            let isWindows = /^win/.test(process.platform),
              forwardSlashPattern = /\//g,
              protocolPattern = /^(\w{2,}):\/\//i,
              url = module.exports,
              jsonPointerSlash = /~1/g,
              jsonPointerTilde = /~0/g;

            // RegExp patterns to URL-encode special characters in local filesystem paths
            let urlEncodePatterns = [/\?/g, "%3F", /\#/g, "%23"];

            // RegExp patterns to URL-decode special characters for local filesystem paths
            let urlDecodePatterns = [/\%23/g, "#", /\%24/g, "$", /\%26/g, "&", /\%2C/g, ",", /\%40/g, "@"];

            exports.parse = require("url").parse;
            exports.resolve = require("url").resolve;

            /**
             * Returns the current working directory (in Node) or the current page URL (in browsers).
             *
             * @returns {string}
             */
            exports.cwd = function cwd() {
              if (process.browser) {
                return location.href;
              }

              let path = process.cwd();

              let lastChar = path.slice(-1);
              if (lastChar === "/" || lastChar === "\\") {
                return path;
              } else {
                return path + "/";
              }
            };

            /**
             * Returns the protocol of the given URL, or `undefined` if it has no protocol.
             *
             * @param   {string} path
             * @returns {?string}
             */
            exports.getProtocol = function getProtocol(path) {
              let match = protocolPattern.exec(path);
              if (match) {
                return match[1].toLowerCase();
              }
            };

            /**
             * Returns the lowercased file extension of the given URL,
             * or an empty string if it has no extension.
             *
             * @param   {string} path
             * @returns {string}
             */
            exports.getExtension = function getExtension(path) {
              let lastDot = path.lastIndexOf(".");
              if (lastDot >= 0) {
                return path.substr(lastDot).toLowerCase();
              }
              return "";
            };

            /**
             * Returns the hash (URL fragment), of the given path.
             * If there is no hash, then the root hash ("#") is returned.
             *
             * @param   {string} path
             * @returns {string}
             */
            exports.getHash = function getHash(path) {
              let hashIndex = path.indexOf("#");
              if (hashIndex >= 0) {
                return path.substr(hashIndex);
              }
              return "#";
            };

            /**
             * Removes the hash (URL fragment), if any, from the given path.
             *
             * @param   {string} path
             * @returns {string}
             */
            exports.stripHash = function stripHash(path) {
              let hashIndex = path.indexOf("#");
              if (hashIndex >= 0) {
                path = path.substr(0, hashIndex);
              }
              return path;
            };

            /**
             * Determines whether the given path is an HTTP(S) URL.
             *
             * @param   {string} path
             * @returns {boolean}
             */
            exports.isHttp = function isHttp(path) {
              let protocol = url.getProtocol(path);
              if (protocol === "http" || protocol === "https") {
                return true;
              } else if (protocol === undefined) {
                // There is no protocol.  If we're running in a browser, then assume it's HTTP.
                return process.browser;
              } else {
                // It's some other protocol, such as "ftp://", "mongodb://", etc.
                return false;
              }
            };

            /**
             * Determines whether the given path is a filesystem path.
             * This includes "file://" URLs.
             *
             * @param   {string} path
             * @returns {boolean}
             */
            exports.isFileSystemPath = function isFileSystemPath(path) {
              if (process.browser) {
                // We're running in a browser, so assume that all paths are URLs.
                // This way, even relative paths will be treated as URLs rather than as filesystem paths
                return false;
              }

              let protocol = url.getProtocol(path);
              return protocol === undefined || protocol === "file";
            };

            /**
             * Converts a filesystem path to a properly-encoded URL.
             *
             * This is intended to handle situations where JSON Schema $Ref Parser is called
             * with a filesystem path that contains characters which are not allowed in URLs.
             *
             * @example
             * The following filesystem paths would be converted to the following URLs:
             *
             *    <"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\'%3E.json
             *    C:\\My Documents\\File (1).json   ==>   C:/My%20Documents/File%20(1).json
             *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json
             *
             * @param {string} path
             * @returns {string}
             */
            exports.fromFileSystemPath = function fromFileSystemPath(path) {
              // Step 1: On Windows, replace backslashes with forward slashes,
              // rather than encoding them as "%5C"
              if (isWindows) {
                path = path.replace(/\\/g, "/");
              }

              // Step 2: `encodeURI` will take care of MOST characters
              path = encodeURI(path);

              // Step 3: Manually encode characters that are not encoded by `encodeURI`.
              // This includes characters such as "#" and "?", which have special meaning in URLs,
              // but are just normal characters in a filesystem path.
              for (let i = 0; i < urlEncodePatterns.length; i += 2) {
                path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);
              }

              return path;
            };

            /**
             * Converts a URL to a local filesystem path.
             *
             * @param {string}  path
             * @param {boolean} [keepFileProtocol] - If true, then "file://" will NOT be stripped
             * @returns {string}
             */
            exports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {
              // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.
              path = decodeURI(path);

              // Step 2: Manually decode characters that are not decoded by `decodeURI`.
              // This includes characters such as "#" and "?", which have special meaning in URLs,
              // but are just normal characters in a filesystem path.
              for (let i = 0; i < urlDecodePatterns.length; i += 2) {
                path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);
              }

              // Step 3: If it's a "file://" URL, then format it consistently
              // or convert it to a local filesystem path
              let isFileUrl = path.substr(0, 7).toLowerCase() === "file://";
              if (isFileUrl) {
                // Strip-off the protocol, and the initial "/", if there is one
                path = path[7] === "/" ? path.substr(8) : path.substr(7);

                // insert a colon (":") after the drive letter on Windows
                if (isWindows && path[1] === "/") {
                  path = path[0] + ":" + path.substr(1);
                }

                if (keepFileProtocol) {
                  // Return the consistently-formatted "file://" URL
                  path = "file:///" + path;
                } else {
                  // Convert the "file://" URL to a local filesystem path.
                  // On Windows, it will start with something like "C:/".
                  // On Posix, it will start with "/"
                  isFileUrl = false;
                  path = isWindows ? path : "/" + path;
                }
              }

              // Step 4: Normalize Windows paths (unless it's a "file://" URL)
              if (isWindows && !isFileUrl) {
                // Replace forward slashes with backslashes
                path = path.replace(forwardSlashPattern, "\\");

                // Capitalize the drive letter
                if (path.substr(1, 2) === ":\\") {
                  path = path[0].toUpperCase() + path.substr(1);
                }
              }

              return path;
            };

            /**
             * Converts a $ref pointer to a valid JSON Path.
             *
             * @param {string}  pointer
             * @returns {Array<number | string>}
             */
            exports.safePointerToPath = function safePointerToPath(pointer) {
              if (pointer.length <= 1 || pointer[0] !== "#" || pointer[1] !== "/") {
                return [];
              }

              return pointer
                .slice(2)
                .split("/")
                .map((value) => {
                  return decodeURIComponent(value).replace(jsonPointerSlash, "/").replace(jsonPointerTilde, "~");
                });
            };
          }).call(this);
        }).call(this, require("_process"));
      },
      { _process: 172, url: 199 },
    ],
    25: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.openapi = exports.openapiV31 = exports.openapiV3 = exports.openapiV2 = exports.openapiV1 = void 0;
        /**
         * JSON Schema for OpenAPI Specification v1.2
         */
        exports.openapiV1 = require("../schemas/v1.2/apiDeclaration.json");
        /**
         * JSON Schema for OpenAPI Specification v2.0
         */
        exports.openapiV2 = require("../schemas/v2.0/schema.json");
        /**
         * JSON Schema for OpenAPI Specification v3.0
         */
        exports.openapiV3 = require("../schemas/v3.0/schema.json");
        /**
         * JSON Schema for OpenAPI Specification v3.1
         */
        exports.openapiV31 = require("../schemas/v3.1/schema.json");
        /**
         * JSON Schemas for every version of the OpenAPI Specification
         */
        exports.openapi = {
          v1: exports.openapiV1,
          v2: exports.openapiV2,
          v3: exports.openapiV3,
          v31: exports.openapiV31,
        };
        // Export `openapi` as the default export
        exports.default = exports.openapi;
        // CommonJS default export hack
        /* eslint-env commonjs */
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = Object.assign(module.exports.default, module.exports);
        }
      },
      {
        "../schemas/v1.2/apiDeclaration.json": 26,
        "../schemas/v2.0/schema.json": 27,
        "../schemas/v3.0/schema.json": 28,
        "../schemas/v3.1/schema.json": 29,
      },
    ],
    26: [
      function (require, module, exports) {
        module.exports = {
          id: "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#",
          $schema: "http://json-schema.org/draft-04/schema#",
          type: "object",
          required: ["swaggerVersion", "basePath", "apis"],
          properties: {
            swaggerVersion: { enum: ["1.2"] },
            apiVersion: { type: "string" },
            basePath: {
              type: "string",
              format: "uri",
              pattern: "^https?://",
            },
            resourcePath: {
              type: "string",
              format: "uri",
              pattern: "^/",
            },
            apis: {
              type: "array",
              items: { $ref: "#/definitions/apiObject" },
            },
            models: {
              type: "object",
              additionalProperties: {
                $ref: "modelsObject.json#",
              },
            },
            produces: { $ref: "#/definitions/mimeTypeArray" },
            consumes: { $ref: "#/definitions/mimeTypeArray" },
            authorizations: { $ref: "authorizationObject.json#" },
          },
          additionalProperties: false,
          definitions: {
            apiObject: {
              type: "object",
              required: ["path", "operations"],
              properties: {
                path: {
                  type: "string",
                  format: "uri-template",
                  pattern: "^/",
                },
                description: { type: "string" },
                operations: {
                  type: "array",
                  items: { $ref: "operationObject.json#" },
                },
              },
              additionalProperties: false,
            },
            mimeTypeArray: {
              type: "array",
              items: {
                type: "string",
                format: "mime-type",
              },
              uniqueItems: true,
            },
          },
        };
      },
      {},
    ],
    27: [
      function (require, module, exports) {
        module.exports = {
          title: "A JSON Schema for Swagger 2.0 API.",
          id: "http://swagger.io/v2/schema.json#",
          $schema: "http://json-schema.org/draft-04/schema#",
          type: "object",
          required: ["swagger", "info", "paths"],
          additionalProperties: false,
          patternProperties: {
            "^x-": {
              $ref: "#/definitions/vendorExtension",
            },
          },
          properties: {
            swagger: {
              type: "string",
              enum: ["2.0"],
              description: "The Swagger version of this document.",
            },
            info: {
              $ref: "#/definitions/info",
            },
            host: {
              type: "string",
              pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
              description: "The host (name or ip) of the API. Example: 'swagger.io'",
            },
            basePath: {
              type: "string",
              pattern: "^/",
              description: "The base path to the API. Example: '/api'.",
            },
            schemes: {
              $ref: "#/definitions/schemesList",
            },
            consumes: {
              description: "A list of MIME types accepted by the API.",
              allOf: [
                {
                  $ref: "#/definitions/mediaTypeList",
                },
              ],
            },
            produces: {
              description: "A list of MIME types the API can produce.",
              allOf: [
                {
                  $ref: "#/definitions/mediaTypeList",
                },
              ],
            },
            paths: {
              $ref: "#/definitions/paths",
            },
            definitions: {
              $ref: "#/definitions/definitions",
            },
            parameters: {
              $ref: "#/definitions/parameterDefinitions",
            },
            responses: {
              $ref: "#/definitions/responseDefinitions",
            },
            security: {
              $ref: "#/definitions/security",
            },
            securityDefinitions: {
              $ref: "#/definitions/securityDefinitions",
            },
            tags: {
              type: "array",
              items: {
                $ref: "#/definitions/tag",
              },
              uniqueItems: true,
            },
            externalDocs: {
              $ref: "#/definitions/externalDocs",
            },
          },
          definitions: {
            info: {
              type: "object",
              description: "General information about the API.",
              required: ["version", "title"],
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                title: {
                  type: "string",
                  description: "A unique and precise title of the API.",
                },
                version: {
                  type: "string",
                  description: "A semantic version number of the API.",
                },
                description: {
                  type: "string",
                  description:
                    "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.",
                },
                termsOfService: {
                  type: "string",
                  description: "The terms of service for the API.",
                },
                contact: {
                  $ref: "#/definitions/contact",
                },
                license: {
                  $ref: "#/definitions/license",
                },
              },
            },
            contact: {
              type: "object",
              description: "Contact information for the owners of the API.",
              additionalProperties: false,
              properties: {
                name: {
                  type: "string",
                  description: "The identifying name of the contact person/organization.",
                },
                url: {
                  type: "string",
                  description: "The URL pointing to the contact information.",
                  format: "uri",
                },
                email: {
                  type: "string",
                  description: "The email address of the contact person/organization.",
                  format: "email",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            license: {
              type: "object",
              required: ["name"],
              additionalProperties: false,
              properties: {
                name: {
                  type: "string",
                  description: "The name of the license type. It's encouraged to use an OSI compatible license.",
                },
                url: {
                  type: "string",
                  description: "The URL pointing to the license.",
                  format: "uri",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            paths: {
              type: "object",
              description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
                "^/": {
                  $ref: "#/definitions/pathItem",
                },
              },
              additionalProperties: false,
            },
            definitions: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/schema",
              },
              description: "One or more JSON objects describing the schemas being consumed and produced by the API.",
            },
            parameterDefinitions: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/parameter",
              },
              description: "One or more JSON representations for parameters",
            },
            responseDefinitions: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/response",
              },
              description: "One or more JSON representations for responses",
            },
            externalDocs: {
              type: "object",
              additionalProperties: false,
              description: "information about external documentation",
              required: ["url"],
              properties: {
                description: {
                  type: "string",
                },
                url: {
                  type: "string",
                  format: "uri",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            examples: {
              type: "object",
              additionalProperties: true,
            },
            mimeType: {
              type: "string",
              description: "The MIME type of the HTTP message.",
            },
            operation: {
              type: "object",
              required: ["responses"],
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                tags: {
                  type: "array",
                  items: {
                    type: "string",
                  },
                  uniqueItems: true,
                },
                summary: {
                  type: "string",
                  description: "A brief summary of the operation.",
                },
                description: {
                  type: "string",
                  description: "A longer description of the operation, GitHub Flavored Markdown is allowed.",
                },
                externalDocs: {
                  $ref: "#/definitions/externalDocs",
                },
                operationId: {
                  type: "string",
                  description: "A unique identifier of the operation.",
                },
                produces: {
                  description: "A list of MIME types the API can produce.",
                  allOf: [
                    {
                      $ref: "#/definitions/mediaTypeList",
                    },
                  ],
                },
                consumes: {
                  description: "A list of MIME types the API can consume.",
                  allOf: [
                    {
                      $ref: "#/definitions/mediaTypeList",
                    },
                  ],
                },
                parameters: {
                  $ref: "#/definitions/parametersList",
                },
                responses: {
                  $ref: "#/definitions/responses",
                },
                schemes: {
                  $ref: "#/definitions/schemesList",
                },
                deprecated: {
                  type: "boolean",
                  default: false,
                },
                security: {
                  $ref: "#/definitions/security",
                },
              },
            },
            pathItem: {
              type: "object",
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                $ref: {
                  type: "string",
                },
                get: {
                  $ref: "#/definitions/operation",
                },
                put: {
                  $ref: "#/definitions/operation",
                },
                post: {
                  $ref: "#/definitions/operation",
                },
                delete: {
                  $ref: "#/definitions/operation",
                },
                options: {
                  $ref: "#/definitions/operation",
                },
                head: {
                  $ref: "#/definitions/operation",
                },
                patch: {
                  $ref: "#/definitions/operation",
                },
                parameters: {
                  $ref: "#/definitions/parametersList",
                },
              },
            },
            responses: {
              type: "object",
              description: "Response objects names can either be any valid HTTP status code or 'default'.",
              minProperties: 1,
              additionalProperties: false,
              patternProperties: {
                "^([0-9]{3})$|^(default)$": {
                  $ref: "#/definitions/responseValue",
                },
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              not: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": {
                    $ref: "#/definitions/vendorExtension",
                  },
                },
              },
            },
            responseValue: {
              oneOf: [
                {
                  $ref: "#/definitions/response",
                },
                {
                  $ref: "#/definitions/jsonReference",
                },
              ],
            },
            response: {
              type: "object",
              required: ["description"],
              properties: {
                description: {
                  type: "string",
                },
                schema: {
                  oneOf: [
                    {
                      $ref: "#/definitions/schema",
                    },
                    {
                      $ref: "#/definitions/fileSchema",
                    },
                  ],
                },
                headers: {
                  $ref: "#/definitions/headers",
                },
                examples: {
                  $ref: "#/definitions/examples",
                },
              },
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            headers: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/header",
              },
            },
            header: {
              type: "object",
              additionalProperties: false,
              required: ["type"],
              properties: {
                type: {
                  type: "string",
                  enum: ["string", "number", "integer", "boolean", "array"],
                },
                format: {
                  type: "string",
                },
                items: {
                  $ref: "#/definitions/primitivesItems",
                },
                collectionFormat: {
                  $ref: "#/definitions/collectionFormat",
                },
                default: {
                  $ref: "#/definitions/default",
                },
                maximum: {
                  $ref: "#/definitions/maximum",
                },
                exclusiveMaximum: {
                  $ref: "#/definitions/exclusiveMaximum",
                },
                minimum: {
                  $ref: "#/definitions/minimum",
                },
                exclusiveMinimum: {
                  $ref: "#/definitions/exclusiveMinimum",
                },
                maxLength: {
                  $ref: "#/definitions/maxLength",
                },
                minLength: {
                  $ref: "#/definitions/minLength",
                },
                pattern: {
                  $ref: "#/definitions/pattern",
                },
                maxItems: {
                  $ref: "#/definitions/maxItems",
                },
                minItems: {
                  $ref: "#/definitions/minItems",
                },
                uniqueItems: {
                  $ref: "#/definitions/uniqueItems",
                },
                enum: {
                  $ref: "#/definitions/enum",
                },
                multipleOf: {
                  $ref: "#/definitions/multipleOf",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            vendorExtension: {
              description: "Any property starting with x- is valid.",
              additionalProperties: true,
              additionalItems: true,
            },
            bodyParameter: {
              type: "object",
              required: ["name", "in", "schema"],
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: {
                  type: "string",
                  description: "The name of the parameter.",
                },
                in: {
                  type: "string",
                  description: "Determines the location of the parameter.",
                  enum: ["body"],
                },
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: false,
                },
                schema: {
                  $ref: "#/definitions/schema",
                },
              },
              additionalProperties: false,
            },
            headerParameterSubSchema: {
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: false,
                },
                in: {
                  type: "string",
                  description: "Determines the location of the parameter.",
                  enum: ["header"],
                },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: {
                  type: "string",
                  description: "The name of the parameter.",
                },
                type: {
                  type: "string",
                  enum: ["string", "number", "boolean", "integer", "array"],
                },
                format: {
                  type: "string",
                },
                items: {
                  $ref: "#/definitions/primitivesItems",
                },
                collectionFormat: {
                  $ref: "#/definitions/collectionFormat",
                },
                default: {
                  $ref: "#/definitions/default",
                },
                maximum: {
                  $ref: "#/definitions/maximum",
                },
                exclusiveMaximum: {
                  $ref: "#/definitions/exclusiveMaximum",
                },
                minimum: {
                  $ref: "#/definitions/minimum",
                },
                exclusiveMinimum: {
                  $ref: "#/definitions/exclusiveMinimum",
                },
                maxLength: {
                  $ref: "#/definitions/maxLength",
                },
                minLength: {
                  $ref: "#/definitions/minLength",
                },
                pattern: {
                  $ref: "#/definitions/pattern",
                },
                maxItems: {
                  $ref: "#/definitions/maxItems",
                },
                minItems: {
                  $ref: "#/definitions/minItems",
                },
                uniqueItems: {
                  $ref: "#/definitions/uniqueItems",
                },
                enum: {
                  $ref: "#/definitions/enum",
                },
                multipleOf: {
                  $ref: "#/definitions/multipleOf",
                },
              },
            },
            queryParameterSubSchema: {
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: false,
                },
                in: {
                  type: "string",
                  description: "Determines the location of the parameter.",
                  enum: ["query"],
                },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: {
                  type: "string",
                  description: "The name of the parameter.",
                },
                allowEmptyValue: {
                  type: "boolean",
                  default: false,
                  description: "allows sending a parameter by name only or with an empty value.",
                },
                type: {
                  type: "string",
                  enum: ["string", "number", "boolean", "integer", "array"],
                },
                format: {
                  type: "string",
                },
                items: {
                  $ref: "#/definitions/primitivesItems",
                },
                collectionFormat: {
                  $ref: "#/definitions/collectionFormatWithMulti",
                },
                default: {
                  $ref: "#/definitions/default",
                },
                maximum: {
                  $ref: "#/definitions/maximum",
                },
                exclusiveMaximum: {
                  $ref: "#/definitions/exclusiveMaximum",
                },
                minimum: {
                  $ref: "#/definitions/minimum",
                },
                exclusiveMinimum: {
                  $ref: "#/definitions/exclusiveMinimum",
                },
                maxLength: {
                  $ref: "#/definitions/maxLength",
                },
                minLength: {
                  $ref: "#/definitions/minLength",
                },
                pattern: {
                  $ref: "#/definitions/pattern",
                },
                maxItems: {
                  $ref: "#/definitions/maxItems",
                },
                minItems: {
                  $ref: "#/definitions/minItems",
                },
                uniqueItems: {
                  $ref: "#/definitions/uniqueItems",
                },
                enum: {
                  $ref: "#/definitions/enum",
                },
                multipleOf: {
                  $ref: "#/definitions/multipleOf",
                },
              },
            },
            formDataParameterSubSchema: {
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: false,
                },
                in: {
                  type: "string",
                  description: "Determines the location of the parameter.",
                  enum: ["formData"],
                },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: {
                  type: "string",
                  description: "The name of the parameter.",
                },
                allowEmptyValue: {
                  type: "boolean",
                  default: false,
                  description: "allows sending a parameter by name only or with an empty value.",
                },
                type: {
                  type: "string",
                  enum: ["string", "number", "boolean", "integer", "array", "file"],
                },
                format: {
                  type: "string",
                },
                items: {
                  $ref: "#/definitions/primitivesItems",
                },
                collectionFormat: {
                  $ref: "#/definitions/collectionFormatWithMulti",
                },
                default: {
                  $ref: "#/definitions/default",
                },
                maximum: {
                  $ref: "#/definitions/maximum",
                },
                exclusiveMaximum: {
                  $ref: "#/definitions/exclusiveMaximum",
                },
                minimum: {
                  $ref: "#/definitions/minimum",
                },
                exclusiveMinimum: {
                  $ref: "#/definitions/exclusiveMinimum",
                },
                maxLength: {
                  $ref: "#/definitions/maxLength",
                },
                minLength: {
                  $ref: "#/definitions/minLength",
                },
                pattern: {
                  $ref: "#/definitions/pattern",
                },
                maxItems: {
                  $ref: "#/definitions/maxItems",
                },
                minItems: {
                  $ref: "#/definitions/minItems",
                },
                uniqueItems: {
                  $ref: "#/definitions/uniqueItems",
                },
                enum: {
                  $ref: "#/definitions/enum",
                },
                multipleOf: {
                  $ref: "#/definitions/multipleOf",
                },
              },
            },
            pathParameterSubSchema: {
              additionalProperties: false,
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              required: ["required"],
              properties: {
                required: {
                  type: "boolean",
                  enum: [true],
                  description: "Determines whether or not this parameter is required or optional.",
                },
                in: {
                  type: "string",
                  description: "Determines the location of the parameter.",
                  enum: ["path"],
                },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: {
                  type: "string",
                  description: "The name of the parameter.",
                },
                type: {
                  type: "string",
                  enum: ["string", "number", "boolean", "integer", "array"],
                },
                format: {
                  type: "string",
                },
                items: {
                  $ref: "#/definitions/primitivesItems",
                },
                collectionFormat: {
                  $ref: "#/definitions/collectionFormat",
                },
                default: {
                  $ref: "#/definitions/default",
                },
                maximum: {
                  $ref: "#/definitions/maximum",
                },
                exclusiveMaximum: {
                  $ref: "#/definitions/exclusiveMaximum",
                },
                minimum: {
                  $ref: "#/definitions/minimum",
                },
                exclusiveMinimum: {
                  $ref: "#/definitions/exclusiveMinimum",
                },
                maxLength: {
                  $ref: "#/definitions/maxLength",
                },
                minLength: {
                  $ref: "#/definitions/minLength",
                },
                pattern: {
                  $ref: "#/definitions/pattern",
                },
                maxItems: {
                  $ref: "#/definitions/maxItems",
                },
                minItems: {
                  $ref: "#/definitions/minItems",
                },
                uniqueItems: {
                  $ref: "#/definitions/uniqueItems",
                },
                enum: {
                  $ref: "#/definitions/enum",
                },
                multipleOf: {
                  $ref: "#/definitions/multipleOf",
                },
              },
            },
            nonBodyParameter: {
              type: "object",
              required: ["name", "in", "type"],
              oneOf: [
                {
                  $ref: "#/definitions/headerParameterSubSchema",
                },
                {
                  $ref: "#/definitions/formDataParameterSubSchema",
                },
                {
                  $ref: "#/definitions/queryParameterSubSchema",
                },
                {
                  $ref: "#/definitions/pathParameterSubSchema",
                },
              ],
            },
            parameter: {
              oneOf: [
                {
                  $ref: "#/definitions/bodyParameter",
                },
                {
                  $ref: "#/definitions/nonBodyParameter",
                },
              ],
            },
            schema: {
              type: "object",
              description: "A deterministic version of a JSON Schema object.",
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              properties: {
                $ref: {
                  type: "string",
                },
                format: {
                  type: "string",
                },
                title: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/title",
                },
                description: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/description",
                },
                default: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/default",
                },
                multipleOf: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf",
                },
                maximum: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/maximum",
                },
                exclusiveMaximum: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum",
                },
                minimum: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/minimum",
                },
                exclusiveMinimum: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum",
                },
                maxLength: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger",
                },
                minLength: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0",
                },
                pattern: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/pattern",
                },
                maxItems: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger",
                },
                minItems: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0",
                },
                uniqueItems: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems",
                },
                maxProperties: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger",
                },
                minProperties: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0",
                },
                required: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray",
                },
                enum: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/enum",
                },
                additionalProperties: {
                  anyOf: [
                    {
                      $ref: "#/definitions/schema",
                    },
                    {
                      type: "boolean",
                    },
                  ],
                  default: {},
                },
                type: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/type",
                },
                items: {
                  anyOf: [
                    {
                      $ref: "#/definitions/schema",
                    },
                    {
                      type: "array",
                      minItems: 1,
                      items: {
                        $ref: "#/definitions/schema",
                      },
                    },
                  ],
                  default: {},
                },
                allOf: {
                  type: "array",
                  minItems: 1,
                  items: {
                    $ref: "#/definitions/schema",
                  },
                },
                properties: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/schema",
                  },
                  default: {},
                },
                discriminator: {
                  type: "string",
                },
                readOnly: {
                  type: "boolean",
                  default: false,
                },
                xml: {
                  $ref: "#/definitions/xml",
                },
                externalDocs: {
                  $ref: "#/definitions/externalDocs",
                },
                example: {},
              },
              additionalProperties: false,
            },
            fileSchema: {
              type: "object",
              description: "A deterministic version of a JSON Schema object.",
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
              required: ["type"],
              properties: {
                format: {
                  type: "string",
                },
                title: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/title",
                },
                description: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/description",
                },
                default: {
                  $ref: "http://json-schema.org/draft-04/schema#/properties/default",
                },
                required: {
                  $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray",
                },
                type: {
                  type: "string",
                  enum: ["file"],
                },
                readOnly: {
                  type: "boolean",
                  default: false,
                },
                externalDocs: {
                  $ref: "#/definitions/externalDocs",
                },
                example: {},
              },
              additionalProperties: false,
            },
            primitivesItems: {
              type: "object",
              additionalProperties: false,
              properties: {
                type: {
                  type: "string",
                  enum: ["string", "number", "integer", "boolean", "array"],
                },
                format: {
                  type: "string",
                },
                items: {
                  $ref: "#/definitions/primitivesItems",
                },
                collectionFormat: {
                  $ref: "#/definitions/collectionFormat",
                },
                default: {
                  $ref: "#/definitions/default",
                },
                maximum: {
                  $ref: "#/definitions/maximum",
                },
                exclusiveMaximum: {
                  $ref: "#/definitions/exclusiveMaximum",
                },
                minimum: {
                  $ref: "#/definitions/minimum",
                },
                exclusiveMinimum: {
                  $ref: "#/definitions/exclusiveMinimum",
                },
                maxLength: {
                  $ref: "#/definitions/maxLength",
                },
                minLength: {
                  $ref: "#/definitions/minLength",
                },
                pattern: {
                  $ref: "#/definitions/pattern",
                },
                maxItems: {
                  $ref: "#/definitions/maxItems",
                },
                minItems: {
                  $ref: "#/definitions/minItems",
                },
                uniqueItems: {
                  $ref: "#/definitions/uniqueItems",
                },
                enum: {
                  $ref: "#/definitions/enum",
                },
                multipleOf: {
                  $ref: "#/definitions/multipleOf",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            security: {
              type: "array",
              items: {
                $ref: "#/definitions/securityRequirement",
              },
              uniqueItems: true,
            },
            securityRequirement: {
              type: "object",
              additionalProperties: {
                type: "array",
                items: {
                  type: "string",
                },
                uniqueItems: true,
              },
            },
            xml: {
              type: "object",
              additionalProperties: false,
              properties: {
                name: {
                  type: "string",
                },
                namespace: {
                  type: "string",
                },
                prefix: {
                  type: "string",
                },
                attribute: {
                  type: "boolean",
                  default: false,
                },
                wrapped: {
                  type: "boolean",
                  default: false,
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            tag: {
              type: "object",
              additionalProperties: false,
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                externalDocs: {
                  $ref: "#/definitions/externalDocs",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            securityDefinitions: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  {
                    $ref: "#/definitions/basicAuthenticationSecurity",
                  },
                  {
                    $ref: "#/definitions/apiKeySecurity",
                  },
                  {
                    $ref: "#/definitions/oauth2ImplicitSecurity",
                  },
                  {
                    $ref: "#/definitions/oauth2PasswordSecurity",
                  },
                  {
                    $ref: "#/definitions/oauth2ApplicationSecurity",
                  },
                  {
                    $ref: "#/definitions/oauth2AccessCodeSecurity",
                  },
                ],
              },
            },
            basicAuthenticationSecurity: {
              type: "object",
              additionalProperties: false,
              required: ["type"],
              properties: {
                type: {
                  type: "string",
                  enum: ["basic"],
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            apiKeySecurity: {
              type: "object",
              additionalProperties: false,
              required: ["type", "name", "in"],
              properties: {
                type: {
                  type: "string",
                  enum: ["apiKey"],
                },
                name: {
                  type: "string",
                },
                in: {
                  type: "string",
                  enum: ["header", "query"],
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            oauth2ImplicitSecurity: {
              type: "object",
              additionalProperties: false,
              required: ["type", "flow", "authorizationUrl"],
              properties: {
                type: {
                  type: "string",
                  enum: ["oauth2"],
                },
                flow: {
                  type: "string",
                  enum: ["implicit"],
                },
                scopes: {
                  $ref: "#/definitions/oauth2Scopes",
                },
                authorizationUrl: {
                  type: "string",
                  format: "uri",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            oauth2PasswordSecurity: {
              type: "object",
              additionalProperties: false,
              required: ["type", "flow", "tokenUrl"],
              properties: {
                type: {
                  type: "string",
                  enum: ["oauth2"],
                },
                flow: {
                  type: "string",
                  enum: ["password"],
                },
                scopes: {
                  $ref: "#/definitions/oauth2Scopes",
                },
                tokenUrl: {
                  type: "string",
                  format: "uri",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            oauth2ApplicationSecurity: {
              type: "object",
              additionalProperties: false,
              required: ["type", "flow", "tokenUrl"],
              properties: {
                type: {
                  type: "string",
                  enum: ["oauth2"],
                },
                flow: {
                  type: "string",
                  enum: ["application"],
                },
                scopes: {
                  $ref: "#/definitions/oauth2Scopes",
                },
                tokenUrl: {
                  type: "string",
                  format: "uri",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            oauth2AccessCodeSecurity: {
              type: "object",
              additionalProperties: false,
              required: ["type", "flow", "authorizationUrl", "tokenUrl"],
              properties: {
                type: {
                  type: "string",
                  enum: ["oauth2"],
                },
                flow: {
                  type: "string",
                  enum: ["accessCode"],
                },
                scopes: {
                  $ref: "#/definitions/oauth2Scopes",
                },
                authorizationUrl: {
                  type: "string",
                  format: "uri",
                },
                tokenUrl: {
                  type: "string",
                  format: "uri",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {
                  $ref: "#/definitions/vendorExtension",
                },
              },
            },
            oauth2Scopes: {
              type: "object",
              additionalProperties: {
                type: "string",
              },
            },
            mediaTypeList: {
              type: "array",
              items: {
                $ref: "#/definitions/mimeType",
              },
              uniqueItems: true,
            },
            parametersList: {
              type: "array",
              description: "The parameters needed to send a valid API call.",
              additionalItems: false,
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/parameter",
                  },
                  {
                    $ref: "#/definitions/jsonReference",
                  },
                ],
              },
              uniqueItems: true,
            },
            schemesList: {
              type: "array",
              description: "The transfer protocol of the API.",
              items: {
                type: "string",
                enum: ["http", "https", "ws", "wss"],
              },
              uniqueItems: true,
            },
            collectionFormat: {
              type: "string",
              enum: ["csv", "ssv", "tsv", "pipes"],
              default: "csv",
            },
            collectionFormatWithMulti: {
              type: "string",
              enum: ["csv", "ssv", "tsv", "pipes", "multi"],
              default: "csv",
            },
            title: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/title",
            },
            description: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/description",
            },
            default: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/default",
            },
            multipleOf: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf",
            },
            maximum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/maximum",
            },
            exclusiveMaximum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum",
            },
            minimum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/minimum",
            },
            exclusiveMinimum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum",
            },
            maxLength: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger",
            },
            minLength: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0",
            },
            pattern: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/pattern",
            },
            maxItems: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger",
            },
            minItems: {
              $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0",
            },
            uniqueItems: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems",
            },
            enum: {
              $ref: "http://json-schema.org/draft-04/schema#/properties/enum",
            },
            jsonReference: {
              type: "object",
              required: ["$ref"],
              additionalProperties: false,
              properties: {
                $ref: {
                  type: "string",
                },
              },
            },
          },
        };
      },
      {},
    ],
    28: [
      function (require, module, exports) {
        module.exports = {
          id: "https://spec.openapis.org/oas/3.0/schema/2019-04-02",
          $schema: "http://json-schema.org/draft-04/schema#",
          description: "Validation schema for OpenAPI Specification 3.0.X.",
          type: "object",
          required: ["openapi", "info", "paths"],
          properties: {
            openapi: {
              type: "string",
              pattern: "^3\\.0\\.\\d(-.+)?$",
            },
            info: {
              $ref: "#/definitions/Info",
            },
            externalDocs: {
              $ref: "#/definitions/ExternalDocumentation",
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/definitions/Server",
              },
            },
            security: {
              type: "array",
              items: {
                $ref: "#/definitions/SecurityRequirement",
              },
            },
            tags: {
              type: "array",
              items: {
                $ref: "#/definitions/Tag",
              },
              uniqueItems: true,
            },
            paths: {
              $ref: "#/definitions/Paths",
            },
            components: {
              $ref: "#/definitions/Components",
            },
          },
          patternProperties: {
            "^x-": {},
          },
          additionalProperties: false,
          definitions: {
            Reference: {
              type: "object",
              required: ["$ref"],
              patternProperties: {
                "^\\$ref$": {
                  type: "string",
                  format: "uri-reference",
                },
              },
            },
            Info: {
              type: "object",
              required: ["title", "version"],
              properties: {
                title: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                termsOfService: {
                  type: "string",
                  format: "uri-reference",
                },
                contact: {
                  $ref: "#/definitions/Contact",
                },
                license: {
                  $ref: "#/definitions/License",
                },
                version: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Contact: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                },
                url: {
                  type: "string",
                  format: "uri-reference",
                },
                email: {
                  type: "string",
                  format: "email",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            License: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                },
                url: {
                  type: "string",
                  format: "uri-reference",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Server: {
              type: "object",
              required: ["url"],
              properties: {
                url: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                variables: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/ServerVariable",
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            ServerVariable: {
              type: "object",
              required: ["default"],
              properties: {
                enum: {
                  type: "array",
                  items: {
                    type: "string",
                  },
                },
                default: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Components: {
              type: "object",
              properties: {
                schemas: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Schema",
                        },
                        {
                          $ref: "#/definitions/Reference",
                        },
                      ],
                    },
                  },
                },
                responses: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/Response",
                        },
                      ],
                    },
                  },
                },
                parameters: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/Parameter",
                        },
                      ],
                    },
                  },
                },
                examples: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/Example",
                        },
                      ],
                    },
                  },
                },
                requestBodies: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/RequestBody",
                        },
                      ],
                    },
                  },
                },
                headers: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/Header",
                        },
                      ],
                    },
                  },
                },
                securitySchemes: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/SecurityScheme",
                        },
                      ],
                    },
                  },
                },
                links: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/Link",
                        },
                      ],
                    },
                  },
                },
                callbacks: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [
                        {
                          $ref: "#/definitions/Reference",
                        },
                        {
                          $ref: "#/definitions/Callback",
                        },
                      ],
                    },
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Schema: {
              type: "object",
              properties: {
                title: {
                  type: "string",
                },
                multipleOf: {
                  type: "number",
                  minimum: 0,
                  exclusiveMinimum: true,
                },
                maximum: {
                  type: "number",
                },
                exclusiveMaximum: {
                  type: "boolean",
                  default: false,
                },
                minimum: {
                  type: "number",
                },
                exclusiveMinimum: {
                  type: "boolean",
                  default: false,
                },
                maxLength: {
                  type: "integer",
                  minimum: 0,
                },
                minLength: {
                  type: "integer",
                  minimum: 0,
                  default: 0,
                },
                pattern: {
                  type: "string",
                  format: "regex",
                },
                maxItems: {
                  type: "integer",
                  minimum: 0,
                },
                minItems: {
                  type: "integer",
                  minimum: 0,
                  default: 0,
                },
                uniqueItems: {
                  type: "boolean",
                  default: false,
                },
                maxProperties: {
                  type: "integer",
                  minimum: 0,
                },
                minProperties: {
                  type: "integer",
                  minimum: 0,
                  default: 0,
                },
                required: {
                  type: "array",
                  items: {
                    type: "string",
                  },
                  minItems: 1,
                  uniqueItems: true,
                },
                enum: {
                  type: "array",
                  items: {},
                  minItems: 1,
                  uniqueItems: false,
                },
                type: {
                  type: "string",
                  enum: ["array", "boolean", "integer", "number", "object", "string"],
                },
                not: {
                  oneOf: [
                    {
                      $ref: "#/definitions/Schema",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
                allOf: {
                  type: "array",
                  items: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Schema",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
                oneOf: {
                  type: "array",
                  items: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Schema",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
                anyOf: {
                  type: "array",
                  items: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Schema",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
                items: {
                  oneOf: [
                    {
                      $ref: "#/definitions/Schema",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
                properties: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Schema",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
                additionalProperties: {
                  oneOf: [
                    {
                      $ref: "#/definitions/Schema",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                    {
                      type: "boolean",
                    },
                  ],
                  default: true,
                },
                description: {
                  type: "string",
                },
                format: {
                  type: "string",
                },
                default: {},
                nullable: {
                  type: "boolean",
                  default: false,
                },
                discriminator: {
                  $ref: "#/definitions/Discriminator",
                },
                readOnly: {
                  type: "boolean",
                  default: false,
                },
                writeOnly: {
                  type: "boolean",
                  default: false,
                },
                example: {},
                externalDocs: {
                  $ref: "#/definitions/ExternalDocumentation",
                },
                deprecated: {
                  type: "boolean",
                  default: false,
                },
                xml: {
                  $ref: "#/definitions/XML",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Discriminator: {
              type: "object",
              required: ["propertyName"],
              properties: {
                propertyName: {
                  type: "string",
                },
                mapping: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                  },
                },
              },
            },
            XML: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                },
                namespace: {
                  type: "string",
                  format: "uri",
                },
                prefix: {
                  type: "string",
                },
                attribute: {
                  type: "boolean",
                  default: false,
                },
                wrapped: {
                  type: "boolean",
                  default: false,
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Response: {
              type: "object",
              required: ["description"],
              properties: {
                description: {
                  type: "string",
                },
                headers: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Header",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
                content: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/MediaType",
                  },
                },
                links: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Link",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            MediaType: {
              type: "object",
              properties: {
                schema: {
                  oneOf: [
                    {
                      $ref: "#/definitions/Schema",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
                example: {},
                examples: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Example",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
                encoding: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/Encoding",
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
              allOf: [
                {
                  $ref: "#/definitions/ExampleXORExamples",
                },
              ],
            },
            Example: {
              type: "object",
              properties: {
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                value: {},
                externalValue: {
                  type: "string",
                  format: "uri-reference",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Header: {
              type: "object",
              properties: {
                description: {
                  type: "string",
                },
                required: {
                  type: "boolean",
                  default: false,
                },
                deprecated: {
                  type: "boolean",
                  default: false,
                },
                allowEmptyValue: {
                  type: "boolean",
                  default: false,
                },
                style: {
                  type: "string",
                  enum: ["simple"],
                  default: "simple",
                },
                explode: {
                  type: "boolean",
                },
                allowReserved: {
                  type: "boolean",
                  default: false,
                },
                schema: {
                  oneOf: [
                    {
                      $ref: "#/definitions/Schema",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
                content: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/MediaType",
                  },
                  minProperties: 1,
                  maxProperties: 1,
                },
                example: {},
                examples: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Example",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
              allOf: [
                {
                  $ref: "#/definitions/ExampleXORExamples",
                },
                {
                  $ref: "#/definitions/SchemaXORContent",
                },
              ],
            },
            Paths: {
              type: "object",
              patternProperties: {
                "^\\/": {
                  $ref: "#/definitions/PathItem",
                },
                "^x-": {},
              },
              additionalProperties: false,
            },
            PathItem: {
              type: "object",
              properties: {
                $ref: {
                  type: "string",
                },
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                servers: {
                  type: "array",
                  items: {
                    $ref: "#/definitions/Server",
                  },
                },
                parameters: {
                  type: "array",
                  items: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Parameter",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                  uniqueItems: true,
                },
              },
              patternProperties: {
                "^(get|put|post|delete|options|head|patch|trace)$": {
                  $ref: "#/definitions/Operation",
                },
                "^x-": {},
              },
              additionalProperties: false,
            },
            Operation: {
              type: "object",
              required: ["responses"],
              properties: {
                tags: {
                  type: "array",
                  items: {
                    type: "string",
                  },
                },
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                externalDocs: {
                  $ref: "#/definitions/ExternalDocumentation",
                },
                operationId: {
                  type: "string",
                },
                parameters: {
                  type: "array",
                  items: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Parameter",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                  uniqueItems: true,
                },
                requestBody: {
                  oneOf: [
                    {
                      $ref: "#/definitions/RequestBody",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
                responses: {
                  $ref: "#/definitions/Responses",
                },
                callbacks: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Callback",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
                deprecated: {
                  type: "boolean",
                  default: false,
                },
                security: {
                  type: "array",
                  items: {
                    $ref: "#/definitions/SecurityRequirement",
                  },
                },
                servers: {
                  type: "array",
                  items: {
                    $ref: "#/definitions/Server",
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Responses: {
              type: "object",
              properties: {
                default: {
                  oneOf: [
                    {
                      $ref: "#/definitions/Response",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
              },
              patternProperties: {
                "^[1-5](?:\\d{2}|XX)$": {
                  oneOf: [
                    {
                      $ref: "#/definitions/Response",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
                "^x-": {},
              },
              minProperties: 1,
              additionalProperties: false,
            },
            SecurityRequirement: {
              type: "object",
              additionalProperties: {
                type: "array",
                items: {
                  type: "string",
                },
              },
            },
            Tag: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                externalDocs: {
                  $ref: "#/definitions/ExternalDocumentation",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            ExternalDocumentation: {
              type: "object",
              required: ["url"],
              properties: {
                description: {
                  type: "string",
                },
                url: {
                  type: "string",
                  format: "uri-reference",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            ExampleXORExamples: {
              description: "Example and examples are mutually exclusive",
              not: {
                required: ["example", "examples"],
              },
            },
            SchemaXORContent: {
              description: "Schema and content are mutually exclusive, at least one is required",
              not: {
                required: ["schema", "content"],
              },
              oneOf: [
                {
                  required: ["schema"],
                },
                {
                  required: ["content"],
                  description: "Some properties are not allowed if content is present",
                  allOf: [
                    {
                      not: {
                        required: ["style"],
                      },
                    },
                    {
                      not: {
                        required: ["explode"],
                      },
                    },
                    {
                      not: {
                        required: ["allowReserved"],
                      },
                    },
                    {
                      not: {
                        required: ["example"],
                      },
                    },
                    {
                      not: {
                        required: ["examples"],
                      },
                    },
                  ],
                },
              ],
            },
            Parameter: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                },
                in: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                required: {
                  type: "boolean",
                  default: false,
                },
                deprecated: {
                  type: "boolean",
                  default: false,
                },
                allowEmptyValue: {
                  type: "boolean",
                  default: false,
                },
                style: {
                  type: "string",
                },
                explode: {
                  type: "boolean",
                },
                allowReserved: {
                  type: "boolean",
                  default: false,
                },
                schema: {
                  oneOf: [
                    {
                      $ref: "#/definitions/Schema",
                    },
                    {
                      $ref: "#/definitions/Reference",
                    },
                  ],
                },
                content: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/MediaType",
                  },
                  minProperties: 1,
                  maxProperties: 1,
                },
                example: {},
                examples: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [
                      {
                        $ref: "#/definitions/Example",
                      },
                      {
                        $ref: "#/definitions/Reference",
                      },
                    ],
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
              required: ["name", "in"],
              allOf: [
                {
                  $ref: "#/definitions/ExampleXORExamples",
                },
                {
                  $ref: "#/definitions/SchemaXORContent",
                },
                {
                  $ref: "#/definitions/ParameterLocation",
                },
              ],
            },
            ParameterLocation: {
              description: "Parameter location",
              oneOf: [
                {
                  description: "Parameter in path",
                  required: ["required"],
                  properties: {
                    in: {
                      enum: ["path"],
                    },
                    style: {
                      enum: ["matrix", "label", "simple"],
                      default: "simple",
                    },
                    required: {
                      enum: [true],
                    },
                  },
                },
                {
                  description: "Parameter in query",
                  properties: {
                    in: {
                      enum: ["query"],
                    },
                    style: {
                      enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
                      default: "form",
                    },
                  },
                },
                {
                  description: "Parameter in header",
                  properties: {
                    in: {
                      enum: ["header"],
                    },
                    style: {
                      enum: ["simple"],
                      default: "simple",
                    },
                  },
                },
                {
                  description: "Parameter in cookie",
                  properties: {
                    in: {
                      enum: ["cookie"],
                    },
                    style: {
                      enum: ["form"],
                      default: "form",
                    },
                  },
                },
              ],
            },
            RequestBody: {
              type: "object",
              required: ["content"],
              properties: {
                description: {
                  type: "string",
                },
                content: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/MediaType",
                  },
                },
                required: {
                  type: "boolean",
                  default: false,
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            SecurityScheme: {
              oneOf: [
                {
                  $ref: "#/definitions/APIKeySecurityScheme",
                },
                {
                  $ref: "#/definitions/HTTPSecurityScheme",
                },
                {
                  $ref: "#/definitions/OAuth2SecurityScheme",
                },
                {
                  $ref: "#/definitions/OpenIdConnectSecurityScheme",
                },
              ],
            },
            APIKeySecurityScheme: {
              type: "object",
              required: ["type", "name", "in"],
              properties: {
                type: {
                  type: "string",
                  enum: ["apiKey"],
                },
                name: {
                  type: "string",
                },
                in: {
                  type: "string",
                  enum: ["header", "query", "cookie"],
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            HTTPSecurityScheme: {
              type: "object",
              required: ["scheme", "type"],
              properties: {
                scheme: {
                  type: "string",
                },
                bearerFormat: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                type: {
                  type: "string",
                  enum: ["http"],
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
              oneOf: [
                {
                  description: "Bearer",
                  properties: {
                    scheme: {
                      enum: ["bearer"],
                    },
                  },
                },
                {
                  description: "Non Bearer",
                  not: {
                    required: ["bearerFormat"],
                  },
                  properties: {
                    scheme: {
                      not: {
                        enum: ["bearer"],
                      },
                    },
                  },
                },
              ],
            },
            OAuth2SecurityScheme: {
              type: "object",
              required: ["type", "flows"],
              properties: {
                type: {
                  type: "string",
                  enum: ["oauth2"],
                },
                flows: {
                  $ref: "#/definitions/OAuthFlows",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            OpenIdConnectSecurityScheme: {
              type: "object",
              required: ["type", "openIdConnectUrl"],
              properties: {
                type: {
                  type: "string",
                  enum: ["openIdConnect"],
                },
                openIdConnectUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                description: {
                  type: "string",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            OAuthFlows: {
              type: "object",
              properties: {
                implicit: {
                  $ref: "#/definitions/ImplicitOAuthFlow",
                },
                password: {
                  $ref: "#/definitions/PasswordOAuthFlow",
                },
                clientCredentials: {
                  $ref: "#/definitions/ClientCredentialsFlow",
                },
                authorizationCode: {
                  $ref: "#/definitions/AuthorizationCodeOAuthFlow",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            ImplicitOAuthFlow: {
              type: "object",
              required: ["authorizationUrl", "scopes"],
              properties: {
                authorizationUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                refreshUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                scopes: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            PasswordOAuthFlow: {
              type: "object",
              required: ["tokenUrl"],
              properties: {
                tokenUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                refreshUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                scopes: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            ClientCredentialsFlow: {
              type: "object",
              required: ["tokenUrl"],
              properties: {
                tokenUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                refreshUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                scopes: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            AuthorizationCodeOAuthFlow: {
              type: "object",
              required: ["authorizationUrl", "tokenUrl"],
              properties: {
                authorizationUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                tokenUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                refreshUrl: {
                  type: "string",
                  format: "uri-reference",
                },
                scopes: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                  },
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
            },
            Link: {
              type: "object",
              properties: {
                operationId: {
                  type: "string",
                },
                operationRef: {
                  type: "string",
                  format: "uri-reference",
                },
                parameters: {
                  type: "object",
                  additionalProperties: {},
                },
                requestBody: {},
                description: {
                  type: "string",
                },
                server: {
                  $ref: "#/definitions/Server",
                },
              },
              patternProperties: {
                "^x-": {},
              },
              additionalProperties: false,
              not: {
                description: "Operation Id and Operation Ref are mutually exclusive",
                required: ["operationId", "operationRef"],
              },
            },
            Callback: {
              type: "object",
              additionalProperties: {
                $ref: "#/definitions/PathItem",
              },
              patternProperties: {
                "^x-": {},
              },
            },
            Encoding: {
              type: "object",
              properties: {
                contentType: {
                  type: "string",
                },
                headers: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/definitions/Header",
                  },
                },
                style: {
                  type: "string",
                  enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
                },
                explode: {
                  type: "boolean",
                },
                allowReserved: {
                  type: "boolean",
                  default: false,
                },
              },
              additionalProperties: false,
            },
          },
        };
      },
      {},
    ],
    29: [
      function (require, module, exports) {
        module.exports = {
          $id: "https://spec.openapis.org/oas/3.1/schema/2021-04-15",
          $schema: "https://json-schema.org/draft/2020-12/schema",
          type: "object",
          properties: {
            openapi: {
              type: "string",
              pattern: "^3\\.1\\.\\d+(-.+)?$",
            },
            info: {
              $ref: "#/$defs/info",
            },
            jsonSchemaDialect: {
              $ref: "#/$defs/uri",
              default: "https://spec.openapis.org/oas/3.1/dialect/base",
            },
            servers: {
              type: "array",
              items: {
                $ref: "#/$defs/server",
              },
            },
            paths: {
              $ref: "#/$defs/paths",
            },
            webhooks: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/path-item-or-reference",
              },
            },
            components: {
              $ref: "#/$defs/components",
            },
            security: {
              type: "array",
              items: {
                $ref: "#/$defs/security-requirement",
              },
            },
            tags: {
              type: "array",
              items: {
                $ref: "#/$defs/tag",
              },
            },
            externalDocs: {
              $ref: "#/$defs/external-documentation",
            },
          },
          required: ["openapi", "info"],
          anyOf: [
            {
              required: ["paths"],
            },
            {
              required: ["components"],
            },
            {
              required: ["webhooks"],
            },
          ],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: false,
          $defs: {
            info: {
              type: "object",
              properties: {
                title: {
                  type: "string",
                },
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                termsOfService: {
                  type: "string",
                },
                contact: {
                  $ref: "#/$defs/contact",
                },
                license: {
                  $ref: "#/$defs/license",
                },
                version: {
                  type: "string",
                },
              },
              required: ["title", "version"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            contact: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                },
                url: {
                  type: "string",
                },
                email: {
                  type: "string",
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            license: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                },
                identifier: {
                  type: "string",
                },
                url: {
                  $ref: "#/$defs/uri",
                },
              },
              required: ["name"],
              oneOf: [
                {
                  required: ["identifier"],
                },
                {
                  required: ["url"],
                },
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            server: {
              type: "object",
              properties: {
                url: {
                  $ref: "#/$defs/uri",
                },
                description: {
                  type: "string",
                },
                variables: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/server-variable",
                  },
                },
              },
              required: ["url"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "server-variable": {
              type: "object",
              properties: {
                enum: {
                  type: "array",
                  items: {
                    type: "string",
                  },
                  minItems: 1,
                },
                default: {
                  type: "string",
                },
                descriptions: {
                  type: "string",
                },
              },
              required: ["default"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            components: {
              type: "object",
              properties: {
                schemas: {
                  type: "object",
                  additionalProperties: {
                    $dynamicRef: "#meta",
                  },
                },
                responses: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/response-or-reference",
                  },
                },
                parameters: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/parameter-or-reference",
                  },
                },
                examples: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/example-or-reference",
                  },
                },
                requestBodies: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/request-body-or-reference",
                  },
                },
                headers: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/header-or-reference",
                  },
                },
                securitySchemes: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/security-scheme-or-reference",
                  },
                },
                links: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/link-or-reference",
                  },
                },
                callbacks: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/callbacks-or-reference",
                  },
                },
                pathItems: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/path-item-or-reference",
                  },
                },
              },
              patternProperties: {
                "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$":
                  {
                    $comment:
                      "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
                    propertyNames: {
                      pattern: "^[a-zA-Z0-9._-]+$",
                    },
                  },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            paths: {
              type: "object",
              patternProperties: {
                "^/": {
                  $ref: "#/$defs/path-item",
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "path-item": {
              type: "object",
              properties: {
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                servers: {
                  type: "array",
                  items: {
                    $ref: "#/$defs/server",
                  },
                },
                parameters: {
                  type: "array",
                  items: {
                    $ref: "#/$defs/parameter-or-reference",
                  },
                },
              },
              patternProperties: {
                "^(get|put|post|delete|options|head|patch|trace)$": {
                  $ref: "#/$defs/operation",
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "path-item-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/path-item",
              },
            },
            operation: {
              type: "object",
              properties: {
                tags: {
                  type: "array",
                  items: {
                    type: "string",
                  },
                },
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                externalDocs: {
                  $ref: "#/$defs/external-documentation",
                },
                operationId: {
                  type: "string",
                },
                parameters: {
                  type: "array",
                  items: {
                    $ref: "#/$defs/parameter-or-reference",
                  },
                },
                requestBody: {
                  $ref: "#/$defs/request-body-or-reference",
                },
                responses: {
                  $ref: "#/$defs/responses",
                },
                callbacks: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/callbacks-or-reference",
                  },
                },
                deprecated: {
                  default: false,
                  type: "boolean",
                },
                security: {
                  type: "array",
                  items: {
                    $ref: "#/$defs/security-requirement",
                  },
                },
                servers: {
                  type: "array",
                  items: {
                    $ref: "#/$defs/server",
                  },
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "external-documentation": {
              type: "object",
              properties: {
                description: {
                  type: "string",
                },
                url: {
                  $ref: "#/$defs/uri",
                },
              },
              required: ["url"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            parameter: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                },
                in: {
                  enum: ["query", "header", "path", "cookie"],
                },
                description: {
                  type: "string",
                },
                required: {
                  default: false,
                  type: "boolean",
                },
                deprecated: {
                  default: false,
                  type: "boolean",
                },
                allowEmptyValue: {
                  default: false,
                  type: "boolean",
                },
                schema: {
                  $dynamicRef: "#meta",
                },
                content: {
                  $ref: "#/$defs/content",
                },
              },
              required: ["in"],
              oneOf: [
                {
                  required: ["schema"],
                },
                {
                  required: ["content"],
                },
              ],
              dependentSchemas: {
                schema: {
                  properties: {
                    style: {
                      type: "string",
                    },
                    explode: {
                      type: "boolean",
                    },
                    allowReserved: {
                      default: false,
                      type: "boolean",
                    },
                  },
                  allOf: [
                    {
                      $ref: "#/$defs/examples",
                    },
                    {
                      $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path",
                    },
                    {
                      $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header",
                    },
                    {
                      $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query",
                    },
                    {
                      $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie",
                    },
                    {
                      $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form",
                    },
                  ],
                  $defs: {
                    "styles-for-path": {
                      if: {
                        properties: {
                          in: {
                            const: "path",
                          },
                        },
                        required: ["in"],
                      },
                      then: {
                        properties: {
                          style: {
                            default: "simple",
                            enum: ["matrix", "label", "simple"],
                          },
                          required: {
                            const: true,
                          },
                        },
                        required: ["required"],
                      },
                    },
                    "styles-for-header": {
                      if: {
                        properties: {
                          in: {
                            const: "header",
                          },
                        },
                        required: ["in"],
                      },
                      then: {
                        properties: {
                          style: {
                            default: "simple",
                            enum: ["simple"],
                          },
                        },
                      },
                    },
                    "styles-for-query": {
                      if: {
                        properties: {
                          in: {
                            const: "query",
                          },
                        },
                        required: ["in"],
                      },
                      then: {
                        properties: {
                          style: {
                            default: "form",
                            enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
                          },
                        },
                      },
                    },
                    "styles-for-cookie": {
                      if: {
                        properties: {
                          in: {
                            const: "cookie",
                          },
                        },
                        required: ["in"],
                      },
                      then: {
                        properties: {
                          style: {
                            default: "form",
                            enum: ["form"],
                          },
                        },
                      },
                    },
                    "styles-for-form": {
                      if: {
                        properties: {
                          style: {
                            const: "form",
                          },
                        },
                        required: ["style"],
                      },
                      then: {
                        properties: {
                          explode: {
                            default: true,
                          },
                        },
                      },
                      else: {
                        properties: {
                          explode: {
                            default: false,
                          },
                        },
                      },
                    },
                  },
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "parameter-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/parameter",
              },
            },
            "request-body": {
              type: "object",
              properties: {
                description: {
                  type: "string",
                },
                content: {
                  $ref: "#/$defs/content",
                },
                required: {
                  default: false,
                  type: "boolean",
                },
              },
              required: ["content"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "request-body-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/request-body",
              },
            },
            content: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/media-type",
              },
              propertyNames: {
                format: "media-range",
              },
            },
            "media-type": {
              type: "object",
              properties: {
                schema: {
                  $dynamicRef: "#meta",
                },
                encoding: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/encoding",
                  },
                },
              },
              allOf: [
                {
                  $ref: "#/$defs/specification-extensions",
                },
                {
                  $ref: "#/$defs/examples",
                },
              ],
              unevaluatedProperties: false,
            },
            encoding: {
              type: "object",
              properties: {
                contentType: {
                  type: "string",
                  format: "media-range",
                },
                headers: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/header-or-reference",
                  },
                },
                style: {
                  default: "form",
                  enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
                },
                explode: {
                  type: "boolean",
                },
                allowReserved: {
                  default: false,
                  type: "boolean",
                },
              },
              allOf: [
                {
                  $ref: "#/$defs/specification-extensions",
                },
                {
                  $ref: "#/$defs/encoding/$defs/explode-default",
                },
              ],
              unevaluatedProperties: false,
              $defs: {
                "explode-default": {
                  if: {
                    properties: {
                      style: {
                        const: "form",
                      },
                    },
                    required: ["style"],
                  },
                  then: {
                    properties: {
                      explode: {
                        default: true,
                      },
                    },
                  },
                  else: {
                    properties: {
                      explode: {
                        default: false,
                      },
                    },
                  },
                },
              },
            },
            responses: {
              type: "object",
              properties: {
                default: {
                  $ref: "#/$defs/response-or-reference",
                },
              },
              patternProperties: {
                "^[1-5][0-9X]{2}$": {
                  $ref: "#/$defs/response-or-reference",
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            response: {
              type: "object",
              properties: {
                description: {
                  type: "string",
                },
                headers: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/header-or-reference",
                  },
                },
                content: {
                  $ref: "#/$defs/content",
                },
                links: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/link-or-reference",
                  },
                },
              },
              required: ["description"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "response-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/response",
              },
            },
            callbacks: {
              type: "object",
              $ref: "#/$defs/specification-extensions",
              additionalProperties: {
                $ref: "#/$defs/path-item-or-reference",
              },
            },
            "callbacks-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/callbacks",
              },
            },
            example: {
              type: "object",
              properties: {
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                value: true,
                externalValue: {
                  $ref: "#/$defs/uri",
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "example-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/example",
              },
            },
            link: {
              type: "object",
              properties: {
                operationRef: {
                  $ref: "#/$defs/uri",
                },
                operationId: true,
                parameters: {
                  $ref: "#/$defs/map-of-strings",
                },
                requestBody: true,
                description: {
                  type: "string",
                },
                body: {
                  $ref: "#/$defs/server",
                },
              },
              oneOf: [
                {
                  required: ["operationRef"],
                },
                {
                  required: ["operationId"],
                },
              ],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "link-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/link",
              },
            },
            header: {
              type: "object",
              properties: {
                description: {
                  type: "string",
                },
                required: {
                  default: false,
                  type: "boolean",
                },
                deprecated: {
                  default: false,
                  type: "boolean",
                },
                allowEmptyValue: {
                  default: false,
                  type: "boolean",
                },
              },
              dependentSchemas: {
                schema: {
                  properties: {
                    style: {
                      default: "simple",
                      enum: ["simple"],
                    },
                    explode: {
                      default: false,
                      type: "boolean",
                    },
                    allowReserved: {
                      default: false,
                      type: "boolean",
                    },
                    schema: {
                      $dynamicRef: "#meta",
                    },
                  },
                  $ref: "#/$defs/examples",
                },
                content: {
                  properties: {
                    content: {
                      $ref: "#/$defs/content",
                    },
                  },
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            "header-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/header",
              },
            },
            tag: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
                externalDocs: {
                  $ref: "#/$defs/external-documentation",
                },
              },
              required: ["name"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
            },
            reference: {
              type: "object",
              properties: {
                $ref: {
                  $ref: "#/$defs/uri",
                },
                summary: {
                  type: "string",
                },
                description: {
                  type: "string",
                },
              },
              unevaluatedProperties: false,
            },
            schema: {
              $dynamicAnchor: "meta",
              type: ["object", "boolean"],
            },
            "security-scheme": {
              type: "object",
              properties: {
                type: {
                  enum: ["apiKey", "http", "mutualTLS", "oauth2", "openIdConnect"],
                },
                description: {
                  type: "string",
                },
              },
              required: ["type"],
              allOf: [
                {
                  $ref: "#/$defs/specification-extensions",
                },
                {
                  $ref: "#/$defs/security-scheme/$defs/type-apikey",
                },
                {
                  $ref: "#/$defs/security-scheme/$defs/type-http",
                },
                {
                  $ref: "#/$defs/security-scheme/$defs/type-http-bearer",
                },
                {
                  $ref: "#/$defs/security-scheme/$defs/type-oauth2",
                },
                {
                  $ref: "#/$defs/security-scheme/$defs/type-oidc",
                },
              ],
              unevaluatedProperties: false,
              $defs: {
                "type-apikey": {
                  if: {
                    properties: {
                      type: {
                        const: "apiKey",
                      },
                    },
                    required: ["type"],
                  },
                  then: {
                    properties: {
                      name: {
                        type: "string",
                      },
                      in: {
                        enum: ["query", "header", "cookie"],
                      },
                    },
                    required: ["name", "in"],
                  },
                },
                "type-http": {
                  if: {
                    properties: {
                      type: {
                        const: "http",
                      },
                    },
                    required: ["type"],
                  },
                  then: {
                    properties: {
                      scheme: {
                        type: "string",
                      },
                    },
                    required: ["scheme"],
                  },
                },
                "type-http-bearer": {
                  if: {
                    properties: {
                      type: {
                        const: "http",
                      },
                      scheme: {
                        const: "bearer",
                      },
                    },
                    required: ["type", "scheme"],
                  },
                  then: {
                    properties: {
                      bearerFormat: {
                        type: "string",
                      },
                    },
                    required: ["scheme"],
                  },
                },
                "type-oauth2": {
                  if: {
                    properties: {
                      type: {
                        const: "oauth2",
                      },
                    },
                    required: ["type"],
                  },
                  then: {
                    properties: {
                      flows: {
                        $ref: "#/$defs/oauth-flows",
                      },
                    },
                    required: ["flows"],
                  },
                },
                "type-oidc": {
                  if: {
                    properties: {
                      type: {
                        const: "openIdConnect",
                      },
                    },
                    required: ["type"],
                  },
                  then: {
                    properties: {
                      openIdConnectUrl: {
                        $ref: "#/$defs/uri",
                      },
                    },
                    required: ["openIdConnectUrl"],
                  },
                },
              },
            },
            "security-scheme-or-reference": {
              if: {
                required: ["$ref"],
              },
              then: {
                $ref: "#/$defs/reference",
              },
              else: {
                $ref: "#/$defs/security-scheme",
              },
            },
            "oauth-flows": {
              type: "object",
              properties: {
                implicit: {
                  $ref: "#/$defs/oauth-flows/$defs/implicit",
                },
                password: {
                  $ref: "#/$defs/oauth-flows/$defs/password",
                },
                clientCredentials: {
                  $ref: "#/$defs/oauth-flows/$defs/client-credentials",
                },
                authorizationCode: {
                  $ref: "#/$defs/oauth-flows/$defs/authorization-code",
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: false,
              $defs: {
                implicit: {
                  type: "object",
                  properties: {
                    authorizationUrl: {
                      type: "string",
                    },
                    refreshUrl: {
                      type: "string",
                    },
                    scopes: {
                      $ref: "#/$defs/map-of-strings",
                    },
                  },
                  required: ["authorizationUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: false,
                },
                password: {
                  type: "object",
                  properties: {
                    tokenUrl: {
                      type: "string",
                    },
                    refreshUrl: {
                      type: "string",
                    },
                    scopes: {
                      $ref: "#/$defs/map-of-strings",
                    },
                  },
                  required: ["tokenUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: false,
                },
                "client-credentials": {
                  type: "object",
                  properties: {
                    tokenUrl: {
                      type: "string",
                    },
                    refreshUrl: {
                      type: "string",
                    },
                    scopes: {
                      $ref: "#/$defs/map-of-strings",
                    },
                  },
                  required: ["tokenUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: false,
                },
                "authorization-code": {
                  type: "object",
                  properties: {
                    authorizationUrl: {
                      type: "string",
                    },
                    tokenUrl: {
                      type: "string",
                    },
                    refreshUrl: {
                      type: "string",
                    },
                    scopes: {
                      $ref: "#/$defs/map-of-strings",
                    },
                  },
                  required: ["authorizationUrl", "tokenUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: false,
                },
              },
            },
            "security-requirement": {
              type: "object",
              additionalProperties: {
                type: "array",
                items: {
                  type: "string",
                },
              },
            },
            "specification-extensions": {
              patternProperties: {
                "^x-": true,
              },
            },
            examples: {
              properties: {
                example: true,
                examples: {
                  type: "object",
                  additionalProperties: {
                    $ref: "#/$defs/example-or-reference",
                  },
                },
              },
            },
            uri: {
              type: "string",
              format: "uri",
            },
            "map-of-strings": {
              type: "object",
              additionalProperties: {
                type: "string",
              },
            },
          },
        };
      },
      {},
    ],
    30: [
      function (require, module, exports) {
        "use strict";

        module.exports = ["get", "put", "post", "delete", "options", "head", "patch"];
      },
      {},
    ],
    31: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Ono = void 0;
        const extend_error_1 = require("./extend-error");
        const normalize_1 = require("./normalize");
        const to_json_1 = require("./to-json");
        const constructor = Ono;
        exports.Ono = constructor;
        /**
         * Creates an `Ono` instance for a specifc error type.
         */
        // eslint-disable-next-line @typescript-eslint/naming-convention
        function Ono(ErrorConstructor, options) {
          options = normalize_1.normalizeOptions(options);
          function ono(...args) {
            let { originalError, props, message } = normalize_1.normalizeArgs(args, options);
            // Create a new error of the specified type
            let newError = new ErrorConstructor(message);
            // Extend the error with the properties of the original error and the `props` object
            return extend_error_1.extendError(newError, originalError, props);
          }
          ono[Symbol.species] = ErrorConstructor;
          return ono;
        }
        /**
         * Returns an object containing all properties of the given Error object,
         * which can be used with `JSON.stringify()`.
         */
        Ono.toJSON = function toJSON(error) {
          return to_json_1.toJSON.call(error);
        };
        /**
         * Extends the given Error object with enhanced Ono functionality, such as nested stack traces,
         * additional properties, and improved support for `JSON.stringify()`.
         */
        Ono.extend = function extend(error, originalError, props) {
          if (props || originalError instanceof Error) {
            return extend_error_1.extendError(error, originalError, props);
          } else if (originalError) {
            return extend_error_1.extendError(error, undefined, originalError);
          } else {
            return extend_error_1.extendError(error);
          }
        };
      },
      { "./extend-error": 32, "./normalize": 35, "./to-json": 38 },
    ],
    32: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.extendError = void 0;
        const isomorphic_node_1 = require("./isomorphic.node");
        const stack_1 = require("./stack");
        const to_json_1 = require("./to-json");
        const protectedProps = ["name", "message", "stack"];
        /**
         * Extends the new error with the properties of the original error and the `props` object.
         *
         * @param newError - The error object to extend
         * @param originalError - The original error object, if any
         * @param props - Additional properties to add, if any
         */
        function extendError(error, originalError, props) {
          let onoError = error;
          extendStack(onoError, originalError);
          // Copy properties from the original error
          if (originalError && typeof originalError === "object") {
            mergeErrors(onoError, originalError);
          }
          // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.
          // So replace it with one that outputs every property of the error.
          onoError.toJSON = to_json_1.toJSON;
          // On Node.js, add support for the `util.inspect()` method
          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
          if (isomorphic_node_1.addInspectMethod) {
            isomorphic_node_1.addInspectMethod(onoError);
          }
          // Finally, copy custom properties that were specified by the user.
          // These props OVERWRITE any previous props
          if (props && typeof props === "object") {
            Object.assign(onoError, props);
          }
          return onoError;
        }
        exports.extendError = extendError;
        /**
         * Extend the error stack to include its cause
         */
        function extendStack(newError, originalError) {
          let stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
          if (stack_1.isLazyStack(stackProp)) {
            stack_1.lazyJoinStacks(stackProp, newError, originalError);
          } else if (stack_1.isWritableStack(stackProp)) {
            newError.stack = stack_1.joinStacks(newError, originalError);
          }
        }
        /**
         * Merges properties of the original error with the new error.
         *
         * @param newError - The error object to extend
         * @param originalError - The original error object, if any
         */
        function mergeErrors(newError, originalError) {
          // Get the original error's keys
          // NOTE: We specifically exclude properties that we have already set on the new error.
          // This is _especially_ important for the `stack` property, because this property has
          // a lazy getter in some environments
          let keys = to_json_1.getDeepKeys(originalError, protectedProps);
          // HACK: We have to cast the errors to `any` so we can use symbol indexers.
          // see https://github.com/Microsoft/TypeScript/issues/1863
          let _newError = newError;
          let _originalError = originalError;
          for (let key of keys) {
            if (_newError[key] === undefined) {
              try {
                _newError[key] = _originalError[key];
              } catch (e) {
                // This property is read-only, so it can't be copied
              }
            }
          }
        }
      },
      { "./isomorphic.node": 34, "./stack": 37, "./to-json": 38 },
    ],
    33: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                });
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __exportStar =
          (this && this.__exportStar) ||
          function (m, exports) {
            for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ono = void 0;
        /* eslint-env commonjs */
        const singleton_1 = require("./singleton");
        Object.defineProperty(exports, "ono", {
          enumerable: true,
          get: function () {
            return singleton_1.ono;
          },
        });
        var constructor_1 = require("./constructor");
        Object.defineProperty(exports, "Ono", {
          enumerable: true,
          get: function () {
            return constructor_1.Ono;
          },
        });
        __exportStar(require("./types"), exports);
        exports.default = singleton_1.ono;
        // CommonJS default export hack
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = Object.assign(module.exports.default, module.exports);
        }
      },
      { "./constructor": 31, "./singleton": 36, "./types": 39 },
    ],
    34: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.addInspectMethod = exports.format = void 0;
        /**
         * Ono supports custom formatters for error messages.  In Node.js, it defaults
         * to the `util.format()` function.  In browsers, it defaults to `Array.join()`.
         *
         * The Node.js functionality can be used in a web browser via a polyfill,
         * such as "format-util".
         *
         * @see https://github.com/tmpfs/format-util
         */
        exports.format = false;
        /**
         * The `util.inspect()` functionality only applies to Node.js.
         * We return the constant `false` here so that the Node-specific code gets removed by tree-shaking.
         */
        exports.addInspectMethod = false;
      },
      {},
    ],
    35: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.normalizeArgs = exports.normalizeOptions = void 0;
        const isomorphic_node_1 = require("./isomorphic.node");
        /**
         * Normalizes Ono options, accounting for defaults and optional options.
         */
        function normalizeOptions(options) {
          options = options || {};
          return {
            concatMessages: options.concatMessages === undefined ? true : Boolean(options.concatMessages),
            format:
              options.format === undefined
                ? isomorphic_node_1.format
                : typeof options.format === "function"
                  ? options.format
                  : false,
          };
        }
        exports.normalizeOptions = normalizeOptions;
        /**
         * Normalizes the Ono arguments, accounting for defaults, options, and optional arguments.
         */
        function normalizeArgs(args, options) {
          let originalError;
          let props;
          let formatArgs;
          let message = "";
          // Determine which arguments were actually specified
          if (typeof args[0] === "string") {
            formatArgs = args;
          } else if (typeof args[1] === "string") {
            if (args[0] instanceof Error) {
              originalError = args[0];
            } else {
              props = args[0];
            }
            formatArgs = args.slice(1);
          } else {
            originalError = args[0];
            props = args[1];
            formatArgs = args.slice(2);
          }
          // If there are any format arguments, then format the error message
          if (formatArgs.length > 0) {
            if (options.format) {
              message = options.format.apply(undefined, formatArgs);
            } else {
              message = formatArgs.join(" ");
            }
          }
          if (options.concatMessages && originalError && originalError.message) {
            // The inner-error's message will be added to the new message
            message += (message ? " \n" : "") + originalError.message;
          }
          return { originalError, props, message };
        }
        exports.normalizeArgs = normalizeArgs;
      },
      { "./isomorphic.node": 34 },
    ],
    36: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ono = void 0;
        const constructor_1 = require("./constructor");
        const singleton = ono;
        exports.ono = singleton;
        ono.error = new constructor_1.Ono(Error);
        ono.eval = new constructor_1.Ono(EvalError);
        ono.range = new constructor_1.Ono(RangeError);
        ono.reference = new constructor_1.Ono(ReferenceError);
        ono.syntax = new constructor_1.Ono(SyntaxError);
        ono.type = new constructor_1.Ono(TypeError);
        ono.uri = new constructor_1.Ono(URIError);
        const onoMap = ono;
        /**
         * Creates a new error with the specified message, properties, and/or inner error.
         * If an inner error is provided, then the new error will match its type, if possible.
         */
        function ono(...args) {
          let originalError = args[0];
          // Is the first argument an Error-like object?
          if (typeof originalError === "object" && typeof originalError.name === "string") {
            // Try to find an Ono singleton method that matches this error type
            for (let typedOno of Object.values(onoMap)) {
              if (typeof typedOno === "function" && typedOno.name === "ono") {
                let species = typedOno[Symbol.species];
                if (
                  species &&
                  species !== Error &&
                  (originalError instanceof species || originalError.name === species.name)
                ) {
                  // Create an error of the same type
                  return typedOno.apply(undefined, args);
                }
              }
            }
          }
          // By default, create a base Error object
          return ono.error.apply(undefined, args);
        }
      },
      { "./constructor": 31 },
    ],
    37: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.lazyJoinStacks = exports.joinStacks = exports.isWritableStack = exports.isLazyStack = void 0;
        const newline = /\r?\n/;
        const onoCall = /\bono[ @]/;
        /**
         * Is the property lazily computed?
         */
        function isLazyStack(stackProp) {
          return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === "function");
        }
        exports.isLazyStack = isLazyStack;
        /**
         * Is the stack property writable?
         */
        function isWritableStack(stackProp) {
          return Boolean(
            // If there is no stack property, then it's writable, since assigning it will create it
            !stackProp || stackProp.writable || typeof stackProp.set === "function",
          );
        }
        exports.isWritableStack = isWritableStack;
        /**
         * Appends the original `Error.stack` property to the new Error's stack.
         */
        function joinStacks(newError, originalError) {
          let newStack = popStack(newError.stack);
          let originalStack = originalError ? originalError.stack : undefined;
          if (newStack && originalStack) {
            return newStack + "\n\n" + originalStack;
          } else {
            return newStack || originalStack;
          }
        }
        exports.joinStacks = joinStacks;
        /**
         * Calls `joinStacks` lazily, when the `Error.stack` property is accessed.
         */
        function lazyJoinStacks(lazyStack, newError, originalError) {
          if (originalError) {
            Object.defineProperty(newError, "stack", {
              get: () => {
                let newStack = lazyStack.get.apply(newError);
                return joinStacks({ stack: newStack }, originalError);
              },
              enumerable: false,
              configurable: true,
            });
          } else {
            lazyPopStack(newError, lazyStack);
          }
        }
        exports.lazyJoinStacks = lazyJoinStacks;
        /**
         * Removes Ono from the stack, so that the stack starts at the original error location
         */
        function popStack(stack) {
          if (stack) {
            let lines = stack.split(newline);
            // Find the Ono call(s) in the stack, and remove them
            let onoStart;
            for (let i = 0; i < lines.length; i++) {
              let line = lines[i];
              if (onoCall.test(line)) {
                if (onoStart === undefined) {
                  // We found the first Ono call in the stack trace.
                  // There may be other subsequent Ono calls as well.
                  onoStart = i;
                }
              } else if (onoStart !== undefined) {
                // We found the first non-Ono call after one or more Ono calls.
                // So remove the Ono call lines from the stack trace
                lines.splice(onoStart, i - onoStart);
                break;
              }
            }
            if (lines.length > 0) {
              return lines.join("\n");
            }
          }
          // If we get here, then the stack doesn't contain a call to `ono`.
          // This may be due to minification or some optimization of the JS engine.
          // So just return the stack as-is.
          return stack;
        }
        /**
         * Calls `popStack` lazily, when the `Error.stack` property is accessed.
         */
        function lazyPopStack(error, lazyStack) {
          Object.defineProperty(error, "stack", {
            get: () => popStack(lazyStack.get.apply(error)),
            enumerable: false,
            configurable: true,
          });
        }
      },
      {},
    ],
    38: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.getDeepKeys = exports.toJSON = void 0;
        const nonJsonTypes = ["function", "symbol", "undefined"];
        const protectedProps = ["constructor", "prototype", "__proto__"];
        const objectPrototype = Object.getPrototypeOf({});
        /**
         * Custom JSON serializer for Error objects.
         * Returns all built-in error properties, as well as extended properties.
         */
        function toJSON() {
          // HACK: We have to cast the objects to `any` so we can use symbol indexers.
          // see https://github.com/Microsoft/TypeScript/issues/1863
          let pojo = {};
          let error = this;
          for (let key of getDeepKeys(error)) {
            if (typeof key === "string") {
              let value = error[key];
              let type = typeof value;
              if (!nonJsonTypes.includes(type)) {
                pojo[key] = value;
              }
            }
          }
          return pojo;
        }
        exports.toJSON = toJSON;
        /**
         * Returns own, inherited, enumerable, non-enumerable, string, and symbol keys of `obj`.
         * Does NOT return members of the base Object prototype, or the specified omitted keys.
         */
        function getDeepKeys(obj, omit = []) {
          let keys = [];
          // Crawl the prototype chain, finding all the string and symbol keys
          while (obj && obj !== objectPrototype) {
            keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));
            obj = Object.getPrototypeOf(obj);
          }
          // De-duplicate the list of keys
          let uniqueKeys = new Set(keys);
          // Remove any omitted keys
          for (let key of omit.concat(protectedProps)) {
            uniqueKeys.delete(key);
          }
          return uniqueKeys;
        }
        exports.getDeepKeys = getDeepKeys;
      },
      {},
    ],
    39: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const util_1 = require("util");
      },
      { util: 204 },
    ],
    40: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.CodeGen =
          exports.Name =
          exports.nil =
          exports.stringify =
          exports.str =
          exports._ =
          exports.KeywordCxt =
            void 0;
        const core_1 = require("ajv/dist/core");
        const draft4_1 = require("./vocabulary/draft4");
        const discriminator_1 = require("ajv/dist/vocabularies/discriminator");
        const draft4MetaSchema = require("./refs/json-schema-draft-04.json");
        const META_SUPPORT_DATA = ["/properties"];
        const META_SCHEMA_ID = "http://json-schema.org/draft-04/schema";
        class Ajv extends core_1.default {
          constructor(opts = {}) {
            super({
              ...opts,
              schemaId: "id",
            });
          }
          _addVocabularies() {
            super._addVocabularies();
            draft4_1.default.forEach((v) => this.addVocabulary(v));
            if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
          }
          _addDefaultMetaSchema() {
            super._addDefaultMetaSchema();
            if (!this.opts.meta) return;
            const metaSchema = this.opts.$data
              ? this.$dataMetaSchema(draft4MetaSchema, META_SUPPORT_DATA)
              : draft4MetaSchema;
            this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
            this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
          }
          defaultMeta() {
            return (this.opts.defaultMeta =
              super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
          }
        }
        module.exports = exports = Ajv;
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.default = Ajv;
        var core_2 = require("ajv/dist/core");
        Object.defineProperty(exports, "KeywordCxt", {
          enumerable: true,
          get: function () {
            return core_2.KeywordCxt;
          },
        });
        var core_3 = require("ajv/dist/core");
        Object.defineProperty(exports, "_", {
          enumerable: true,
          get: function () {
            return core_3._;
          },
        });
        Object.defineProperty(exports, "str", {
          enumerable: true,
          get: function () {
            return core_3.str;
          },
        });
        Object.defineProperty(exports, "stringify", {
          enumerable: true,
          get: function () {
            return core_3.stringify;
          },
        });
        Object.defineProperty(exports, "nil", {
          enumerable: true,
          get: function () {
            return core_3.nil;
          },
        });
        Object.defineProperty(exports, "Name", {
          enumerable: true,
          get: function () {
            return core_3.Name;
          },
        });
        Object.defineProperty(exports, "CodeGen", {
          enumerable: true,
          get: function () {
            return core_3.CodeGen;
          },
        });
      },
      {
        "./refs/json-schema-draft-04.json": 41,
        "./vocabulary/draft4": 43,
        "ajv/dist/core": 65,
        "ajv/dist/vocabularies/discriminator": 102,
      },
    ],
    41: [
      function (require, module, exports) {
        module.exports = {
          id: "http://json-schema.org/draft-04/schema#",
          $schema: "http://json-schema.org/draft-04/schema#",
          description: "Core schema meta-schema",
          definitions: {
            schemaArray: {
              type: "array",
              minItems: 1,
              items: { $ref: "#" },
            },
            positiveInteger: {
              type: "integer",
              minimum: 0,
            },
            positiveIntegerDefault0: {
              allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }],
            },
            simpleTypes: {
              enum: ["array", "boolean", "integer", "null", "number", "object", "string"],
            },
            stringArray: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              uniqueItems: true,
            },
          },
          type: "object",
          properties: {
            id: {
              type: "string",
              format: "uri",
            },
            $schema: {
              type: "string",
              format: "uri",
            },
            title: {
              type: "string",
            },
            description: {
              type: "string",
            },
            default: {},
            multipleOf: {
              type: "number",
              minimum: 0,
              exclusiveMinimum: true,
            },
            maximum: {
              type: "number",
            },
            exclusiveMaximum: {
              type: "boolean",
              default: false,
            },
            minimum: {
              type: "number",
            },
            exclusiveMinimum: {
              type: "boolean",
              default: false,
            },
            maxLength: { $ref: "#/definitions/positiveInteger" },
            minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
            pattern: {
              type: "string",
              format: "regex",
            },
            additionalItems: {
              anyOf: [{ type: "boolean" }, { $ref: "#" }],
              default: {},
            },
            items: {
              anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
              default: {},
            },
            maxItems: { $ref: "#/definitions/positiveInteger" },
            minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
            uniqueItems: {
              type: "boolean",
              default: false,
            },
            maxProperties: { $ref: "#/definitions/positiveInteger" },
            minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
            required: { $ref: "#/definitions/stringArray" },
            additionalProperties: {
              anyOf: [{ type: "boolean" }, { $ref: "#" }],
              default: {},
            },
            definitions: {
              type: "object",
              additionalProperties: { $ref: "#" },
              default: {},
            },
            properties: {
              type: "object",
              additionalProperties: { $ref: "#" },
              default: {},
            },
            patternProperties: {
              type: "object",
              additionalProperties: { $ref: "#" },
              default: {},
            },
            dependencies: {
              type: "object",
              additionalProperties: {
                anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
              },
            },
            enum: {
              type: "array",
              minItems: 1,
              uniqueItems: true,
            },
            type: {
              anyOf: [
                { $ref: "#/definitions/simpleTypes" },
                {
                  type: "array",
                  items: { $ref: "#/definitions/simpleTypes" },
                  minItems: 1,
                  uniqueItems: true,
                },
              ],
            },
            allOf: { $ref: "#/definitions/schemaArray" },
            anyOf: { $ref: "#/definitions/schemaArray" },
            oneOf: { $ref: "#/definitions/schemaArray" },
            not: { $ref: "#" },
          },
          dependencies: {
            exclusiveMaximum: ["maximum"],
            exclusiveMinimum: ["minimum"],
          },
          default: {},
        };
      },
      {},
    ],
    42: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const ref_1 = require("ajv/dist/vocabularies/core/ref");
        const core = ["$schema", "id", "$defs", { keyword: "$comment" }, "definitions", ref_1.default];
        exports.default = core;
      },
      { "ajv/dist/vocabularies/core/ref": 101 },
    ],
    43: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const core_1 = require("./core");
        const validation_1 = require("./validation");
        const applicator_1 = require("ajv/dist/vocabularies/applicator");
        const format_1 = require("ajv/dist/vocabularies/format");
        const metadataVocabulary = ["title", "description", "default"];
        const draft4Vocabularies = [
          core_1.default,
          validation_1.default,
          applicator_1.default(),
          format_1.default,
          metadataVocabulary,
        ];
        exports.default = draft4Vocabularies;
      },
      { "./core": 42, "./validation": 44, "ajv/dist/vocabularies/applicator": 88, "ajv/dist/vocabularies/format": 111 },
    ],
    44: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const limitNumber_1 = require("./limitNumber");
        const limitNumberExclusive_1 = require("./limitNumberExclusive");
        const multipleOf_1 = require("ajv/dist/vocabularies/validation/multipleOf");
        const limitLength_1 = require("ajv/dist/vocabularies/validation/limitLength");
        const pattern_1 = require("ajv/dist/vocabularies/validation/pattern");
        const limitProperties_1 = require("ajv/dist/vocabularies/validation/limitProperties");
        const required_1 = require("ajv/dist/vocabularies/validation/required");
        const limitItems_1 = require("ajv/dist/vocabularies/validation/limitItems");
        const uniqueItems_1 = require("ajv/dist/vocabularies/validation/uniqueItems");
        const const_1 = require("ajv/dist/vocabularies/validation/const");
        const enum_1 = require("ajv/dist/vocabularies/validation/enum");
        const validation = [
          // number
          limitNumber_1.default,
          limitNumberExclusive_1.default,
          multipleOf_1.default,
          // string
          limitLength_1.default,
          pattern_1.default,
          // object
          limitProperties_1.default,
          required_1.default,
          // array
          limitItems_1.default,
          uniqueItems_1.default,
          // any
          { keyword: "type", schemaType: ["string", "array"] },
          { keyword: "nullable", schemaType: "boolean" },
          const_1.default,
          enum_1.default,
        ];
        exports.default = validation;
      },
      {
        "./limitNumber": 45,
        "./limitNumberExclusive": 46,
        "ajv/dist/vocabularies/validation/const": 117,
        "ajv/dist/vocabularies/validation/enum": 119,
        "ajv/dist/vocabularies/validation/limitItems": 122,
        "ajv/dist/vocabularies/validation/limitLength": 123,
        "ajv/dist/vocabularies/validation/limitProperties": 125,
        "ajv/dist/vocabularies/validation/multipleOf": 126,
        "ajv/dist/vocabularies/validation/pattern": 127,
        "ajv/dist/vocabularies/validation/required": 128,
        "ajv/dist/vocabularies/validation/uniqueItems": 129,
      },
    ],
    45: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const core_1 = require("ajv/dist/core");
        const codegen_1 = require("ajv/dist/compile/codegen");
        const ops = codegen_1.operators;
        const KWDs = {
          maximum: {
            exclusive: "exclusiveMaximum",
            ops: [
              { okStr: "<=", ok: ops.LTE, fail: ops.GT },
              { okStr: "<", ok: ops.LT, fail: ops.GTE },
            ],
          },
          minimum: {
            exclusive: "exclusiveMinimum",
            ops: [
              { okStr: ">=", ok: ops.GTE, fail: ops.LT },
              { okStr: ">", ok: ops.GT, fail: ops.LTE },
            ],
          },
        };
        const error = {
          message: (cxt) => core_1.str`must be ${kwdOp(cxt).okStr} ${cxt.schemaCode}`,
          params: (cxt) => core_1._`{comparison: ${kwdOp(cxt).okStr}, limit: ${cxt.schemaCode}}`,
        };
        const def = {
          keyword: Object.keys(KWDs),
          type: "number",
          schemaType: "number",
          $data: true,
          error,
          code(cxt) {
            const { data, schemaCode } = cxt;
            cxt.fail$data(core_1._`${data} ${kwdOp(cxt).fail} ${schemaCode} || isNaN(${data})`);
          },
        };
        function kwdOp(cxt) {
          var _a;
          const keyword = cxt.keyword;
          const opsIdx = ((_a = cxt.parentSchema) === null || _a === void 0 ? void 0 : _a[KWDs[keyword].exclusive])
            ? 1
            : 0;
          return KWDs[keyword].ops[opsIdx];
        }
        exports.default = def;
      },
      { "ajv/dist/compile/codegen": 49, "ajv/dist/core": 65 },
    ],
    46: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const KWDs = {
          exclusiveMaximum: "maximum",
          exclusiveMinimum: "minimum",
        };
        const def = {
          keyword: Object.keys(KWDs),
          type: "number",
          schemaType: "boolean",
          code({ keyword, parentSchema }) {
            const limitKwd = KWDs[keyword];
            if (parentSchema[limitKwd] === undefined) {
              throw new Error(`${keyword} can only be used with ${limitKwd}`);
            }
          },
        };
        exports.default = def;
      },
      {},
    ],
    47: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.CodeGen =
          exports.Name =
          exports.nil =
          exports.stringify =
          exports.str =
          exports._ =
          exports.KeywordCxt =
            void 0;
        const core_1 = require("./core");
        const draft2020_1 = require("./vocabularies/draft2020");
        const discriminator_1 = require("./vocabularies/discriminator");
        const json_schema_2020_12_1 = require("./refs/json-schema-2020-12");
        const META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
        class Ajv2020 extends core_1.default {
          constructor(opts = {}) {
            super({
              ...opts,
              dynamicRef: true,
              next: true,
              unevaluated: true,
            });
          }
          _addVocabularies() {
            super._addVocabularies();
            draft2020_1.default.forEach((v) => this.addVocabulary(v));
            if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
          }
          _addDefaultMetaSchema() {
            super._addDefaultMetaSchema();
            const { $data, meta } = this.opts;
            if (!meta) return;
            json_schema_2020_12_1.default.call(this, $data);
            this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
          }
          defaultMeta() {
            return (this.opts.defaultMeta =
              super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
          }
        }
        module.exports = exports = Ajv2020;
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.default = Ajv2020;
        var validate_1 = require("./compile/validate");
        Object.defineProperty(exports, "KeywordCxt", {
          enumerable: true,
          get: function () {
            return validate_1.KeywordCxt;
          },
        });
        var codegen_1 = require("./compile/codegen");
        Object.defineProperty(exports, "_", {
          enumerable: true,
          get: function () {
            return codegen_1._;
          },
        });
        Object.defineProperty(exports, "str", {
          enumerable: true,
          get: function () {
            return codegen_1.str;
          },
        });
        Object.defineProperty(exports, "stringify", {
          enumerable: true,
          get: function () {
            return codegen_1.stringify;
          },
        });
        Object.defineProperty(exports, "nil", {
          enumerable: true,
          get: function () {
            return codegen_1.nil;
          },
        });
        Object.defineProperty(exports, "Name", {
          enumerable: true,
          get: function () {
            return codegen_1.Name;
          },
        });
        Object.defineProperty(exports, "CodeGen", {
          enumerable: true,
          get: function () {
            return codegen_1.CodeGen;
          },
        });
      },
      {
        "./compile/codegen": 49,
        "./compile/validate": 62,
        "./core": 65,
        "./refs/json-schema-2020-12": 67,
        "./vocabularies/discriminator": 102,
        "./vocabularies/draft2020": 104,
      },
    ],
    48: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.regexpCode =
          exports.getEsmExportName =
          exports.getProperty =
          exports.safeStringify =
          exports.stringify =
          exports.strConcat =
          exports.addCodeArg =
          exports.str =
          exports._ =
          exports.nil =
          exports._Code =
          exports.Name =
          exports.IDENTIFIER =
          exports._CodeOrName =
            void 0;
        class _CodeOrName {}
        exports._CodeOrName = _CodeOrName;
        exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class Name extends _CodeOrName {
          constructor(s) {
            super();
            if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
            this.str = s;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            return false;
          }
          get names() {
            return { [this.str]: 1 };
          }
        }
        exports.Name = Name;
        class _Code extends _CodeOrName {
          constructor(code) {
            super();
            this._items = typeof code === "string" ? [code] : code;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            if (this._items.length > 1) return false;
            const item = this._items[0];
            return item === "" || item === '""';
          }
          get str() {
            var _a;
            return (_a = this._str) !== null && _a !== void 0
              ? _a
              : (this._str = this._items.reduce((s, c) => `${s}${c}`, ""));
          }
          get names() {
            var _a;
            return (_a = this._names) !== null && _a !== void 0
              ? _a
              : (this._names = this._items.reduce((names, c) => {
                  if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1;
                  return names;
                }, {}));
          }
        }
        exports._Code = _Code;
        exports.nil = new _Code("");
        function _(strs, ...args) {
          const code = [strs[0]];
          let i = 0;
          while (i < args.length) {
            addCodeArg(code, args[i]);
            code.push(strs[++i]);
          }
          return new _Code(code);
        }
        exports._ = _;
        const plus = new _Code("+");
        function str(strs, ...args) {
          const expr = [safeStringify(strs[0])];
          let i = 0;
          while (i < args.length) {
            expr.push(plus);
            addCodeArg(expr, args[i]);
            expr.push(plus, safeStringify(strs[++i]));
          }
          optimize(expr);
          return new _Code(expr);
        }
        exports.str = str;
        function addCodeArg(code, arg) {
          if (arg instanceof _Code) code.push(...arg._items);
          else if (arg instanceof Name) code.push(arg);
          else code.push(interpolate(arg));
        }
        exports.addCodeArg = addCodeArg;
        function optimize(expr) {
          let i = 1;
          while (i < expr.length - 1) {
            if (expr[i] === plus) {
              const res = mergeExprItems(expr[i - 1], expr[i + 1]);
              if (res !== undefined) {
                expr.splice(i - 1, 3, res);
                continue;
              }
              expr[i++] = "+";
            }
            i++;
          }
        }
        function mergeExprItems(a, b) {
          if (b === '""') return a;
          if (a === '""') return b;
          if (typeof a == "string") {
            if (b instanceof Name || a[a.length - 1] !== '"') return;
            if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
            if (b[0] === '"') return a.slice(0, -1) + b.slice(1);
            return;
          }
          if (typeof b == "string" && b[0] === '"' && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
          return;
        }
        function strConcat(c1, c2) {
          return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
        }
        exports.strConcat = strConcat;
        // TODO do not allow arrays here
        function interpolate(x) {
          return typeof x == "number" || typeof x == "boolean" || x === null
            ? x
            : safeStringify(Array.isArray(x) ? x.join(",") : x);
        }
        function stringify(x) {
          return new _Code(safeStringify(x));
        }
        exports.stringify = stringify;
        function safeStringify(x) {
          return JSON.stringify(x)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029");
        }
        exports.safeStringify = safeStringify;
        function getProperty(key) {
          return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
        }
        exports.getProperty = getProperty;
        //Does best effort to format the name properly
        function getEsmExportName(key) {
          if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
            return new _Code(`${key}`);
          }
          throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
        }
        exports.getEsmExportName = getEsmExportName;
        function regexpCode(rx) {
          return new _Code(rx.toString());
        }
        exports.regexpCode = regexpCode;
      },
      {},
    ],
    49: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.or =
          exports.and =
          exports.not =
          exports.CodeGen =
          exports.operators =
          exports.varKinds =
          exports.ValueScopeName =
          exports.ValueScope =
          exports.Scope =
          exports.Name =
          exports.regexpCode =
          exports.stringify =
          exports.getProperty =
          exports.nil =
          exports.strConcat =
          exports.str =
          exports._ =
            void 0;
        const code_1 = require("./code");
        const scope_1 = require("./scope");
        var code_2 = require("./code");
        Object.defineProperty(exports, "_", {
          enumerable: true,
          get: function () {
            return code_2._;
          },
        });
        Object.defineProperty(exports, "str", {
          enumerable: true,
          get: function () {
            return code_2.str;
          },
        });
        Object.defineProperty(exports, "strConcat", {
          enumerable: true,
          get: function () {
            return code_2.strConcat;
          },
        });
        Object.defineProperty(exports, "nil", {
          enumerable: true,
          get: function () {
            return code_2.nil;
          },
        });
        Object.defineProperty(exports, "getProperty", {
          enumerable: true,
          get: function () {
            return code_2.getProperty;
          },
        });
        Object.defineProperty(exports, "stringify", {
          enumerable: true,
          get: function () {
            return code_2.stringify;
          },
        });
        Object.defineProperty(exports, "regexpCode", {
          enumerable: true,
          get: function () {
            return code_2.regexpCode;
          },
        });
        Object.defineProperty(exports, "Name", {
          enumerable: true,
          get: function () {
            return code_2.Name;
          },
        });
        var scope_2 = require("./scope");
        Object.defineProperty(exports, "Scope", {
          enumerable: true,
          get: function () {
            return scope_2.Scope;
          },
        });
        Object.defineProperty(exports, "ValueScope", {
          enumerable: true,
          get: function () {
            return scope_2.ValueScope;
          },
        });
        Object.defineProperty(exports, "ValueScopeName", {
          enumerable: true,
          get: function () {
            return scope_2.ValueScopeName;
          },
        });
        Object.defineProperty(exports, "varKinds", {
          enumerable: true,
          get: function () {
            return scope_2.varKinds;
          },
        });
        exports.operators = {
          GT: new code_1._Code(">"),
          GTE: new code_1._Code(">="),
          LT: new code_1._Code("<"),
          LTE: new code_1._Code("<="),
          EQ: new code_1._Code("==="),
          NEQ: new code_1._Code("!=="),
          NOT: new code_1._Code("!"),
          OR: new code_1._Code("||"),
          AND: new code_1._Code("&&"),
          ADD: new code_1._Code("+"),
        };
        class Node {
          optimizeNodes() {
            return this;
          }
          optimizeNames(_names, _constants) {
            return this;
          }
        }
        class Def extends Node {
          constructor(varKind, name, rhs) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.rhs = rhs;
          }
          render({ es5, _n }) {
            const varKind = es5 ? scope_1.varKinds.var : this.varKind;
            const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
            return `${varKind} ${this.name}${rhs};` + _n;
          }
          optimizeNames(names, constants) {
            if (!names[this.name.str]) return;
            if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);
            return this;
          }
          get names() {
            return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
          }
        }
        class Assign extends Node {
          constructor(lhs, rhs, sideEffects) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.sideEffects = sideEffects;
          }
          render({ _n }) {
            return `${this.lhs} = ${this.rhs};` + _n;
          }
          optimizeNames(names, constants) {
            if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;
            this.rhs = optimizeExpr(this.rhs, names, constants);
            return this;
          }
          get names() {
            const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
            return addExprNames(names, this.rhs);
          }
        }
        class AssignOp extends Assign {
          constructor(lhs, op, rhs, sideEffects) {
            super(lhs, rhs, sideEffects);
            this.op = op;
          }
          render({ _n }) {
            return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
          }
        }
        class Label extends Node {
          constructor(label) {
            super();
            this.label = label;
            this.names = {};
          }
          render({ _n }) {
            return `${this.label}:` + _n;
          }
        }
        class Break extends Node {
          constructor(label) {
            super();
            this.label = label;
            this.names = {};
          }
          render({ _n }) {
            const label = this.label ? ` ${this.label}` : "";
            return `break${label};` + _n;
          }
        }
        class Throw extends Node {
          constructor(error) {
            super();
            this.error = error;
          }
          render({ _n }) {
            return `throw ${this.error};` + _n;
          }
          get names() {
            return this.error.names;
          }
        }
        class AnyCode extends Node {
          constructor(code) {
            super();
            this.code = code;
          }
          render({ _n }) {
            return `${this.code};` + _n;
          }
          optimizeNodes() {
            return `${this.code}` ? this : undefined;
          }
          optimizeNames(names, constants) {
            this.code = optimizeExpr(this.code, names, constants);
            return this;
          }
          get names() {
            return this.code instanceof code_1._CodeOrName ? this.code.names : {};
          }
        }
        class ParentNode extends Node {
          constructor(nodes = []) {
            super();
            this.nodes = nodes;
          }
          render(opts) {
            return this.nodes.reduce((code, n) => code + n.render(opts), "");
          }
          optimizeNodes() {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
              const n = nodes[i].optimizeNodes();
              if (Array.isArray(n)) nodes.splice(i, 1, ...n);
              else if (n) nodes[i] = n;
              else nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : undefined;
          }
          optimizeNames(names, constants) {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
              // iterating backwards improves 1-pass optimization
              const n = nodes[i];
              if (n.optimizeNames(names, constants)) continue;
              subtractNames(names, n.names);
              nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : undefined;
          }
          get names() {
            return this.nodes.reduce((names, n) => addNames(names, n.names), {});
          }
        }
        class BlockNode extends ParentNode {
          render(opts) {
            return "{" + opts._n + super.render(opts) + "}" + opts._n;
          }
        }
        class Root extends ParentNode {}
        class Else extends BlockNode {}
        Else.kind = "else";
        class If extends BlockNode {
          constructor(condition, nodes) {
            super(nodes);
            this.condition = condition;
          }
          render(opts) {
            let code = `if(${this.condition})` + super.render(opts);
            if (this.else) code += "else " + this.else.render(opts);
            return code;
          }
          optimizeNodes() {
            super.optimizeNodes();
            const cond = this.condition;
            if (cond === true) return this.nodes; // else is ignored here
            let e = this.else;
            if (e) {
              const ns = e.optimizeNodes();
              e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
            }
            if (e) {
              if (cond === false) return e instanceof If ? e : e.nodes;
              if (this.nodes.length) return this;
              return new If(not(cond), e instanceof If ? [e] : e.nodes);
            }
            if (cond === false || !this.nodes.length) return undefined;
            return this;
          }
          optimizeNames(names, constants) {
            var _a;
            this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
            if (!(super.optimizeNames(names, constants) || this.else)) return;
            this.condition = optimizeExpr(this.condition, names, constants);
            return this;
          }
          get names() {
            const names = super.names;
            addExprNames(names, this.condition);
            if (this.else) addNames(names, this.else.names);
            return names;
          }
        }
        If.kind = "if";
        class For extends BlockNode {}
        For.kind = "for";
        class ForLoop extends For {
          constructor(iteration) {
            super();
            this.iteration = iteration;
          }
          render(opts) {
            return `for(${this.iteration})` + super.render(opts);
          }
          optimizeNames(names, constants) {
            if (!super.optimizeNames(names, constants)) return;
            this.iteration = optimizeExpr(this.iteration, names, constants);
            return this;
          }
          get names() {
            return addNames(super.names, this.iteration.names);
          }
        }
        class ForRange extends For {
          constructor(varKind, name, from, to) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.from = from;
            this.to = to;
          }
          render(opts) {
            const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
            const { name, from, to } = this;
            return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
          }
          get names() {
            const names = addExprNames(super.names, this.from);
            return addExprNames(names, this.to);
          }
        }
        class ForIter extends For {
          constructor(loop, varKind, name, iterable) {
            super();
            this.loop = loop;
            this.varKind = varKind;
            this.name = name;
            this.iterable = iterable;
          }
          render(opts) {
            return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
          }
          optimizeNames(names, constants) {
            if (!super.optimizeNames(names, constants)) return;
            this.iterable = optimizeExpr(this.iterable, names, constants);
            return this;
          }
          get names() {
            return addNames(super.names, this.iterable.names);
          }
        }
        class Func extends BlockNode {
          constructor(name, args, async) {
            super();
            this.name = name;
            this.args = args;
            this.async = async;
          }
          render(opts) {
            const _async = this.async ? "async " : "";
            return `${_async}function ${this.name}(${this.args})` + super.render(opts);
          }
        }
        Func.kind = "func";
        class Return extends ParentNode {
          render(opts) {
            return "return " + super.render(opts);
          }
        }
        Return.kind = "return";
        class Try extends BlockNode {
          render(opts) {
            let code = "try" + super.render(opts);
            if (this.catch) code += this.catch.render(opts);
            if (this.finally) code += this.finally.render(opts);
            return code;
          }
          optimizeNodes() {
            var _a, _b;
            super.optimizeNodes();
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
            return this;
          }
          optimizeNames(names, constants) {
            var _a, _b;
            super.optimizeNames(names, constants);
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
            return this;
          }
          get names() {
            const names = super.names;
            if (this.catch) addNames(names, this.catch.names);
            if (this.finally) addNames(names, this.finally.names);
            return names;
          }
        }
        class Catch extends BlockNode {
          constructor(error) {
            super();
            this.error = error;
          }
          render(opts) {
            return `catch(${this.error})` + super.render(opts);
          }
        }
        Catch.kind = "catch";
        class Finally extends BlockNode {
          render(opts) {
            return "finally" + super.render(opts);
          }
        }
        Finally.kind = "finally";
        class CodeGen {
          constructor(extScope, opts = {}) {
            this._values = {};
            this._blockStarts = [];
            this._constants = {};
            this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
            this._extScope = extScope;
            this._scope = new scope_1.Scope({ parent: extScope });
            this._nodes = [new Root()];
          }
          toString() {
            return this._root.render(this.opts);
          }
          // returns unique name in the internal scope
          name(prefix) {
            return this._scope.name(prefix);
          }
          // reserves unique name in the external scope
          scopeName(prefix) {
            return this._extScope.name(prefix);
          }
          // reserves unique name in the external scope and assigns value to it
          scopeValue(prefixOrName, value) {
            const name = this._extScope.value(prefixOrName, value);
            const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
            vs.add(name);
            return name;
          }
          getScopeValue(prefix, keyOrRef) {
            return this._extScope.getValue(prefix, keyOrRef);
          }
          // return code that assigns values in the external scope to the names that are used internally
          // (same names that were returned by gen.scopeName or gen.scopeValue)
          scopeRefs(scopeName) {
            return this._extScope.scopeRefs(scopeName, this._values);
          }
          scopeCode() {
            return this._extScope.scopeCode(this._values);
          }
          _def(varKind, nameOrPrefix, rhs, constant) {
            const name = this._scope.toName(nameOrPrefix);
            if (rhs !== undefined && constant) this._constants[name.str] = rhs;
            this._leafNode(new Def(varKind, name, rhs));
            return name;
          }
          // `const` declaration (`var` in es5 mode)
          const(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
          }
          // `let` declaration with optional assignment (`var` in es5 mode)
          let(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
          }
          // `var` declaration with optional assignment
          var(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
          }
          // assignment code
          assign(lhs, rhs, sideEffects) {
            return this._leafNode(new Assign(lhs, rhs, sideEffects));
          }
          // `+=` code
          add(lhs, rhs) {
            return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
          }
          // appends passed SafeExpr to code or executes Block
          code(c) {
            if (typeof c == "function") c();
            else if (c !== code_1.nil) this._leafNode(new AnyCode(c));
            return this;
          }
          // returns code for object literal for the passed argument list of key-value pairs
          object(...keyValues) {
            const code = ["{"];
            for (const [key, value] of keyValues) {
              if (code.length > 1) code.push(",");
              code.push(key);
              if (key !== value || this.opts.es5) {
                code.push(":");
                (0, code_1.addCodeArg)(code, value);
              }
            }
            code.push("}");
            return new code_1._Code(code);
          }
          // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
          if(condition, thenBody, elseBody) {
            this._blockNode(new If(condition));
            if (thenBody && elseBody) {
              this.code(thenBody).else().code(elseBody).endIf();
            } else if (thenBody) {
              this.code(thenBody).endIf();
            } else if (elseBody) {
              throw new Error('CodeGen: "else" body without "then" body');
            }
            return this;
          }
          // `else if` clause - invalid without `if` or after `else` clauses
          elseIf(condition) {
            return this._elseNode(new If(condition));
          }
          // `else` clause - only valid after `if` or `else if` clauses
          else() {
            return this._elseNode(new Else());
          }
          // end `if` statement (needed if gen.if was used only with condition)
          endIf() {
            return this._endBlockNode(If, Else);
          }
          _for(node, forBody) {
            this._blockNode(node);
            if (forBody) this.code(forBody).endFor();
            return this;
          }
          // a generic `for` clause (or statement if `forBody` is passed)
          for(iteration, forBody) {
            return this._for(new ForLoop(iteration), forBody);
          }
          // `for` statement for a range of values
          forRange(
            nameOrPrefix,
            from,
            to,
            forBody,
            varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let,
          ) {
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
          }
          // `for-of` statement (in es5 mode replace with a normal for loop)
          forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
            const name = this._scope.toName(nameOrPrefix);
            if (this.opts.es5) {
              const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
              return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
                this.var(name, (0, code_1._)`${arr}[${i}]`);
                forBody(name);
              });
            }
            return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
          }
          // `for-in` statement.
          // With option `ownProperties` replaced with a `for-of` loop for object keys
          forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
            if (this.opts.ownProperties) {
              return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
            }
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
          }
          // end `for` loop
          endFor() {
            return this._endBlockNode(For);
          }
          // `label` statement
          label(label) {
            return this._leafNode(new Label(label));
          }
          // `break` statement
          break(label) {
            return this._leafNode(new Break(label));
          }
          // `return` statement
          return(value) {
            const node = new Return();
            this._blockNode(node);
            this.code(value);
            if (node.nodes.length !== 1) throw new Error('CodeGen: "return" should have one node');
            return this._endBlockNode(Return);
          }
          // `try` statement
          try(tryBody, catchCode, finallyCode) {
            if (!catchCode && !finallyCode) throw new Error('CodeGen: "try" without "catch" and "finally"');
            const node = new Try();
            this._blockNode(node);
            this.code(tryBody);
            if (catchCode) {
              const error = this.name("e");
              this._currNode = node.catch = new Catch(error);
              catchCode(error);
            }
            if (finallyCode) {
              this._currNode = node.finally = new Finally();
              this.code(finallyCode);
            }
            return this._endBlockNode(Catch, Finally);
          }
          // `throw` statement
          throw(error) {
            return this._leafNode(new Throw(error));
          }
          // start self-balancing block
          block(body, nodeCount) {
            this._blockStarts.push(this._nodes.length);
            if (body) this.code(body).endBlock(nodeCount);
            return this;
          }
          // end the current self-balancing block
          endBlock(nodeCount) {
            const len = this._blockStarts.pop();
            if (len === undefined) throw new Error("CodeGen: not in self-balancing block");
            const toClose = this._nodes.length - len;
            if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
              throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
            }
            this._nodes.length = len;
            return this;
          }
          // `function` heading (or definition if funcBody is passed)
          func(name, args = code_1.nil, async, funcBody) {
            this._blockNode(new Func(name, args, async));
            if (funcBody) this.code(funcBody).endFunc();
            return this;
          }
          // end function definition
          endFunc() {
            return this._endBlockNode(Func);
          }
          optimize(n = 1) {
            while (n-- > 0) {
              this._root.optimizeNodes();
              this._root.optimizeNames(this._root.names, this._constants);
            }
          }
          _leafNode(node) {
            this._currNode.nodes.push(node);
            return this;
          }
          _blockNode(node) {
            this._currNode.nodes.push(node);
            this._nodes.push(node);
          }
          _endBlockNode(N1, N2) {
            const n = this._currNode;
            if (n instanceof N1 || (N2 && n instanceof N2)) {
              this._nodes.pop();
              return this;
            }
            throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
          }
          _elseNode(node) {
            const n = this._currNode;
            if (!(n instanceof If)) {
              throw new Error('CodeGen: "else" without "if"');
            }
            this._currNode = n.else = node;
            return this;
          }
          get _root() {
            return this._nodes[0];
          }
          get _currNode() {
            const ns = this._nodes;
            return ns[ns.length - 1];
          }
          set _currNode(node) {
            const ns = this._nodes;
            ns[ns.length - 1] = node;
          }
        }
        exports.CodeGen = CodeGen;
        function addNames(names, from) {
          for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);
          return names;
        }
        function addExprNames(names, from) {
          return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
        }
        function optimizeExpr(expr, names, constants) {
          if (expr instanceof code_1.Name) return replaceName(expr);
          if (!canOptimize(expr)) return expr;
          return new code_1._Code(
            expr._items.reduce((items, c) => {
              if (c instanceof code_1.Name) c = replaceName(c);
              if (c instanceof code_1._Code) items.push(...c._items);
              else items.push(c);
              return items;
            }, []),
          );
          function replaceName(n) {
            const c = constants[n.str];
            if (c === undefined || names[n.str] !== 1) return n;
            delete names[n.str];
            return c;
          }
          function canOptimize(e) {
            return (
              e instanceof code_1._Code &&
              e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined)
            );
          }
        }
        function subtractNames(names, from) {
          for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);
        }
        function not(x) {
          return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
        }
        exports.not = not;
        const andCode = mappend(exports.operators.AND);
        // boolean AND (&&) expression with the passed arguments
        function and(...args) {
          return args.reduce(andCode);
        }
        exports.and = and;
        const orCode = mappend(exports.operators.OR);
        // boolean OR (||) expression with the passed arguments
        function or(...args) {
          return args.reduce(orCode);
        }
        exports.or = or;
        function mappend(op) {
          return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`);
        }
        function par(x) {
          return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
        }
      },
      { "./code": 48, "./scope": 50 },
    ],
    50: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ValueScope =
          exports.ValueScopeName =
          exports.Scope =
          exports.varKinds =
          exports.UsedValueState =
            void 0;
        const code_1 = require("./code");
        class ValueError extends Error {
          constructor(name) {
            super(`CodeGen: "code" for ${name} not defined`);
            this.value = name.value;
          }
        }
        var UsedValueState;
        (function (UsedValueState) {
          UsedValueState[(UsedValueState["Started"] = 0)] = "Started";
          UsedValueState[(UsedValueState["Completed"] = 1)] = "Completed";
        })((UsedValueState = exports.UsedValueState || (exports.UsedValueState = {})));
        exports.varKinds = {
          const: new code_1.Name("const"),
          let: new code_1.Name("let"),
          var: new code_1.Name("var"),
        };
        class Scope {
          constructor({ prefixes, parent } = {}) {
            this._names = {};
            this._prefixes = prefixes;
            this._parent = parent;
          }
          toName(nameOrPrefix) {
            return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
          }
          name(prefix) {
            return new code_1.Name(this._newName(prefix));
          }
          _newName(prefix) {
            const ng = this._names[prefix] || this._nameGroup(prefix);
            return `${prefix}${ng.index++}`;
          }
          _nameGroup(prefix) {
            var _a, _b;
            if (
              ((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0
                ? void 0
                : _b.has(prefix)) ||
              (this._prefixes && !this._prefixes.has(prefix))
            ) {
              throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
            }
            return (this._names[prefix] = { prefix, index: 0 });
          }
        }
        exports.Scope = Scope;
        class ValueScopeName extends code_1.Name {
          constructor(prefix, nameStr) {
            super(nameStr);
            this.prefix = prefix;
          }
          setValue(value, { property, itemIndex }) {
            this.value = value;
            this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
          }
        }
        exports.ValueScopeName = ValueScopeName;
        const line = (0, code_1._)`\n`;
        class ValueScope extends Scope {
          constructor(opts) {
            super(opts);
            this._values = {};
            this._scope = opts.scope;
            this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
          }
          get() {
            return this._scope;
          }
          name(prefix) {
            return new ValueScopeName(prefix, this._newName(prefix));
          }
          value(nameOrPrefix, value) {
            var _a;
            if (value.ref === undefined) throw new Error("CodeGen: ref must be passed in value");
            const name = this.toName(nameOrPrefix);
            const { prefix } = name;
            const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
            let vs = this._values[prefix];
            if (vs) {
              const _name = vs.get(valueKey);
              if (_name) return _name;
            } else {
              vs = this._values[prefix] = new Map();
            }
            vs.set(valueKey, name);
            const s = this._scope[prefix] || (this._scope[prefix] = []);
            const itemIndex = s.length;
            s[itemIndex] = value.ref;
            name.setValue(value, { property: prefix, itemIndex });
            return name;
          }
          getValue(prefix, keyOrRef) {
            const vs = this._values[prefix];
            if (!vs) return;
            return vs.get(keyOrRef);
          }
          scopeRefs(scopeName, values = this._values) {
            return this._reduceValues(values, (name) => {
              if (name.scopePath === undefined) throw new Error(`CodeGen: name "${name}" has no value`);
              return (0, code_1._)`${scopeName}${name.scopePath}`;
            });
          }
          scopeCode(values = this._values, usedValues, getCode) {
            return this._reduceValues(
              values,
              (name) => {
                if (name.value === undefined) throw new Error(`CodeGen: name "${name}" has no value`);
                return name.value.code;
              },
              usedValues,
              getCode,
            );
          }
          _reduceValues(values, valueCode, usedValues = {}, getCode) {
            let code = code_1.nil;
            for (const prefix in values) {
              const vs = values[prefix];
              if (!vs) continue;
              const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
              vs.forEach((name) => {
                if (nameSet.has(name)) return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                  const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                  code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
                } else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                  code = (0, code_1._)`${code}${c}${this.opts._n}`;
                } else {
                  throw new ValueError(name);
                }
                nameSet.set(name, UsedValueState.Completed);
              });
            }
            return code;
          }
        }
        exports.ValueScope = ValueScope;
      },
      { "./code": 48 },
    ],
    51: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.extendErrors =
          exports.resetErrorsCount =
          exports.reportExtraError =
          exports.reportError =
          exports.keyword$DataError =
          exports.keywordError =
            void 0;
        const codegen_1 = require("./codegen");
        const util_1 = require("./util");
        const names_1 = require("./names");
        exports.keywordError = {
          message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`,
        };
        exports.keyword$DataError = {
          message: ({ keyword, schemaType }) =>
            schemaType
              ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)`
              : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`,
        };
        function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
          const { it } = cxt;
          const { gen, compositeRule, allErrors } = it;
          const errObj = errorObjectCode(cxt, error, errorPaths);
          if (
            overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors
          ) {
            addError(gen, errObj);
          } else {
            returnErrors(it, (0, codegen_1._)`[${errObj}]`);
          }
        }
        exports.reportError = reportError;
        function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
          const { it } = cxt;
          const { gen, compositeRule, allErrors } = it;
          const errObj = errorObjectCode(cxt, error, errorPaths);
          addError(gen, errObj);
          if (!(compositeRule || allErrors)) {
            returnErrors(it, names_1.default.vErrors);
          }
        }
        exports.reportExtraError = reportExtraError;
        function resetErrorsCount(gen, errsCount) {
          gen.assign(names_1.default.errors, errsCount);
          gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () =>
            gen.if(
              errsCount,
              () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount),
              () => gen.assign(names_1.default.vErrors, null),
            ),
          );
        }
        exports.resetErrorsCount = resetErrorsCount;
        function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
          /* istanbul ignore if */
          if (errsCount === undefined) throw new Error("ajv implementation error");
          const err = gen.name("err");
          gen.forRange("i", errsCount, names_1.default.errors, (i) => {
            gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
            gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () =>
              gen.assign(
                (0, codegen_1._)`${err}.instancePath`,
                (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath),
              ),
            );
            gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
            if (it.opts.verbose) {
              gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
              gen.assign((0, codegen_1._)`${err}.data`, data);
            }
          });
        }
        exports.extendErrors = extendErrors;
        function addError(gen, errObj) {
          const err = gen.const("err", errObj);
          gen.if(
            (0, codegen_1._)`${names_1.default.vErrors} === null`,
            () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`),
            (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`,
          );
          gen.code((0, codegen_1._)`${names_1.default.errors}++`);
        }
        function returnErrors(it, errs) {
          const { gen, validateName, schemaEnv } = it;
          if (schemaEnv.$async) {
            gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
          } else {
            gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
            gen.return(false);
          }
        }
        const E = {
          keyword: new codegen_1.Name("keyword"),
          schemaPath: new codegen_1.Name("schemaPath"),
          params: new codegen_1.Name("params"),
          propertyName: new codegen_1.Name("propertyName"),
          message: new codegen_1.Name("message"),
          schema: new codegen_1.Name("schema"),
          parentSchema: new codegen_1.Name("parentSchema"),
        };
        function errorObjectCode(cxt, error, errorPaths) {
          const { createErrors } = cxt.it;
          if (createErrors === false) return (0, codegen_1._)`{}`;
          return errorObject(cxt, error, errorPaths);
        }
        function errorObject(cxt, error, errorPaths = {}) {
          const { gen, it } = cxt;
          const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];
          extraErrorProps(cxt, error, keyValues);
          return gen.object(...keyValues);
        }
        function errorInstancePath({ errorPath }, { instancePath }) {
          const instPath = instancePath
            ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
            : errorPath;
          return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
        }
        function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
          let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
          if (schemaPath) {
            schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
          }
          return [E.schemaPath, schPath];
        }
        function extraErrorProps(cxt, { params, message }, keyValues) {
          const { keyword, data, schemaValue, it } = cxt;
          const { opts, propertyName, topSchemaRef, schemaPath } = it;
          keyValues.push(
            [E.keyword, keyword],
            [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`],
          );
          if (opts.messages) {
            keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
          }
          if (opts.verbose) {
            keyValues.push(
              [E.schema, schemaValue],
              [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`],
              [names_1.default.data, data],
            );
          }
          if (propertyName) keyValues.push([E.propertyName, propertyName]);
        }
      },
      { "./codegen": 49, "./names": 53, "./util": 57 },
    ],
    52: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.resolveSchema =
          exports.getCompilingSchema =
          exports.resolveRef =
          exports.compileSchema =
          exports.SchemaEnv =
            void 0;
        const codegen_1 = require("./codegen");
        const validation_error_1 = require("../runtime/validation_error");
        const names_1 = require("./names");
        const resolve_1 = require("./resolve");
        const util_1 = require("./util");
        const validate_1 = require("./validate");
        class SchemaEnv {
          constructor(env) {
            var _a;
            this.refs = {};
            this.dynamicAnchors = {};
            let schema;
            if (typeof env.schema == "object") schema = env.schema;
            this.schema = env.schema;
            this.schemaId = env.schemaId;
            this.root = env.root || this;
            this.baseId =
              (_a = env.baseId) !== null && _a !== void 0
                ? _a
                : (0, resolve_1.normalizeId)(
                    schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"],
                  );
            this.schemaPath = env.schemaPath;
            this.localRefs = env.localRefs;
            this.meta = env.meta;
            this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
            this.refs = {};
          }
        }
        exports.SchemaEnv = SchemaEnv;
        // let codeSize = 0
        // let nodeCount = 0
        // Compiles schema in SchemaEnv
        function compileSchema(sch) {
          // TODO refactor - remove compilations
          const _sch = getCompilingSchema.call(this, sch);
          if (_sch) return _sch;
          const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
          const { es5, lines } = this.opts.code;
          const { ownProperties } = this.opts;
          const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
          let _ValidationError;
          if (sch.$async) {
            _ValidationError = gen.scopeValue("Error", {
              ref: validation_error_1.default,
              code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`,
            });
          }
          const validateName = gen.scopeName("validate");
          sch.validateName = validateName;
          const schemaCxt = {
            gen,
            allErrors: this.opts.allErrors,
            data: names_1.default.data,
            parentData: names_1.default.parentData,
            parentDataProperty: names_1.default.parentDataProperty,
            dataNames: [names_1.default.data],
            dataPathArr: [codegen_1.nil],
            dataLevel: 0,
            dataTypes: [],
            definedProperties: new Set(),
            topSchemaRef: gen.scopeValue(
              "schema",
              this.opts.code.source === true
                ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
                : { ref: sch.schema },
            ),
            validateName,
            ValidationError: _ValidationError,
            schema: sch.schema,
            schemaEnv: sch,
            rootId,
            baseId: sch.baseId || rootId,
            schemaPath: codegen_1.nil,
            errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
            errorPath: (0, codegen_1._)`""`,
            opts: this.opts,
            self: this,
          };
          let sourceCode;
          try {
            this._compilations.add(sch);
            (0, validate_1.validateFunctionCode)(schemaCxt);
            gen.optimize(this.opts.code.optimize);
            // gen.optimize(1)
            const validateCode = gen.toString();
            sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
            // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
            if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
            // console.log("\n\n\n *** \n", sourceCode)
            const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
            const validate = makeValidate(this, this.scope.get());
            this.scope.value(validateName, { ref: validate });
            validate.errors = null;
            validate.schema = sch.schema;
            validate.schemaEnv = sch;
            if (sch.$async) validate.$async = true;
            if (this.opts.code.source === true) {
              validate.source = { validateName, validateCode, scopeValues: gen._values };
            }
            if (this.opts.unevaluated) {
              const { props, items } = schemaCxt;
              validate.evaluated = {
                props: props instanceof codegen_1.Name ? undefined : props,
                items: items instanceof codegen_1.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1.Name,
                dynamicItems: items instanceof codegen_1.Name,
              };
              if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
            }
            sch.validate = validate;
            return sch;
          } catch (e) {
            delete sch.validate;
            delete sch.validateName;
            if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
            // console.log("\n\n\n *** \n", sourceCode, this.opts)
            throw e;
          } finally {
            this._compilations.delete(sch);
          }
        }
        exports.compileSchema = compileSchema;
        function resolveRef(root, baseId, ref) {
          var _a;
          ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
          const schOrFunc = root.refs[ref];
          if (schOrFunc) return schOrFunc;
          let _sch = resolve.call(this, root, ref);
          if (_sch === undefined) {
            const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
            const { schemaId } = this.opts;
            if (schema) _sch = new SchemaEnv({ schema, schemaId, root, baseId });
          }
          if (_sch === undefined) return;
          return (root.refs[ref] = inlineOrCompile.call(this, _sch));
        }
        exports.resolveRef = resolveRef;
        function inlineOrCompile(sch) {
          if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
          return sch.validate ? sch : compileSchema.call(this, sch);
        }
        // Index of schema compilation in the currently compiled list
        function getCompilingSchema(schEnv) {
          for (const sch of this._compilations) {
            if (sameSchemaEnv(sch, schEnv)) return sch;
          }
        }
        exports.getCompilingSchema = getCompilingSchema;
        function sameSchemaEnv(s1, s2) {
          return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
        }
        // resolve and compile the references ($ref)
        // TODO returns AnySchemaObject (if the schema can be inlined) or validation function
        function resolve(
          root, // information about the root schema for the current schema
          ref, // reference to resolve
        ) {
          let sch;
          while (typeof (sch = this.refs[ref]) == "string") ref = sch;
          return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
        }
        // Resolve schema, its root and baseId
        function resolveSchema(
          root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
          ref, // reference to resolve
        ) {
          const p = this.opts.uriResolver.parse(ref);
          const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
          let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
          // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
          if (Object.keys(root.schema).length > 0 && refPath === baseId) {
            return getJsonPointer.call(this, p, root);
          }
          const id = (0, resolve_1.normalizeId)(refPath);
          const schOrRef = this.refs[id] || this.schemas[id];
          if (typeof schOrRef == "string") {
            const sch = resolveSchema.call(this, root, schOrRef);
            if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
            return getJsonPointer.call(this, p, sch);
          }
          if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
          if (!schOrRef.validate) compileSchema.call(this, schOrRef);
          if (id === (0, resolve_1.normalizeId)(ref)) {
            const { schema } = schOrRef;
            const { schemaId } = this.opts;
            const schId = schema[schemaId];
            if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
            return new SchemaEnv({ schema, schemaId, root, baseId });
          }
          return getJsonPointer.call(this, p, schOrRef);
        }
        exports.resolveSchema = resolveSchema;
        const PREVENT_SCOPE_CHANGE = new Set([
          "properties",
          "patternProperties",
          "enum",
          "dependencies",
          "definitions",
        ]);
        function getJsonPointer(parsedRef, { baseId, schema, root }) {
          var _a;
          if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/") return;
          for (const part of parsedRef.fragment.slice(1).split("/")) {
            if (typeof schema === "boolean") return;
            const partSchema = schema[(0, util_1.unescapeFragment)(part)];
            if (partSchema === undefined) return;
            schema = partSchema;
            // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
            const schId = typeof schema === "object" && schema[this.opts.schemaId];
            if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
              baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
            }
          }
          let env;
          if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
            const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
            env = resolveSchema.call(this, root, $ref);
          }
          // even though resolution failed we need to return SchemaEnv to throw exception
          // so that compileAsync loads missing schema.
          const { schemaId } = this.opts;
          env = env || new SchemaEnv({ schema, schemaId, root, baseId });
          if (env.schema !== env.root.schema) return env;
          return undefined;
        }
      },
      {
        "../runtime/validation_error": 79,
        "./codegen": 49,
        "./names": 53,
        "./resolve": 55,
        "./util": 57,
        "./validate": 62,
      },
    ],
    53: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("./codegen");
        const names = {
          // validation function arguments
          data: new codegen_1.Name("data"),
          // args passed from referencing schema
          valCxt: new codegen_1.Name("valCxt"),
          instancePath: new codegen_1.Name("instancePath"),
          parentData: new codegen_1.Name("parentData"),
          parentDataProperty: new codegen_1.Name("parentDataProperty"),
          rootData: new codegen_1.Name("rootData"),
          dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
          // function scoped variables
          vErrors: new codegen_1.Name("vErrors"),
          errors: new codegen_1.Name("errors"),
          this: new codegen_1.Name("this"),
          // "globals"
          self: new codegen_1.Name("self"),
          scope: new codegen_1.Name("scope"),
          // JTD serialize/parse name for JSON string and position
          json: new codegen_1.Name("json"),
          jsonPos: new codegen_1.Name("jsonPos"),
          jsonLen: new codegen_1.Name("jsonLen"),
          jsonPart: new codegen_1.Name("jsonPart"),
        };
        exports.default = names;
      },
      { "./codegen": 49 },
    ],
    54: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const resolve_1 = require("./resolve");
        class MissingRefError extends Error {
          constructor(resolver, baseId, ref, msg) {
            super(msg || `can't resolve reference ${ref} from id ${baseId}`);
            this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
            this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
          }
        }
        exports.default = MissingRefError;
      },
      { "./resolve": 55 },
    ],
    55: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.getSchemaRefs =
          exports.resolveUrl =
          exports.normalizeId =
          exports._getFullPath =
          exports.getFullPath =
          exports.inlineRef =
            void 0;
        const util_1 = require("./util");
        const equal = require("fast-deep-equal");
        const traverse = require("json-schema-traverse");
        // TODO refactor to use keyword definitions
        const SIMPLE_INLINED = new Set([
          "type",
          "format",
          "pattern",
          "maxLength",
          "minLength",
          "maxProperties",
          "minProperties",
          "maxItems",
          "minItems",
          "maximum",
          "minimum",
          "uniqueItems",
          "multipleOf",
          "required",
          "enum",
          "const",
        ]);
        function inlineRef(schema, limit = true) {
          if (typeof schema == "boolean") return true;
          if (limit === true) return !hasRef(schema);
          if (!limit) return false;
          return countKeys(schema) <= limit;
        }
        exports.inlineRef = inlineRef;
        const REF_KEYWORDS = new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
        function hasRef(schema) {
          for (const key in schema) {
            if (REF_KEYWORDS.has(key)) return true;
            const sch = schema[key];
            if (Array.isArray(sch) && sch.some(hasRef)) return true;
            if (typeof sch == "object" && hasRef(sch)) return true;
          }
          return false;
        }
        function countKeys(schema) {
          let count = 0;
          for (const key in schema) {
            if (key === "$ref") return Infinity;
            count++;
            if (SIMPLE_INLINED.has(key)) continue;
            if (typeof schema[key] == "object") {
              (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
            }
            if (count === Infinity) return Infinity;
          }
          return count;
        }
        function getFullPath(resolver, id = "", normalize) {
          if (normalize !== false) id = normalizeId(id);
          const p = resolver.parse(id);
          return _getFullPath(resolver, p);
        }
        exports.getFullPath = getFullPath;
        function _getFullPath(resolver, p) {
          const serialized = resolver.serialize(p);
          return serialized.split("#")[0] + "#";
        }
        exports._getFullPath = _getFullPath;
        const TRAILING_SLASH_HASH = /#\/?$/;
        function normalizeId(id) {
          return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
        }
        exports.normalizeId = normalizeId;
        function resolveUrl(resolver, baseId, id) {
          id = normalizeId(id);
          return resolver.resolve(baseId, id);
        }
        exports.resolveUrl = resolveUrl;
        const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
        function getSchemaRefs(schema, baseId) {
          if (typeof schema == "boolean") return {};
          const { schemaId, uriResolver } = this.opts;
          const schId = normalizeId(schema[schemaId] || baseId);
          const baseIds = { "": schId };
          const pathPrefix = getFullPath(uriResolver, schId, false);
          const localRefs = {};
          const schemaRefs = new Set();
          traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
            if (parentJsonPtr === undefined) return;
            const fullPath = pathPrefix + jsonPtr;
            let baseId = baseIds[parentJsonPtr];
            if (typeof sch[schemaId] == "string") baseId = addRef.call(this, sch[schemaId]);
            addAnchor.call(this, sch.$anchor);
            addAnchor.call(this, sch.$dynamicAnchor);
            baseIds[jsonPtr] = baseId;
            function addRef(ref) {
              // eslint-disable-next-line @typescript-eslint/unbound-method
              const _resolve = this.opts.uriResolver.resolve;
              ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);
              if (schemaRefs.has(ref)) throw ambiguos(ref);
              schemaRefs.add(ref);
              let schOrRef = this.refs[ref];
              if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
              if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
              } else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                  checkAmbiguosRef(sch, localRefs[ref], ref);
                  localRefs[ref] = sch;
                } else {
                  this.refs[ref] = fullPath;
                }
              }
              return ref;
            }
            function addAnchor(anchor) {
              if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
              }
            }
          });
          return localRefs;
          function checkAmbiguosRef(sch1, sch2, ref) {
            if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);
          }
          function ambiguos(ref) {
            return new Error(`reference "${ref}" resolves to more than one schema`);
          }
        }
        exports.getSchemaRefs = getSchemaRefs;
      },
      { "./util": 57, "fast-deep-equal": 136, "json-schema-traverse": 171 },
    ],
    56: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.getRules = exports.isJSONType = void 0;
        const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
        const jsonTypes = new Set(_jsonTypes);
        function isJSONType(x) {
          return typeof x == "string" && jsonTypes.has(x);
        }
        exports.isJSONType = isJSONType;
        function getRules() {
          const groups = {
            number: { type: "number", rules: [] },
            string: { type: "string", rules: [] },
            array: { type: "array", rules: [] },
            object: { type: "object", rules: [] },
          };
          return {
            types: { ...groups, integer: true, boolean: true, null: true },
            rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
            post: { rules: [] },
            all: {},
            keywords: {},
          };
        }
        exports.getRules = getRules;
      },
      {},
    ],
    57: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.checkStrictMode =
          exports.getErrorPath =
          exports.Type =
          exports.useFunc =
          exports.setEvaluated =
          exports.evaluatedPropsToName =
          exports.mergeEvaluated =
          exports.eachItem =
          exports.unescapeJsonPointer =
          exports.escapeJsonPointer =
          exports.escapeFragment =
          exports.unescapeFragment =
          exports.schemaRefOrVal =
          exports.schemaHasRulesButRef =
          exports.schemaHasRules =
          exports.checkUnknownRules =
          exports.alwaysValidSchema =
          exports.toHash =
            void 0;
        const codegen_1 = require("./codegen");
        const code_1 = require("./codegen/code");
        // TODO refactor to use Set
        function toHash(arr) {
          const hash = {};
          for (const item of arr) hash[item] = true;
          return hash;
        }
        exports.toHash = toHash;
        function alwaysValidSchema(it, schema) {
          if (typeof schema == "boolean") return schema;
          if (Object.keys(schema).length === 0) return true;
          checkUnknownRules(it, schema);
          return !schemaHasRules(schema, it.self.RULES.all);
        }
        exports.alwaysValidSchema = alwaysValidSchema;
        function checkUnknownRules(it, schema = it.schema) {
          const { opts, self } = it;
          if (!opts.strictSchema) return;
          if (typeof schema === "boolean") return;
          const rules = self.RULES.keywords;
          for (const key in schema) {
            if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
          }
        }
        exports.checkUnknownRules = checkUnknownRules;
        function schemaHasRules(schema, rules) {
          if (typeof schema == "boolean") return !schema;
          for (const key in schema) if (rules[key]) return true;
          return false;
        }
        exports.schemaHasRules = schemaHasRules;
        function schemaHasRulesButRef(schema, RULES) {
          if (typeof schema == "boolean") return !schema;
          for (const key in schema) if (key !== "$ref" && RULES.all[key]) return true;
          return false;
        }
        exports.schemaHasRulesButRef = schemaHasRulesButRef;
        function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
          if (!$data) {
            if (typeof schema == "number" || typeof schema == "boolean") return schema;
            if (typeof schema == "string") return (0, codegen_1._)`${schema}`;
          }
          return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
        }
        exports.schemaRefOrVal = schemaRefOrVal;
        function unescapeFragment(str) {
          return unescapeJsonPointer(decodeURIComponent(str));
        }
        exports.unescapeFragment = unescapeFragment;
        function escapeFragment(str) {
          return encodeURIComponent(escapeJsonPointer(str));
        }
        exports.escapeFragment = escapeFragment;
        function escapeJsonPointer(str) {
          if (typeof str == "number") return `${str}`;
          return str.replace(/~/g, "~0").replace(/\//g, "~1");
        }
        exports.escapeJsonPointer = escapeJsonPointer;
        function unescapeJsonPointer(str) {
          return str.replace(/~1/g, "/").replace(/~0/g, "~");
        }
        exports.unescapeJsonPointer = unescapeJsonPointer;
        function eachItem(xs, f) {
          if (Array.isArray(xs)) {
            for (const x of xs) f(x);
          } else {
            f(xs);
          }
        }
        exports.eachItem = eachItem;
        function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
          return (gen, from, to, toName) => {
            const res =
              to === undefined
                ? from
                : to instanceof codegen_1.Name
                  ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                  : from instanceof codegen_1.Name
                    ? (mergeToName(gen, to, from), from)
                    : mergeValues(from, to);
            return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
          };
        }
        exports.mergeEvaluated = {
          props: makeMergeEvaluated({
            mergeNames: (gen, from, to) =>
              gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
                gen.if(
                  (0, codegen_1._)`${from} === true`,
                  () => gen.assign(to, true),
                  () =>
                    gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`),
                );
              }),
            mergeToName: (gen, from, to) =>
              gen.if((0, codegen_1._)`${to} !== true`, () => {
                if (from === true) {
                  gen.assign(to, true);
                } else {
                  gen.assign(to, (0, codegen_1._)`${to} || {}`);
                  setEvaluated(gen, to, from);
                }
              }),
            mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
            resultToName: evaluatedPropsToName,
          }),
          items: makeMergeEvaluated({
            mergeNames: (gen, from, to) =>
              gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () =>
                gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`),
              ),
            mergeToName: (gen, from, to) =>
              gen.if((0, codegen_1._)`${to} !== true`, () =>
                gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`),
              ),
            mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
            resultToName: (gen, items) => gen.var("items", items),
          }),
        };
        function evaluatedPropsToName(gen, ps) {
          if (ps === true) return gen.var("props", true);
          const props = gen.var("props", (0, codegen_1._)`{}`);
          if (ps !== undefined) setEvaluated(gen, props, ps);
          return props;
        }
        exports.evaluatedPropsToName = evaluatedPropsToName;
        function setEvaluated(gen, props, ps) {
          Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
        }
        exports.setEvaluated = setEvaluated;
        const snippets = {};
        function useFunc(gen, f) {
          return gen.scopeValue("func", {
            ref: f,
            code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
          });
        }
        exports.useFunc = useFunc;
        var Type;
        (function (Type) {
          Type[(Type["Num"] = 0)] = "Num";
          Type[(Type["Str"] = 1)] = "Str";
        })((Type = exports.Type || (exports.Type = {})));
        function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
          // let path
          if (dataProp instanceof codegen_1.Name) {
            const isNumber = dataPropType === Type.Num;
            return jsPropertySyntax
              ? isNumber
                ? (0, codegen_1._)`"[" + ${dataProp} + "]"`
                : (0, codegen_1._)`"['" + ${dataProp} + "']"`
              : isNumber
                ? (0, codegen_1._)`"/" + ${dataProp}`
                : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
          }
          return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
        }
        exports.getErrorPath = getErrorPath;
        function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
          if (!mode) return;
          msg = `strict mode: ${msg}`;
          if (mode === true) throw new Error(msg);
          it.self.logger.warn(msg);
        }
        exports.checkStrictMode = checkStrictMode;
      },
      { "./codegen": 49, "./codegen/code": 48 },
    ],
    58: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
        function schemaHasRulesForType({ schema, self }, type) {
          const group = self.RULES.types[type];
          return group && group !== true && shouldUseGroup(schema, group);
        }
        exports.schemaHasRulesForType = schemaHasRulesForType;
        function shouldUseGroup(schema, group) {
          return group.rules.some((rule) => shouldUseRule(schema, rule));
        }
        exports.shouldUseGroup = shouldUseGroup;
        function shouldUseRule(schema, rule) {
          var _a;
          return (
            schema[rule.keyword] !== undefined ||
            ((_a = rule.definition.implements) === null || _a === void 0
              ? void 0
              : _a.some((kwd) => schema[kwd] !== undefined))
          );
        }
        exports.shouldUseRule = shouldUseRule;
      },
      {},
    ],
    59: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
        const errors_1 = require("../errors");
        const codegen_1 = require("../codegen");
        const names_1 = require("../names");
        const boolError = {
          message: "boolean schema is false",
        };
        function topBoolOrEmptySchema(it) {
          const { gen, schema, validateName } = it;
          if (schema === false) {
            falseSchemaError(it, false);
          } else if (typeof schema == "object" && schema.$async === true) {
            gen.return(names_1.default.data);
          } else {
            gen.assign((0, codegen_1._)`${validateName}.errors`, null);
            gen.return(true);
          }
        }
        exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
        function boolOrEmptySchema(it, valid) {
          const { gen, schema } = it;
          if (schema === false) {
            gen.var(valid, false); // TODO var
            falseSchemaError(it);
          } else {
            gen.var(valid, true); // TODO var
          }
        }
        exports.boolOrEmptySchema = boolOrEmptySchema;
        function falseSchemaError(it, overrideAllErrors) {
          const { gen, data } = it;
          // TODO maybe some other interface should be used for non-keyword validation errors...
          const cxt = {
            gen,
            keyword: "false schema",
            data,
            schema: false,
            schemaCode: false,
            schemaValue: false,
            params: {},
            it,
          };
          (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
        }
      },
      { "../codegen": 49, "../errors": 51, "../names": 53 },
    ],
    60: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.reportTypeError =
          exports.checkDataTypes =
          exports.checkDataType =
          exports.coerceAndCheckDataType =
          exports.getJSONTypes =
          exports.getSchemaTypes =
          exports.DataType =
            void 0;
        const rules_1 = require("../rules");
        const applicability_1 = require("./applicability");
        const errors_1 = require("../errors");
        const codegen_1 = require("../codegen");
        const util_1 = require("../util");
        var DataType;
        (function (DataType) {
          DataType[(DataType["Correct"] = 0)] = "Correct";
          DataType[(DataType["Wrong"] = 1)] = "Wrong";
        })((DataType = exports.DataType || (exports.DataType = {})));
        function getSchemaTypes(schema) {
          const types = getJSONTypes(schema.type);
          const hasNull = types.includes("null");
          if (hasNull) {
            if (schema.nullable === false) throw new Error("type: null contradicts nullable: false");
          } else {
            if (!types.length && schema.nullable !== undefined) {
              throw new Error('"nullable" cannot be used without "type"');
            }
            if (schema.nullable === true) types.push("null");
          }
          return types;
        }
        exports.getSchemaTypes = getSchemaTypes;
        function getJSONTypes(ts) {
          const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
          if (types.every(rules_1.isJSONType)) return types;
          throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
        }
        exports.getJSONTypes = getJSONTypes;
        function coerceAndCheckDataType(it, types) {
          const { gen, data, opts } = it;
          const coerceTo = coerceToTypes(types, opts.coerceTypes);
          const checkTypes =
            types.length > 0 &&
            !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
          if (checkTypes) {
            const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
            gen.if(wrongType, () => {
              if (coerceTo.length) coerceData(it, types, coerceTo);
              else reportTypeError(it);
            });
          }
          return checkTypes;
        }
        exports.coerceAndCheckDataType = coerceAndCheckDataType;
        const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
        function coerceToTypes(types, coerceTypes) {
          return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array")) : [];
        }
        function coerceData(it, types, coerceTo) {
          const { gen, data, opts } = it;
          const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
          const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
          if (opts.coerceTypes === "array") {
            gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>
              gen
                .assign(data, (0, codegen_1._)`${data}[0]`)
                .assign(dataType, (0, codegen_1._)`typeof ${data}`)
                .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)),
            );
          }
          gen.if((0, codegen_1._)`${coerced} !== undefined`);
          for (const t of coerceTo) {
            if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
              coerceSpecificType(t);
            }
          }
          gen.else();
          reportTypeError(it);
          gen.endIf();
          gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
            gen.assign(data, coerced);
            assignParentData(it, coerced);
          });
          function coerceSpecificType(t) {
            switch (t) {
              case "string":
                gen
                  .elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`)
                  .assign(coerced, (0, codegen_1._)`"" + ${data}`)
                  .elseIf((0, codegen_1._)`${data} === null`)
                  .assign(coerced, (0, codegen_1._)`""`);
                return;
              case "number":
                gen
                  .elseIf(
                    (0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`,
                  )
                  .assign(coerced, (0, codegen_1._)`+${data}`);
                return;
              case "integer":
                gen
                  .elseIf(
                    (0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`,
                  )
                  .assign(coerced, (0, codegen_1._)`+${data}`);
                return;
              case "boolean":
                gen
                  .elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`)
                  .assign(coerced, false)
                  .elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`)
                  .assign(coerced, true);
                return;
              case "null":
                gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
                gen.assign(coerced, null);
                return;
              case "array":
                gen
                  .elseIf(
                    (0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`,
                  )
                  .assign(coerced, (0, codegen_1._)`[${data}]`);
            }
          }
        }
        function assignParentData({ gen, parentData, parentDataProperty }, expr) {
          // TODO use gen.property
          gen.if((0, codegen_1._)`${parentData} !== undefined`, () =>
            gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr),
          );
        }
        function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
          const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
          let cond;
          switch (dataType) {
            case "null":
              return (0, codegen_1._)`${data} ${EQ} null`;
            case "array":
              cond = (0, codegen_1._)`Array.isArray(${data})`;
              break;
            case "object":
              cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
              break;
            case "integer":
              cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
              break;
            case "number":
              cond = numCond();
              break;
            default:
              return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
          }
          return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
          function numCond(_cond = codegen_1.nil) {
            return (0, codegen_1.and)(
              (0, codegen_1._)`typeof ${data} == "number"`,
              _cond,
              strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil,
            );
          }
        }
        exports.checkDataType = checkDataType;
        function checkDataTypes(dataTypes, data, strictNums, correct) {
          if (dataTypes.length === 1) {
            return checkDataType(dataTypes[0], data, strictNums, correct);
          }
          let cond;
          const types = (0, util_1.toHash)(dataTypes);
          if (types.array && types.object) {
            const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
            cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
            delete types.null;
            delete types.array;
            delete types.object;
          } else {
            cond = codegen_1.nil;
          }
          if (types.number) delete types.integer;
          for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
          return cond;
        }
        exports.checkDataTypes = checkDataTypes;
        const typeError = {
          message: ({ schema }) => `must be ${schema}`,
          params: ({ schema, schemaValue }) =>
            typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`,
        };
        function reportTypeError(it) {
          const cxt = getTypeErrorContext(it);
          (0, errors_1.reportError)(cxt, typeError);
        }
        exports.reportTypeError = reportTypeError;
        function getTypeErrorContext(it) {
          const { gen, data, schema } = it;
          const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
          return {
            gen,
            keyword: "type",
            data,
            schema: schema.type,
            schemaCode,
            schemaValue: schemaCode,
            parentSchema: schema,
            params: {},
            it,
          };
        }
      },
      { "../codegen": 49, "../errors": 51, "../rules": 56, "../util": 57, "./applicability": 58 },
    ],
    61: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.assignDefaults = void 0;
        const codegen_1 = require("../codegen");
        const util_1 = require("../util");
        function assignDefaults(it, ty) {
          const { properties, items } = it.schema;
          if (ty === "object" && properties) {
            for (const key in properties) {
              assignDefault(it, key, properties[key].default);
            }
          } else if (ty === "array" && Array.isArray(items)) {
            items.forEach((sch, i) => assignDefault(it, i, sch.default));
          }
        }
        exports.assignDefaults = assignDefaults;
        function assignDefault(it, prop, defaultValue) {
          const { gen, compositeRule, data, opts } = it;
          if (defaultValue === undefined) return;
          const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
          if (compositeRule) {
            (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
            return;
          }
          let condition = (0, codegen_1._)`${childData} === undefined`;
          if (opts.useDefaults === "empty") {
            condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
          }
          // `${childData} === undefined` +
          // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
          gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
        }
      },
      { "../codegen": 49, "../util": 57 },
    ],
    62: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
        const boolSchema_1 = require("./boolSchema");
        const dataType_1 = require("./dataType");
        const applicability_1 = require("./applicability");
        const dataType_2 = require("./dataType");
        const defaults_1 = require("./defaults");
        const keyword_1 = require("./keyword");
        const subschema_1 = require("./subschema");
        const codegen_1 = require("../codegen");
        const names_1 = require("../names");
        const resolve_1 = require("../resolve");
        const util_1 = require("../util");
        const errors_1 = require("../errors");
        // schema compilation - generates validation function, subschemaCode (below) is used for subschemas
        function validateFunctionCode(it) {
          if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
              topSchemaObjCode(it);
              return;
            }
          }
          validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
        }
        exports.validateFunctionCode = validateFunctionCode;
        function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
          if (opts.code.es5) {
            gen.func(
              validateName,
              (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`,
              schemaEnv.$async,
              () => {
                gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
                destructureValCxtES5(gen, opts);
                gen.code(body);
              },
            );
          } else {
            gen.func(
              validateName,
              (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`,
              schemaEnv.$async,
              () => gen.code(funcSourceUrl(schema, opts)).code(body),
            );
          }
        }
        function destructureValCxt(opts) {
          return (0,
          codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
        }
        function destructureValCxtES5(gen, opts) {
          gen.if(
            names_1.default.valCxt,
            () => {
              gen.var(
                names_1.default.instancePath,
                (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`,
              );
              gen.var(
                names_1.default.parentData,
                (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`,
              );
              gen.var(
                names_1.default.parentDataProperty,
                (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`,
              );
              gen.var(
                names_1.default.rootData,
                (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`,
              );
              if (opts.dynamicRef)
                gen.var(
                  names_1.default.dynamicAnchors,
                  (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`,
                );
            },
            () => {
              gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
              gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
              gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
              gen.var(names_1.default.rootData, names_1.default.data);
              if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
            },
          );
        }
        function topSchemaObjCode(it) {
          const { schema, opts, gen } = it;
          validateFunction(it, () => {
            if (opts.$comment && schema.$comment) commentKeyword(it);
            checkNoDefault(it);
            gen.let(names_1.default.vErrors, null);
            gen.let(names_1.default.errors, 0);
            if (opts.unevaluated) resetEvaluated(it);
            typeAndKeywords(it);
            returnResults(it);
          });
          return;
        }
        function resetEvaluated(it) {
          // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
          const { gen, validateName } = it;
          it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
          gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () =>
            gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`),
          );
          gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () =>
            gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`),
          );
        }
        function funcSourceUrl(schema, opts) {
          const schId = typeof schema == "object" && schema[opts.schemaId];
          return schId && (opts.code.source || opts.code.process)
            ? (0, codegen_1._)`/*# sourceURL=${schId} */`
            : codegen_1.nil;
        }
        // schema compilation - this function is used recursively to generate code for sub-schemas
        function subschemaCode(it, valid) {
          if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
              subSchemaObjCode(it, valid);
              return;
            }
          }
          (0, boolSchema_1.boolOrEmptySchema)(it, valid);
        }
        function schemaCxtHasRules({ schema, self }) {
          if (typeof schema == "boolean") return !schema;
          for (const key in schema) if (self.RULES.all[key]) return true;
          return false;
        }
        function isSchemaObj(it) {
          return typeof it.schema != "boolean";
        }
        function subSchemaObjCode(it, valid) {
          const { schema, gen, opts } = it;
          if (opts.$comment && schema.$comment) commentKeyword(it);
          updateContext(it);
          checkAsyncSchema(it);
          const errsCount = gen.const("_errs", names_1.default.errors);
          typeAndKeywords(it, errsCount);
          // TODO var
          gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        }
        function checkKeywords(it) {
          (0, util_1.checkUnknownRules)(it);
          checkRefsAndKeywords(it);
        }
        function typeAndKeywords(it, errsCount) {
          if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
          const types = (0, dataType_1.getSchemaTypes)(it.schema);
          const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
          schemaKeywords(it, types, !checkedTypes, errsCount);
        }
        function checkRefsAndKeywords(it) {
          const { schema, errSchemaPath, opts, self } = it;
          if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
            self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
          }
        }
        function checkNoDefault(it) {
          const { schema, opts } = it;
          if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
            (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
          }
        }
        function updateContext(it) {
          const schId = it.schema[it.opts.schemaId];
          if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
        }
        function checkAsyncSchema(it) {
          if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
        }
        function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
          const msg = schema.$comment;
          if (opts.$comment === true) {
            gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
          } else if (typeof opts.$comment == "function") {
            const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
            const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
            gen.code(
              (0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`,
            );
          }
        }
        function returnResults(it) {
          const { gen, schemaEnv, validateName, ValidationError, opts } = it;
          if (schemaEnv.$async) {
            // TODO assign unevaluated
            gen.if(
              (0, codegen_1._)`${names_1.default.errors} === 0`,
              () => gen.return(names_1.default.data),
              () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`),
            );
          } else {
            gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
            if (opts.unevaluated) assignEvaluated(it);
            gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
          }
        }
        function assignEvaluated({ gen, evaluated, props, items }) {
          if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);
          if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);
        }
        function schemaKeywords(it, types, typeErrors, errsCount) {
          const { gen, schema, data, allErrors, opts, self } = it;
          const { RULES } = self;
          if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
            gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
            return;
          }
          if (!opts.jtd) checkStrictTypes(it, types);
          gen.block(() => {
            for (const group of RULES.rules) groupKeywords(group);
            groupKeywords(RULES.post);
          });
          function groupKeywords(group) {
            if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;
            if (group.type) {
              gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
              iterateKeywords(it, group);
              if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen.else();
                (0, dataType_2.reportTypeError)(it);
              }
              gen.endIf();
            } else {
              iterateKeywords(it, group);
            }
            // TODO make it "ok" call?
            if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
          }
        }
        function iterateKeywords(it, group) {
          const {
            gen,
            schema,
            opts: { useDefaults },
          } = it;
          if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
          gen.block(() => {
            for (const rule of group.rules) {
              if ((0, applicability_1.shouldUseRule)(schema, rule)) {
                keywordCode(it, rule.keyword, rule.definition, group.type);
              }
            }
          });
        }
        function checkStrictTypes(it, types) {
          if (it.schemaEnv.meta || !it.opts.strictTypes) return;
          checkContextTypes(it, types);
          if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
          checkKeywordTypes(it, it.dataTypes);
        }
        function checkContextTypes(it, types) {
          if (!types.length) return;
          if (!it.dataTypes.length) {
            it.dataTypes = types;
            return;
          }
          types.forEach((t) => {
            if (!includesType(it.dataTypes, t)) {
              strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
            }
          });
          it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));
        }
        function checkMultipleTypes(it, ts) {
          if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
            strictTypesError(it, "use allowUnionTypes to allow union type keyword");
          }
        }
        function checkKeywordTypes(it, ts) {
          const rules = it.self.RULES.all;
          for (const keyword in rules) {
            const rule = rules[keyword];
            if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
              const { type } = rule.definition;
              if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
              }
            }
          }
        }
        function hasApplicableType(schTs, kwdT) {
          return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
        }
        function includesType(ts, t) {
          return ts.includes(t) || (t === "integer" && ts.includes("number"));
        }
        function strictTypesError(it, msg) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          msg += ` at "${schemaPath}" (strictTypes)`;
          (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
        }
        class KeywordCxt {
          constructor(it, def, keyword) {
            (0, keyword_1.validateKeywordUsage)(it, def, keyword);
            this.gen = it.gen;
            this.allErrors = it.allErrors;
            this.keyword = keyword;
            this.data = it.data;
            this.schema = it.schema[keyword];
            this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
            this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
            this.schemaType = def.schemaType;
            this.parentSchema = it.schema;
            this.params = {};
            this.it = it;
            this.def = def;
            if (this.$data) {
              this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
            } else {
              this.schemaCode = this.schemaValue;
              if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
              }
            }
            if ("code" in def ? def.trackErrors : def.errors !== false) {
              this.errsCount = it.gen.const("_errs", names_1.default.errors);
            }
          }
          result(condition, successAction, failAction) {
            this.failResult((0, codegen_1.not)(condition), successAction, failAction);
          }
          failResult(condition, successAction, failAction) {
            this.gen.if(condition);
            if (failAction) failAction();
            else this.error();
            if (successAction) {
              this.gen.else();
              successAction();
              if (this.allErrors) this.gen.endIf();
            } else {
              if (this.allErrors) this.gen.endIf();
              else this.gen.else();
            }
          }
          pass(condition, failAction) {
            this.failResult((0, codegen_1.not)(condition), undefined, failAction);
          }
          fail(condition) {
            if (condition === undefined) {
              this.error();
              if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize
              return;
            }
            this.gen.if(condition);
            this.error();
            if (this.allErrors) this.gen.endIf();
            else this.gen.else();
          }
          fail$data(condition) {
            if (!this.$data) return this.fail(condition);
            const { schemaCode } = this;
            this.fail(
              (0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`,
            );
          }
          error(append, errorParams, errorPaths) {
            if (errorParams) {
              this.setParams(errorParams);
              this._error(append, errorPaths);
              this.setParams({});
              return;
            }
            this._error(append, errorPaths);
          }
          _error(append, errorPaths) {
            (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
          }
          $dataError() {
            (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
          }
          reset() {
            if (this.errsCount === undefined) throw new Error('add "trackErrors" to keyword definition');
            (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
          }
          ok(cond) {
            if (!this.allErrors) this.gen.if(cond);
          }
          setParams(obj, assign) {
            if (assign) Object.assign(this.params, obj);
            else this.params = obj;
          }
          block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
            this.gen.block(() => {
              this.check$data(valid, $dataValid);
              codeBlock();
            });
          }
          check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
            if (!this.$data) return;
            const { gen, schemaCode, schemaType, def } = this;
            gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
            if (valid !== codegen_1.nil) gen.assign(valid, true);
            if (schemaType.length || def.validateSchema) {
              gen.elseIf(this.invalid$data());
              this.$dataError();
              if (valid !== codegen_1.nil) gen.assign(valid, false);
            }
            gen.else();
          }
          invalid$data() {
            const { gen, schemaCode, schemaType, def, it } = this;
            return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
            function wrong$DataType() {
              if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen_1.Name)) throw new Error("ajv implementation error");
                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return (0,
                codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
              }
              return codegen_1.nil;
            }
            function invalid$DataSchema() {
              if (def.validateSchema) {
                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
              }
              return codegen_1.nil;
            }
          }
          subschema(appl, valid) {
            const subschema = (0, subschema_1.getSubschema)(this.it, appl);
            (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
            (0, subschema_1.extendSubschemaMode)(subschema, appl);
            const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
            subschemaCode(nextContext, valid);
            return nextContext;
          }
          mergeEvaluated(schemaCxt, toName) {
            const { it, gen } = this;
            if (!it.opts.unevaluated) return;
            if (it.props !== true && schemaCxt.props !== undefined) {
              it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
            }
            if (it.items !== true && schemaCxt.items !== undefined) {
              it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
            }
          }
          mergeValidEvaluated(schemaCxt, valid) {
            const { it, gen } = this;
            if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
              gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
              return true;
            }
          }
        }
        exports.KeywordCxt = KeywordCxt;
        function keywordCode(it, keyword, def, ruleType) {
          const cxt = new KeywordCxt(it, def, keyword);
          if ("code" in def) {
            def.code(cxt, ruleType);
          } else if (cxt.$data && def.validate) {
            (0, keyword_1.funcKeywordCode)(cxt, def);
          } else if ("macro" in def) {
            (0, keyword_1.macroKeywordCode)(cxt, def);
          } else if (def.compile || def.validate) {
            (0, keyword_1.funcKeywordCode)(cxt, def);
          }
        }
        const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
        const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
        function getData($data, { dataLevel, dataNames, dataPathArr }) {
          let jsonPointer;
          let data;
          if ($data === "") return names_1.default.rootData;
          if ($data[0] === "/") {
            if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
            jsonPointer = $data;
            data = names_1.default.rootData;
          } else {
            const matches = RELATIVE_JSON_POINTER.exec($data);
            if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
            const up = +matches[1];
            jsonPointer = matches[2];
            if (jsonPointer === "#") {
              if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
              return dataPathArr[dataLevel - up];
            }
            if (up > dataLevel) throw new Error(errorMsg("data", up));
            data = dataNames[dataLevel - up];
            if (!jsonPointer) return data;
          }
          let expr = data;
          const segments = jsonPointer.split("/");
          for (const segment of segments) {
            if (segment) {
              data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
              expr = (0, codegen_1._)`${expr} && ${data}`;
            }
          }
          return expr;
          function errorMsg(pointerType, up) {
            return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
          }
        }
        exports.getData = getData;
      },
      {
        "../codegen": 49,
        "../errors": 51,
        "../names": 53,
        "../resolve": 55,
        "../util": 57,
        "./applicability": 58,
        "./boolSchema": 59,
        "./dataType": 60,
        "./defaults": 61,
        "./keyword": 63,
        "./subschema": 64,
      },
    ],
    63: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.validateKeywordUsage =
          exports.validSchemaType =
          exports.funcKeywordCode =
          exports.macroKeywordCode =
            void 0;
        const codegen_1 = require("../codegen");
        const names_1 = require("../names");
        const code_1 = require("../../vocabularies/code");
        const errors_1 = require("../errors");
        function macroKeywordCode(cxt, def) {
          const { gen, keyword, schema, parentSchema, it } = cxt;
          const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
          const schemaRef = useKeyword(gen, keyword, macroSchema);
          if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
          const valid = gen.name("valid");
          cxt.subschema(
            {
              schema: macroSchema,
              schemaPath: codegen_1.nil,
              errSchemaPath: `${it.errSchemaPath}/${keyword}`,
              topSchemaRef: schemaRef,
              compositeRule: true,
            },
            valid,
          );
          cxt.pass(valid, () => cxt.error(true));
        }
        exports.macroKeywordCode = macroKeywordCode;
        function funcKeywordCode(cxt, def) {
          var _a;
          const { gen, keyword, schema, parentSchema, $data, it } = cxt;
          checkAsyncKeyword(it, def);
          const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
          const validateRef = useKeyword(gen, keyword, validate);
          const valid = gen.let("valid");
          cxt.block$data(valid, validateKeyword);
          cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
          function validateKeyword() {
            if (def.errors === false) {
              assignValid();
              if (def.modifying) modifyData(cxt);
              reportErrs(() => cxt.error());
            } else {
              const ruleErrs = def.async ? validateAsync() : validateSync();
              if (def.modifying) modifyData(cxt);
              reportErrs(() => addErrs(cxt, ruleErrs));
            }
          }
          function validateAsync() {
            const ruleErrs = gen.let("ruleErrs", null);
            gen.try(
              () => assignValid((0, codegen_1._)`await `),
              (e) =>
                gen.assign(valid, false).if(
                  (0, codegen_1._)`${e} instanceof ${it.ValidationError}`,
                  () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`),
                  () => gen.throw(e),
                ),
            );
            return ruleErrs;
          }
          function validateSync() {
            const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
            gen.assign(validateErrs, null);
            assignValid(codegen_1.nil);
            return validateErrs;
          }
          function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
            const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
            const passSchema = !(("compile" in def && !$data) || def.schema === false);
            gen.assign(
              valid,
              (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`,
              def.modifying,
            );
          }
          function reportErrs(errors) {
            var _a;
            gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
          }
        }
        exports.funcKeywordCode = funcKeywordCode;
        function modifyData(cxt) {
          const { gen, data, it } = cxt;
          gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
        }
        function addErrs(cxt, errs) {
          const { gen } = cxt;
          gen.if(
            (0, codegen_1._)`Array.isArray(${errs})`,
            () => {
              gen
                .assign(
                  names_1.default.vErrors,
                  (0,
                  codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`,
                )
                .assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
              (0, errors_1.extendErrors)(cxt);
            },
            () => cxt.error(),
          );
        }
        function checkAsyncKeyword({ schemaEnv }, def) {
          if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
        }
        function useKeyword(gen, keyword, result) {
          if (result === undefined) throw new Error(`keyword "${keyword}" failed to compile`);
          return gen.scopeValue(
            "keyword",
            typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) },
          );
        }
        function validSchemaType(schema, schemaType, allowUndefined = false) {
          // TODO add tests
          return (
            !schemaType.length ||
            schemaType.some((st) =>
              st === "array"
                ? Array.isArray(schema)
                : st === "object"
                  ? schema && typeof schema == "object" && !Array.isArray(schema)
                  : typeof schema == st || (allowUndefined && typeof schema == "undefined"),
            )
          );
        }
        exports.validSchemaType = validSchemaType;
        function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
          /* istanbul ignore if */
          if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
            throw new Error("ajv implementation error");
          }
          const deps = def.dependencies;
          if (
            deps === null || deps === void 0
              ? void 0
              : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))
          ) {
            throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
          }
          if (def.validateSchema) {
            const valid = def.validateSchema(schema[keyword]);
            if (!valid) {
              const msg =
                `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
                self.errorsText(def.validateSchema.errors);
              if (opts.validateSchema === "log") self.logger.error(msg);
              else throw new Error(msg);
            }
          }
        }
        exports.validateKeywordUsage = validateKeywordUsage;
      },
      { "../../vocabularies/code": 98, "../codegen": 49, "../errors": 51, "../names": 53 },
    ],
    64: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
        const codegen_1 = require("../codegen");
        const util_1 = require("../util");
        function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
          if (keyword !== undefined && schema !== undefined) {
            throw new Error('both "keyword" and "schema" passed, only one allowed');
          }
          if (keyword !== undefined) {
            const sch = it.schema[keyword];
            return schemaProp === undefined
              ? {
                  schema: sch,
                  schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
                  errSchemaPath: `${it.errSchemaPath}/${keyword}`,
                }
              : {
                  schema: sch[schemaProp],
                  schemaPath: (0,
                  codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
                  errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
                };
          }
          if (schema !== undefined) {
            if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
              throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
            }
            return {
              schema,
              schemaPath,
              topSchemaRef,
              errSchemaPath,
            };
          }
          throw new Error('either "keyword" or "schema" must be passed');
        }
        exports.getSubschema = getSubschema;
        function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
          if (data !== undefined && dataProp !== undefined) {
            throw new Error('both "data" and "dataProp" passed, only one allowed');
          }
          const { gen } = it;
          if (dataProp !== undefined) {
            const { errorPath, dataPathArr, opts } = it;
            const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
            dataContextProps(nextData);
            subschema.errorPath = (0,
            codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
            subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
            subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
          }
          if (data !== undefined) {
            const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
            dataContextProps(nextData);
            if (propertyName !== undefined) subschema.propertyName = propertyName;
            // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
          }
          if (dataTypes) subschema.dataTypes = dataTypes;
          function dataContextProps(_nextData) {
            subschema.data = _nextData;
            subschema.dataLevel = it.dataLevel + 1;
            subschema.dataTypes = [];
            it.definedProperties = new Set();
            subschema.parentData = it.data;
            subschema.dataNames = [...it.dataNames, _nextData];
          }
        }
        exports.extendSubschemaData = extendSubschemaData;
        function extendSubschemaMode(
          subschema,
          { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors },
        ) {
          if (compositeRule !== undefined) subschema.compositeRule = compositeRule;
          if (createErrors !== undefined) subschema.createErrors = createErrors;
          if (allErrors !== undefined) subschema.allErrors = allErrors;
          subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
          subschema.jtdMetadata = jtdMetadata; // not inherited
        }
        exports.extendSubschemaMode = extendSubschemaMode;
      },
      { "../codegen": 49, "../util": 57 },
    ],
    65: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.CodeGen =
          exports.Name =
          exports.nil =
          exports.stringify =
          exports.str =
          exports._ =
          exports.KeywordCxt =
            void 0;
        var validate_1 = require("./compile/validate");
        Object.defineProperty(exports, "KeywordCxt", {
          enumerable: true,
          get: function () {
            return validate_1.KeywordCxt;
          },
        });
        var codegen_1 = require("./compile/codegen");
        Object.defineProperty(exports, "_", {
          enumerable: true,
          get: function () {
            return codegen_1._;
          },
        });
        Object.defineProperty(exports, "str", {
          enumerable: true,
          get: function () {
            return codegen_1.str;
          },
        });
        Object.defineProperty(exports, "stringify", {
          enumerable: true,
          get: function () {
            return codegen_1.stringify;
          },
        });
        Object.defineProperty(exports, "nil", {
          enumerable: true,
          get: function () {
            return codegen_1.nil;
          },
        });
        Object.defineProperty(exports, "Name", {
          enumerable: true,
          get: function () {
            return codegen_1.Name;
          },
        });
        Object.defineProperty(exports, "CodeGen", {
          enumerable: true,
          get: function () {
            return codegen_1.CodeGen;
          },
        });
        const validation_error_1 = require("./runtime/validation_error");
        const ref_error_1 = require("./compile/ref_error");
        const rules_1 = require("./compile/rules");
        const compile_1 = require("./compile");
        const codegen_2 = require("./compile/codegen");
        const resolve_1 = require("./compile/resolve");
        const dataType_1 = require("./compile/validate/dataType");
        const util_1 = require("./compile/util");
        const $dataRefSchema = require("./refs/data.json");
        const uri_1 = require("./runtime/uri");
        const defaultRegExp = (str, flags) => new RegExp(str, flags);
        defaultRegExp.code = "new RegExp";
        const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
        const EXT_SCOPE_NAMES = new Set([
          "validate",
          "serialize",
          "parse",
          "wrapper",
          "root",
          "schema",
          "keyword",
          "pattern",
          "formats",
          "validate$data",
          "func",
          "obj",
          "Error",
        ]);
        const removedOptions = {
          errorDataPath: "",
          format: "`validateFormats: false` can be used instead.",
          nullable: '"nullable" keyword is supported by default.',
          jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
          extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
          missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
          processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
          sourceCode: "Use option `code: {source: true}`",
          strictDefaults: "It is default now, see option `strict`.",
          strictKeywords: "It is default now, see option `strict`.",
          uniqueItems: '"uniqueItems" keyword is always validated.',
          unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
          cache: "Map is used as cache, schema object as key.",
          serialize: "Map is used as cache, schema object as key.",
          ajvErrors: "It is default now.",
        };
        const deprecatedOptions = {
          ignoreKeywordsWithRef: "",
          jsPropertySyntax: "",
          unicode: '"minLength"/"maxLength" account for unicode characters by default.',
        };
        const MAX_EXPRESSION = 200;
        // eslint-disable-next-line complexity
        function requiredOptions(o) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
          const s = o.strict;
          const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
          const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
          const regExp =
            (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0
              ? _c
              : defaultRegExp;
          const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
          return {
            strictSchema:
              (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
            strictNumbers:
              (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
            strictTypes:
              (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
            strictTuples:
              (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
            strictRequired:
              (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
            code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
            loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
            loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
            meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
            messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
            inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
            schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
            addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
            validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
            validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
            unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
            int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
            uriResolver: uriResolver,
          };
        }
        class Ajv {
          constructor(opts = {}) {
            this.schemas = {};
            this.refs = {};
            this.formats = {};
            this._compilations = new Set();
            this._loading = {};
            this._cache = new Map();
            opts = this.opts = { ...opts, ...requiredOptions(opts) };
            const { es5, lines } = this.opts.code;
            this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
            this.logger = getLogger(opts.logger);
            const formatOpt = opts.validateFormats;
            opts.validateFormats = false;
            this.RULES = (0, rules_1.getRules)();
            checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
            checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
            this._metaOpts = getMetaSchemaOptions.call(this);
            if (opts.formats) addInitialFormats.call(this);
            this._addVocabularies();
            this._addDefaultMetaSchema();
            if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
            if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
            addInitialSchemas.call(this);
            opts.validateFormats = formatOpt;
          }
          _addVocabularies() {
            this.addKeyword("$async");
          }
          _addDefaultMetaSchema() {
            const { $data, meta, schemaId } = this.opts;
            let _dataRefSchema = $dataRefSchema;
            if (schemaId === "id") {
              _dataRefSchema = { ...$dataRefSchema };
              _dataRefSchema.id = _dataRefSchema.$id;
              delete _dataRefSchema.$id;
            }
            if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
          }
          defaultMeta() {
            const { meta, schemaId } = this.opts;
            return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
          }
          validate(
            schemaKeyRef, // key, ref or schema object
            data, // to be validated
          ) {
            let v;
            if (typeof schemaKeyRef == "string") {
              v = this.getSchema(schemaKeyRef);
              if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
            } else {
              v = this.compile(schemaKeyRef);
            }
            const valid = v(data);
            if (!("$async" in v)) this.errors = v.errors;
            return valid;
          }
          compile(schema, _meta) {
            const sch = this._addSchema(schema, _meta);
            return sch.validate || this._compileSchemaEnv(sch);
          }
          compileAsync(schema, meta) {
            if (typeof this.opts.loadSchema != "function") {
              throw new Error("options.loadSchema should be a function");
            }
            const { loadSchema } = this.opts;
            return runCompileAsync.call(this, schema, meta);
            async function runCompileAsync(_schema, _meta) {
              await loadMetaSchema.call(this, _schema.$schema);
              const sch = this._addSchema(_schema, _meta);
              return sch.validate || _compileAsync.call(this, sch);
            }
            async function loadMetaSchema($ref) {
              if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
              }
            }
            async function _compileAsync(sch) {
              try {
                return this._compileSchemaEnv(sch);
              } catch (e) {
                if (!(e instanceof ref_error_1.default)) throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
              }
            }
            function checkLoaded({ missingSchema: ref, missingRef }) {
              if (this.refs[ref]) {
                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
              }
            }
            async function loadMissingSchema(ref) {
              const _schema = await _loadSchema.call(this, ref);
              if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
              if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
            }
            async function _loadSchema(ref) {
              const p = this._loading[ref];
              if (p) return p;
              try {
                return await (this._loading[ref] = loadSchema(ref));
              } finally {
                delete this._loading[ref];
              }
            }
          }
          // Adds schema to the instance
          addSchema(
            schema, // If array is passed, `key` will be ignored
            key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
            _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
            _validateSchema = this.opts.validateSchema, // false to skip schema validation. Used internally, option validateSchema should be used instead.
          ) {
            if (Array.isArray(schema)) {
              for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);
              return this;
            }
            let id;
            if (typeof schema === "object") {
              const { schemaId } = this.opts;
              id = schema[schemaId];
              if (id !== undefined && typeof id != "string") {
                throw new Error(`schema ${schemaId} must be string`);
              }
            }
            key = (0, resolve_1.normalizeId)(key || id);
            this._checkUnique(key);
            this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
            return this;
          }
          // Add schema that will be used to validate other schemas
          // options in META_IGNORE_OPTIONS are alway set to false
          addMetaSchema(
            schema,
            key, // schema key
            _validateSchema = this.opts.validateSchema, // false to skip schema validation, can be used to override validateSchema option for meta-schema
          ) {
            this.addSchema(schema, key, true, _validateSchema);
            return this;
          }
          //  Validate schema against its meta-schema
          validateSchema(schema, throwOrLogError) {
            if (typeof schema == "boolean") return true;
            let $schema;
            $schema = schema.$schema;
            if ($schema !== undefined && typeof $schema != "string") {
              throw new Error("$schema must be a string");
            }
            $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
            if (!$schema) {
              this.logger.warn("meta-schema not available");
              this.errors = null;
              return true;
            }
            const valid = this.validate($schema, schema);
            if (!valid && throwOrLogError) {
              const message = "schema is invalid: " + this.errorsText();
              if (this.opts.validateSchema === "log") this.logger.error(message);
              else throw new Error(message);
            }
            return valid;
          }
          // Get compiled schema by `key` or `ref`.
          // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
          getSchema(keyRef) {
            let sch;
            while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
            if (sch === undefined) {
              const { schemaId } = this.opts;
              const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
              sch = compile_1.resolveSchema.call(this, root, keyRef);
              if (!sch) return;
              this.refs[keyRef] = sch;
            }
            return sch.validate || this._compileSchemaEnv(sch);
          }
          // Remove cached schema(s).
          // If no parameter is passed all schemas but meta-schemas are removed.
          // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
          // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
          removeSchema(schemaKeyRef) {
            if (schemaKeyRef instanceof RegExp) {
              this._removeAllSchemas(this.schemas, schemaKeyRef);
              this._removeAllSchemas(this.refs, schemaKeyRef);
              return this;
            }
            switch (typeof schemaKeyRef) {
              case "undefined":
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
              case "string": {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == "object") this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
              }
              case "object": {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id = schemaKeyRef[this.opts.schemaId];
                if (id) {
                  id = (0, resolve_1.normalizeId)(id);
                  delete this.schemas[id];
                  delete this.refs[id];
                }
                return this;
              }
              default:
                throw new Error("ajv.removeSchema: invalid parameter");
            }
          }
          // add "vocabulary" - a collection of keywords
          addVocabulary(definitions) {
            for (const def of definitions) this.addKeyword(def);
            return this;
          }
          addKeyword(
            kwdOrDef,
            def, // deprecated
          ) {
            let keyword;
            if (typeof kwdOrDef == "string") {
              keyword = kwdOrDef;
              if (typeof def == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def.keyword = keyword;
              }
            } else if (typeof kwdOrDef == "object" && def === undefined) {
              def = kwdOrDef;
              keyword = def.keyword;
              if (Array.isArray(keyword) && !keyword.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
              }
            } else {
              throw new Error("invalid addKeywords parameters");
            }
            checkKeyword.call(this, keyword, def);
            if (!def) {
              (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
              return this;
            }
            keywordMetaschema.call(this, def);
            const definition = {
              ...def,
              type: (0, dataType_1.getJSONTypes)(def.type),
              schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
            };
            (0, util_1.eachItem)(
              keyword,
              definition.type.length === 0
                ? (k) => addRule.call(this, k, definition)
                : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)),
            );
            return this;
          }
          getKeyword(keyword) {
            const rule = this.RULES.all[keyword];
            return typeof rule == "object" ? rule.definition : !!rule;
          }
          // Remove keyword
          removeKeyword(keyword) {
            // TODO return type should be Ajv
            const { RULES } = this;
            delete RULES.keywords[keyword];
            delete RULES.all[keyword];
            for (const group of RULES.rules) {
              const i = group.rules.findIndex((rule) => rule.keyword === keyword);
              if (i >= 0) group.rules.splice(i, 1);
            }
            return this;
          }
          // Add format
          addFormat(name, format) {
            if (typeof format == "string") format = new RegExp(format);
            this.formats[name] = format;
            return this;
          }
          errorsText(
            errors = this.errors, // optional array of validation errors
            { separator = ", ", dataVar = "data" } = {}, // optional options with properties `separator` and `dataVar`
          ) {
            if (!errors || errors.length === 0) return "No errors";
            return errors
              .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
              .reduce((text, msg) => text + separator + msg);
          }
          $dataMetaSchema(metaSchema, keywordsJsonPointers) {
            const rules = this.RULES.all;
            metaSchema = JSON.parse(JSON.stringify(metaSchema));
            for (const jsonPointer of keywordsJsonPointers) {
              const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
              let keywords = metaSchema;
              for (const seg of segments) keywords = keywords[seg];
              for (const key in rules) {
                const rule = rules[key];
                if (typeof rule != "object") continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema) keywords[key] = schemaOrData(schema);
              }
            }
            return metaSchema;
          }
          _removeAllSchemas(schemas, regex) {
            for (const keyRef in schemas) {
              const sch = schemas[keyRef];
              if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                  delete schemas[keyRef];
                } else if (sch && !sch.meta) {
                  this._cache.delete(sch.schema);
                  delete schemas[keyRef];
                }
              }
            }
          }
          _addSchema(
            schema,
            meta,
            baseId,
            validateSchema = this.opts.validateSchema,
            addSchema = this.opts.addUsedSchema,
          ) {
            let id;
            const { schemaId } = this.opts;
            if (typeof schema == "object") {
              id = schema[schemaId];
            } else {
              if (this.opts.jtd) throw new Error("schema must be object");
              else if (typeof schema != "boolean") throw new Error("schema must be object or boolean");
            }
            let sch = this._cache.get(schema);
            if (sch !== undefined) return sch;
            baseId = (0, resolve_1.normalizeId)(id || baseId);
            const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
            sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
            this._cache.set(sch.schema, sch);
            if (addSchema && !baseId.startsWith("#")) {
              // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
              if (baseId) this._checkUnique(baseId);
              this.refs[baseId] = sch;
            }
            if (validateSchema) this.validateSchema(schema, true);
            return sch;
          }
          _checkUnique(id) {
            if (this.schemas[id] || this.refs[id]) {
              throw new Error(`schema with key or id "${id}" already exists`);
            }
          }
          _compileSchemaEnv(sch) {
            if (sch.meta) this._compileMetaSchema(sch);
            else compile_1.compileSchema.call(this, sch);
            /* istanbul ignore if */
            if (!sch.validate) throw new Error("ajv implementation error");
            return sch.validate;
          }
          _compileMetaSchema(sch) {
            const currentOpts = this.opts;
            this.opts = this._metaOpts;
            try {
              compile_1.compileSchema.call(this, sch);
            } finally {
              this.opts = currentOpts;
            }
          }
        }
        exports.default = Ajv;
        Ajv.ValidationError = validation_error_1.default;
        Ajv.MissingRefError = ref_error_1.default;
        function checkOptions(checkOpts, options, msg, log = "error") {
          for (const key in checkOpts) {
            const opt = key;
            if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
          }
        }
        function getSchEnv(keyRef) {
          keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
          return this.schemas[keyRef] || this.refs[keyRef];
        }
        function addInitialSchemas() {
          const optsSchemas = this.opts.schemas;
          if (!optsSchemas) return;
          if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
          else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
        }
        function addInitialFormats() {
          for (const name in this.opts.formats) {
            const format = this.opts.formats[name];
            if (format) this.addFormat(name, format);
          }
        }
        function addInitialKeywords(defs) {
          if (Array.isArray(defs)) {
            this.addVocabulary(defs);
            return;
          }
          this.logger.warn("keywords option as map is deprecated, pass array");
          for (const keyword in defs) {
            const def = defs[keyword];
            if (!def.keyword) def.keyword = keyword;
            this.addKeyword(def);
          }
        }
        function getMetaSchemaOptions() {
          const metaOpts = { ...this.opts };
          for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
          return metaOpts;
        }
        const noLogs = { log() {}, warn() {}, error() {} };
        function getLogger(logger) {
          if (logger === false) return noLogs;
          if (logger === undefined) return console;
          if (logger.log && logger.warn && logger.error) return logger;
          throw new Error("logger must implement log, warn and error methods");
        }
        const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
        function checkKeyword(keyword, def) {
          const { RULES } = this;
          (0, util_1.eachItem)(keyword, (kwd) => {
            if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
            if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
          });
          if (!def) return;
          if (def.$data && !("code" in def || "validate" in def)) {
            throw new Error('$data keyword must have "code" or "validate" function');
          }
        }
        function addRule(keyword, definition, dataType) {
          var _a;
          const post = definition === null || definition === void 0 ? void 0 : definition.post;
          if (dataType && post) throw new Error('keyword with "post" flag cannot have "type"');
          const { RULES } = this;
          let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
          if (!ruleGroup) {
            ruleGroup = { type: dataType, rules: [] };
            RULES.rules.push(ruleGroup);
          }
          RULES.keywords[keyword] = true;
          if (!definition) return;
          const rule = {
            keyword,
            definition: {
              ...definition,
              type: (0, dataType_1.getJSONTypes)(definition.type),
              schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
            },
          };
          if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
          else ruleGroup.rules.push(rule);
          RULES.all[keyword] = rule;
          (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
        }
        function addBeforeRule(ruleGroup, rule, before) {
          const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
          if (i >= 0) {
            ruleGroup.rules.splice(i, 0, rule);
          } else {
            ruleGroup.rules.push(rule);
            this.logger.warn(`rule ${before} is not defined`);
          }
        }
        function keywordMetaschema(def) {
          let { metaSchema } = def;
          if (metaSchema === undefined) return;
          if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
          def.validateSchema = this.compile(metaSchema, true);
        }
        const $dataRef = {
          $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        };
        function schemaOrData(schema) {
          return { anyOf: [schema, $dataRef] };
        }
      },
      {
        "./compile": 52,
        "./compile/codegen": 49,
        "./compile/ref_error": 54,
        "./compile/resolve": 55,
        "./compile/rules": 56,
        "./compile/util": 57,
        "./compile/validate": 62,
        "./compile/validate/dataType": 60,
        "./refs/data.json": 66,
        "./runtime/uri": 78,
        "./runtime/validation_error": 79,
      },
    ],
    66: [
      function (require, module, exports) {
        module.exports = {
          $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
          description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
          type: "object",
          required: ["$data"],
          properties: {
            $data: {
              type: "string",
              anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }],
            },
          },
          additionalProperties: false,
        };
      },
      {},
    ],
    67: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const metaSchema = require("./schema.json");
        const applicator = require("./meta/applicator.json");
        const unevaluated = require("./meta/unevaluated.json");
        const content = require("./meta/content.json");
        const core = require("./meta/core.json");
        const format = require("./meta/format-annotation.json");
        const metadata = require("./meta/meta-data.json");
        const validation = require("./meta/validation.json");
        const META_SUPPORT_DATA = ["/properties"];
        function addMetaSchema2020($data) {
          [
            metaSchema,
            applicator,
            unevaluated,
            content,
            core,
            with$data(this, format),
            metadata,
            with$data(this, validation),
          ].forEach((sch) => this.addMetaSchema(sch, undefined, false));
          return this;
          function with$data(ajv, sch) {
            return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
          }
        }
        exports.default = addMetaSchema2020;
      },
      {
        "./meta/applicator.json": 68,
        "./meta/content.json": 69,
        "./meta/core.json": 70,
        "./meta/format-annotation.json": 71,
        "./meta/meta-data.json": 72,
        "./meta/unevaluated.json": 73,
        "./meta/validation.json": 74,
        "./schema.json": 75,
      },
    ],
    68: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/meta/applicator",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/applicator": true,
          },
          $dynamicAnchor: "meta",

          title: "Applicator vocabulary meta-schema",
          type: ["object", "boolean"],
          properties: {
            prefixItems: { $ref: "#/$defs/schemaArray" },
            items: { $dynamicRef: "#meta" },
            contains: { $dynamicRef: "#meta" },
            additionalProperties: { $dynamicRef: "#meta" },
            properties: {
              type: "object",
              additionalProperties: { $dynamicRef: "#meta" },
              default: {},
            },
            patternProperties: {
              type: "object",
              additionalProperties: { $dynamicRef: "#meta" },
              propertyNames: { format: "regex" },
              default: {},
            },
            dependentSchemas: {
              type: "object",
              additionalProperties: { $dynamicRef: "#meta" },
              default: {},
            },
            propertyNames: { $dynamicRef: "#meta" },
            if: { $dynamicRef: "#meta" },
            then: { $dynamicRef: "#meta" },
            else: { $dynamicRef: "#meta" },
            allOf: { $ref: "#/$defs/schemaArray" },
            anyOf: { $ref: "#/$defs/schemaArray" },
            oneOf: { $ref: "#/$defs/schemaArray" },
            not: { $dynamicRef: "#meta" },
          },
          $defs: {
            schemaArray: {
              type: "array",
              minItems: 1,
              items: { $dynamicRef: "#meta" },
            },
          },
        };
      },
      {},
    ],
    69: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/meta/content",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/content": true,
          },
          $dynamicAnchor: "meta",

          title: "Content vocabulary meta-schema",

          type: ["object", "boolean"],
          properties: {
            contentEncoding: { type: "string" },
            contentMediaType: { type: "string" },
            contentSchema: { $dynamicRef: "#meta" },
          },
        };
      },
      {},
    ],
    70: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/meta/core",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/core": true,
          },
          $dynamicAnchor: "meta",

          title: "Core vocabulary meta-schema",
          type: ["object", "boolean"],
          properties: {
            $id: {
              $ref: "#/$defs/uriReferenceString",
              $comment: "Non-empty fragments not allowed.",
              pattern: "^[^#]*#?$",
            },
            $schema: { $ref: "#/$defs/uriString" },
            $ref: { $ref: "#/$defs/uriReferenceString" },
            $anchor: { $ref: "#/$defs/anchorString" },
            $dynamicRef: { $ref: "#/$defs/uriReferenceString" },
            $dynamicAnchor: { $ref: "#/$defs/anchorString" },
            $vocabulary: {
              type: "object",
              propertyNames: { $ref: "#/$defs/uriString" },
              additionalProperties: {
                type: "boolean",
              },
            },
            $comment: {
              type: "string",
            },
            $defs: {
              type: "object",
              additionalProperties: { $dynamicRef: "#meta" },
            },
          },
          $defs: {
            anchorString: {
              type: "string",
              pattern: "^[A-Za-z_][-A-Za-z0-9._]*$",
            },
            uriString: {
              type: "string",
              format: "uri",
            },
            uriReferenceString: {
              type: "string",
              format: "uri-reference",
            },
          },
        };
      },
      {},
    ],
    71: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,
          },
          $dynamicAnchor: "meta",

          title: "Format vocabulary meta-schema for annotation results",
          type: ["object", "boolean"],
          properties: {
            format: { type: "string" },
          },
        };
      },
      {},
    ],
    72: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/meta-data": true,
          },
          $dynamicAnchor: "meta",

          title: "Meta-data vocabulary meta-schema",

          type: ["object", "boolean"],
          properties: {
            title: {
              type: "string",
            },
            description: {
              type: "string",
            },
            default: true,
            deprecated: {
              type: "boolean",
              default: false,
            },
            readOnly: {
              type: "boolean",
              default: false,
            },
            writeOnly: {
              type: "boolean",
              default: false,
            },
            examples: {
              type: "array",
              items: true,
            },
          },
        };
      },
      {},
    ],
    73: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,
          },
          $dynamicAnchor: "meta",

          title: "Unevaluated applicator vocabulary meta-schema",
          type: ["object", "boolean"],
          properties: {
            unevaluatedItems: { $dynamicRef: "#meta" },
            unevaluatedProperties: { $dynamicRef: "#meta" },
          },
        };
      },
      {},
    ],
    74: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/meta/validation",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/validation": true,
          },
          $dynamicAnchor: "meta",

          title: "Validation vocabulary meta-schema",
          type: ["object", "boolean"],
          properties: {
            type: {
              anyOf: [
                { $ref: "#/$defs/simpleTypes" },
                {
                  type: "array",
                  items: { $ref: "#/$defs/simpleTypes" },
                  minItems: 1,
                  uniqueItems: true,
                },
              ],
            },
            const: true,
            enum: {
              type: "array",
              items: true,
            },
            multipleOf: {
              type: "number",
              exclusiveMinimum: 0,
            },
            maximum: {
              type: "number",
            },
            exclusiveMaximum: {
              type: "number",
            },
            minimum: {
              type: "number",
            },
            exclusiveMinimum: {
              type: "number",
            },
            maxLength: { $ref: "#/$defs/nonNegativeInteger" },
            minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
            pattern: {
              type: "string",
              format: "regex",
            },
            maxItems: { $ref: "#/$defs/nonNegativeInteger" },
            minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
            uniqueItems: {
              type: "boolean",
              default: false,
            },
            maxContains: { $ref: "#/$defs/nonNegativeInteger" },
            minContains: {
              $ref: "#/$defs/nonNegativeInteger",
              default: 1,
            },
            maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
            minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
            required: { $ref: "#/$defs/stringArray" },
            dependentRequired: {
              type: "object",
              additionalProperties: {
                $ref: "#/$defs/stringArray",
              },
            },
          },
          $defs: {
            nonNegativeInteger: {
              type: "integer",
              minimum: 0,
            },
            nonNegativeIntegerDefault0: {
              $ref: "#/$defs/nonNegativeInteger",
              default: 0,
            },
            simpleTypes: {
              enum: ["array", "boolean", "integer", "null", "number", "object", "string"],
            },
            stringArray: {
              type: "array",
              items: { type: "string" },
              uniqueItems: true,
              default: [],
            },
          },
        };
      },
      {},
    ],
    75: [
      function (require, module, exports) {
        module.exports = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          $id: "https://json-schema.org/draft/2020-12/schema",
          $vocabulary: {
            "https://json-schema.org/draft/2020-12/vocab/core": true,
            "https://json-schema.org/draft/2020-12/vocab/applicator": true,
            "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,
            "https://json-schema.org/draft/2020-12/vocab/validation": true,
            "https://json-schema.org/draft/2020-12/vocab/meta-data": true,
            "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,
            "https://json-schema.org/draft/2020-12/vocab/content": true,
          },
          $dynamicAnchor: "meta",

          title: "Core and Validation specifications meta-schema",
          allOf: [
            { $ref: "meta/core" },
            { $ref: "meta/applicator" },
            { $ref: "meta/unevaluated" },
            { $ref: "meta/validation" },
            { $ref: "meta/meta-data" },
            { $ref: "meta/format-annotation" },
            { $ref: "meta/content" },
          ],
          type: ["object", "boolean"],
          $comment:
            "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.",
          properties: {
            definitions: {
              $comment: '"definitions" has been replaced by "$defs".',
              type: "object",
              additionalProperties: { $dynamicRef: "#meta" },
              deprecated: true,
              default: {},
            },
            dependencies: {
              $comment:
                '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
              type: "object",
              additionalProperties: {
                anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }],
              },
              deprecated: true,
              default: {},
            },
            $recursiveAnchor: {
              $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
              $ref: "meta/core#/$defs/anchorString",
              deprecated: true,
            },
            $recursiveRef: {
              $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
              $ref: "meta/core#/$defs/uriReferenceString",
              deprecated: true,
            },
          },
        };
      },
      {},
    ],
    76: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        // https://github.com/ajv-validator/ajv/issues/889
        const equal = require("fast-deep-equal");
        equal.code = 'require("ajv/dist/runtime/equal").default';
        exports.default = equal;
      },
      { "fast-deep-equal": 136 },
    ],
    77: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        // https://mathiasbynens.be/notes/javascript-encoding
        // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
        function ucs2length(str) {
          const len = str.length;
          let length = 0;
          let pos = 0;
          let value;
          while (pos < len) {
            length++;
            value = str.charCodeAt(pos++);
            if (value >= 0xd800 && value <= 0xdbff && pos < len) {
              // high surrogate, and there is a next character
              value = str.charCodeAt(pos);
              if ((value & 0xfc00) === 0xdc00) pos++; // low surrogate
            }
          }
          return length;
        }
        exports.default = ucs2length;
        ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
      },
      {},
    ],
    78: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const uri = require("uri-js");
        uri.code = 'require("ajv/dist/runtime/uri").default';
        exports.default = uri;
      },
      { "uri-js": 198 },
    ],
    79: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        class ValidationError extends Error {
          constructor(errors) {
            super("validation failed");
            this.errors = errors;
            this.ajv = this.validation = true;
          }
        }
        exports.default = ValidationError;
      },
      {},
    ],
    80: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.validateAdditionalItems = void 0;
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const error = {
          message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
          params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`,
        };
        const def = {
          keyword: "additionalItems",
          type: "array",
          schemaType: ["boolean", "object"],
          before: "uniqueItems",
          error,
          code(cxt) {
            const { parentSchema, it } = cxt;
            const { items } = parentSchema;
            if (!Array.isArray(items)) {
              (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
              return;
            }
            validateAdditionalItems(cxt, items);
          },
        };
        function validateAdditionalItems(cxt, items) {
          const { gen, schema, data, keyword, it } = cxt;
          it.items = true;
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          if (schema === false) {
            cxt.setParams({ len: items.length });
            cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
          } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`); // TODO var
            gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
            cxt.ok(valid);
          }
          function validateItems(valid) {
            gen.forRange("i", items.length, len, (i) => {
              cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
              if (!it.allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
            });
          }
        }
        exports.validateAdditionalItems = validateAdditionalItems;
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57 },
    ],
    81: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const code_1 = require("../code");
        const codegen_1 = require("../../compile/codegen");
        const names_1 = require("../../compile/names");
        const util_1 = require("../../compile/util");
        const error = {
          message: "must NOT have additional properties",
          params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`,
        };
        const def = {
          keyword: "additionalProperties",
          type: ["object"],
          schemaType: ["boolean", "object"],
          allowUndefined: true,
          trackErrors: true,
          error,
          code(cxt) {
            const { gen, schema, parentSchema, data, errsCount, it } = cxt;
            /* istanbul ignore if */
            if (!errsCount) throw new Error("ajv implementation error");
            const { allErrors, opts } = it;
            it.props = true;
            if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema)) return;
            const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
            const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
            checkAdditionalProperties();
            cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
            function checkAdditionalProperties() {
              gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length) additionalPropertyCode(key);
                else gen.if(isAdditional(key), () => additionalPropertyCode(key));
              });
            }
            function isAdditional(key) {
              let definedProp;
              if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
              } else if (props.length) {
                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
              } else {
                definedProp = codegen_1.nil;
              }
              if (patProps.length) {
                definedProp = (0, codegen_1.or)(
                  definedProp,
                  ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`),
                );
              }
              return (0, codegen_1.not)(definedProp);
            }
            function deleteAdditional(key) {
              gen.code((0, codegen_1._)`delete ${data}[${key}]`);
            }
            function additionalPropertyCode(key) {
              if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
              }
              if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors) gen.break();
                return;
              }
              if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                  applyAdditionalSchema(key, valid, false);
                  gen.if((0, codegen_1.not)(valid), () => {
                    cxt.reset();
                    deleteAdditional(key);
                  });
                } else {
                  applyAdditionalSchema(key, valid);
                  if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
              }
            }
            function applyAdditionalSchema(key, valid, errors) {
              const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1.Type.Str,
              };
              if (errors === false) {
                Object.assign(subschema, {
                  compositeRule: true,
                  createErrors: false,
                  allErrors: false,
                });
              }
              cxt.subschema(subschema, valid);
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/names": 53, "../../compile/util": 57, "../code": 98 },
    ],
    82: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const util_1 = require("../../compile/util");
        const def = {
          keyword: "allOf",
          schemaType: "array",
          code(cxt) {
            const { gen, schema, it } = cxt;
            /* istanbul ignore if */
            if (!Array.isArray(schema)) throw new Error("ajv implementation error");
            const valid = gen.name("valid");
            schema.forEach((sch, i) => {
              if ((0, util_1.alwaysValidSchema)(it, sch)) return;
              const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
              cxt.ok(valid);
              cxt.mergeEvaluated(schCxt);
            });
          },
        };
        exports.default = def;
      },
      { "../../compile/util": 57 },
    ],
    83: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const code_1 = require("../code");
        const def = {
          keyword: "anyOf",
          schemaType: "array",
          trackErrors: true,
          code: code_1.validateUnion,
          error: { message: "must match a schema in anyOf" },
        };
        exports.default = def;
      },
      { "../code": 98 },
    ],
    84: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const error = {
          message: ({ params: { min, max } }) =>
            max === undefined
              ? (0, codegen_1.str)`must contain at least ${min} valid item(s)`
              : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
          params: ({ params: { min, max } }) =>
            max === undefined
              ? (0, codegen_1._)`{minContains: ${min}}`
              : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`,
        };
        const def = {
          keyword: "contains",
          type: "array",
          schemaType: ["object", "boolean"],
          before: "uniqueItems",
          trackErrors: true,
          error,
          code(cxt) {
            const { gen, schema, parentSchema, data, it } = cxt;
            let min;
            let max;
            const { minContains, maxContains } = parentSchema;
            if (it.opts.next) {
              min = minContains === undefined ? 1 : minContains;
              max = maxContains;
            } else {
              min = 1;
            }
            const len = gen.const("len", (0, codegen_1._)`${data}.length`);
            cxt.setParams({ min, max });
            if (max === undefined && min === 0) {
              (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
              return;
            }
            if (max !== undefined && min > max) {
              (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
              cxt.fail();
              return;
            }
            if ((0, util_1.alwaysValidSchema)(it, schema)) {
              let cond = (0, codegen_1._)`${len} >= ${min}`;
              if (max !== undefined) cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
              cxt.pass(cond);
              return;
            }
            it.items = true;
            const valid = gen.name("valid");
            if (max === undefined && min === 1) {
              validateItems(valid, () => gen.if(valid, () => gen.break()));
            } else if (min === 0) {
              gen.let(valid, true);
              if (max !== undefined) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
            } else {
              gen.let(valid, false);
              validateItemsWithCount();
            }
            cxt.result(valid, () => cxt.reset());
            function validateItemsWithCount() {
              const schValid = gen.name("_valid");
              const count = gen.let("count", 0);
              validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
            }
            function validateItems(_valid, block) {
              gen.forRange("i", 0, len, (i) => {
                cxt.subschema(
                  {
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: util_1.Type.Num,
                    compositeRule: true,
                  },
                  _valid,
                );
                block();
              });
            }
            function checkLimits(count) {
              gen.code((0, codegen_1._)`${count}++`);
              if (max === undefined) {
                gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
              } else {
                gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1) gen.assign(valid, true);
                else gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
              }
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57 },
    ],
    85: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const code_1 = require("../code");
        exports.error = {
          message: ({ params: { property, depsCount, deps } }) => {
            const property_ies = depsCount === 1 ? "property" : "properties";
            return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
          },
          params: ({ params: { property, depsCount, deps, missingProperty } }) => (0,
          codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
        };
        const def = {
          keyword: "dependencies",
          type: "object",
          schemaType: "object",
          error: exports.error,
          code(cxt) {
            const [propDeps, schDeps] = splitDependencies(cxt);
            validatePropertyDeps(cxt, propDeps);
            validateSchemaDeps(cxt, schDeps);
          },
        };
        function splitDependencies({ schema }) {
          const propertyDeps = {};
          const schemaDeps = {};
          for (const key in schema) {
            if (key === "__proto__") continue;
            const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
            deps[key] = schema[key];
          }
          return [propertyDeps, schemaDeps];
        }
        function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
          const { gen, data, it } = cxt;
          if (Object.keys(propertyDeps).length === 0) return;
          const missing = gen.let("missing");
          for (const prop in propertyDeps) {
            const deps = propertyDeps[prop];
            if (deps.length === 0) continue;
            const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
            cxt.setParams({
              property: prop,
              depsCount: deps.length,
              deps: deps.join(", "),
            });
            if (it.allErrors) {
              gen.if(hasProperty, () => {
                for (const depProp of deps) {
                  (0, code_1.checkReportMissingProp)(cxt, depProp);
                }
              });
            } else {
              gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
              (0, code_1.reportMissingProp)(cxt, missing);
              gen.else();
            }
          }
        }
        exports.validatePropertyDeps = validatePropertyDeps;
        function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
          const { gen, data, keyword, it } = cxt;
          const valid = gen.name("valid");
          for (const prop in schemaDeps) {
            if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;
            gen.if(
              (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
              () => {
                const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
                cxt.mergeValidEvaluated(schCxt, valid);
              },
              () => gen.var(valid, true), // TODO var
            );
            cxt.ok(valid);
          }
        }
        exports.validateSchemaDeps = validateSchemaDeps;
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../code": 98 },
    ],
    86: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const dependencies_1 = require("./dependencies");
        const def = {
          keyword: "dependentSchemas",
          type: "object",
          schemaType: "object",
          code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt),
        };
        exports.default = def;
      },
      { "./dependencies": 85 },
    ],
    87: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const error = {
          message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
          params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`,
        };
        const def = {
          keyword: "if",
          schemaType: ["object", "boolean"],
          trackErrors: true,
          error,
          code(cxt) {
            const { gen, parentSchema, it } = cxt;
            if (parentSchema.then === undefined && parentSchema.else === undefined) {
              (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
            }
            const hasThen = hasSchema(it, "then");
            const hasElse = hasSchema(it, "else");
            if (!hasThen && !hasElse) return;
            const valid = gen.let("valid", true);
            const schValid = gen.name("_valid");
            validateIf();
            cxt.reset();
            if (hasThen && hasElse) {
              const ifClause = gen.let("ifClause");
              cxt.setParams({ ifClause });
              gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
            } else if (hasThen) {
              gen.if(schValid, validateClause("then"));
            } else {
              gen.if((0, codegen_1.not)(schValid), validateClause("else"));
            }
            cxt.pass(valid, () => cxt.error(true));
            function validateIf() {
              const schCxt = cxt.subschema(
                {
                  keyword: "if",
                  compositeRule: true,
                  createErrors: false,
                  allErrors: false,
                },
                schValid,
              );
              cxt.mergeEvaluated(schCxt);
            }
            function validateClause(keyword, ifClause) {
              return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
                else cxt.setParams({ ifClause: keyword });
              };
            }
          },
        };
        function hasSchema(it, keyword) {
          const schema = it.schema[keyword];
          return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
        }
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57 },
    ],
    88: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const additionalItems_1 = require("./additionalItems");
        const prefixItems_1 = require("./prefixItems");
        const items_1 = require("./items");
        const items2020_1 = require("./items2020");
        const contains_1 = require("./contains");
        const dependencies_1 = require("./dependencies");
        const propertyNames_1 = require("./propertyNames");
        const additionalProperties_1 = require("./additionalProperties");
        const properties_1 = require("./properties");
        const patternProperties_1 = require("./patternProperties");
        const not_1 = require("./not");
        const anyOf_1 = require("./anyOf");
        const oneOf_1 = require("./oneOf");
        const allOf_1 = require("./allOf");
        const if_1 = require("./if");
        const thenElse_1 = require("./thenElse");
        function getApplicator(draft2020 = false) {
          const applicator = [
            // any
            not_1.default,
            anyOf_1.default,
            oneOf_1.default,
            allOf_1.default,
            if_1.default,
            thenElse_1.default,
            // object
            propertyNames_1.default,
            additionalProperties_1.default,
            dependencies_1.default,
            properties_1.default,
            patternProperties_1.default,
          ];
          // array
          if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
          else applicator.push(additionalItems_1.default, items_1.default);
          applicator.push(contains_1.default);
          return applicator;
        }
        exports.default = getApplicator;
      },
      {
        "./additionalItems": 80,
        "./additionalProperties": 81,
        "./allOf": 82,
        "./anyOf": 83,
        "./contains": 84,
        "./dependencies": 85,
        "./if": 87,
        "./items": 89,
        "./items2020": 90,
        "./not": 91,
        "./oneOf": 92,
        "./patternProperties": 93,
        "./prefixItems": 94,
        "./properties": 95,
        "./propertyNames": 96,
        "./thenElse": 97,
      },
    ],
    89: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.validateTuple = void 0;
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const code_1 = require("../code");
        const def = {
          keyword: "items",
          type: "array",
          schemaType: ["object", "array", "boolean"],
          before: "uniqueItems",
          code(cxt) {
            const { schema, it } = cxt;
            if (Array.isArray(schema)) return validateTuple(cxt, "additionalItems", schema);
            it.items = true;
            if ((0, util_1.alwaysValidSchema)(it, schema)) return;
            cxt.ok((0, code_1.validateArray)(cxt));
          },
        };
        function validateTuple(cxt, extraItems, schArr = cxt.schema) {
          const { gen, parentSchema, data, keyword, it } = cxt;
          checkStrictTuple(parentSchema);
          if (it.opts.unevaluated && schArr.length && it.items !== true) {
            it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
          }
          const valid = gen.name("valid");
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          schArr.forEach((sch, i) => {
            if ((0, util_1.alwaysValidSchema)(it, sch)) return;
            gen.if((0, codegen_1._)`${len} > ${i}`, () =>
              cxt.subschema(
                {
                  keyword,
                  schemaProp: i,
                  dataProp: i,
                },
                valid,
              ),
            );
            cxt.ok(valid);
          });
          function checkStrictTuple(sch) {
            const { opts, errSchemaPath } = it;
            const l = schArr.length;
            const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
            if (opts.strictTuples && !fullTuple) {
              const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
              (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
            }
          }
        }
        exports.validateTuple = validateTuple;
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../code": 98 },
    ],
    90: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const code_1 = require("../code");
        const additionalItems_1 = require("./additionalItems");
        const error = {
          message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
          params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`,
        };
        const def = {
          keyword: "items",
          type: "array",
          schemaType: ["object", "boolean"],
          before: "uniqueItems",
          error,
          code(cxt) {
            const { schema, parentSchema, it } = cxt;
            const { prefixItems } = parentSchema;
            it.items = true;
            if ((0, util_1.alwaysValidSchema)(it, schema)) return;
            if (prefixItems) (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
            else cxt.ok((0, code_1.validateArray)(cxt));
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../code": 98, "./additionalItems": 80 },
    ],
    91: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const util_1 = require("../../compile/util");
        const def = {
          keyword: "not",
          schemaType: ["object", "boolean"],
          trackErrors: true,
          code(cxt) {
            const { gen, schema, it } = cxt;
            if ((0, util_1.alwaysValidSchema)(it, schema)) {
              cxt.fail();
              return;
            }
            const valid = gen.name("valid");
            cxt.subschema(
              {
                keyword: "not",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
              },
              valid,
            );
            cxt.failResult(
              valid,
              () => cxt.reset(),
              () => cxt.error(),
            );
          },
          error: { message: "must NOT be valid" },
        };
        exports.default = def;
      },
      { "../../compile/util": 57 },
    ],
    92: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const error = {
          message: "must match exactly one schema in oneOf",
          params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`,
        };
        const def = {
          keyword: "oneOf",
          schemaType: "array",
          trackErrors: true,
          error,
          code(cxt) {
            const { gen, schema, parentSchema, it } = cxt;
            /* istanbul ignore if */
            if (!Array.isArray(schema)) throw new Error("ajv implementation error");
            if (it.opts.discriminator && parentSchema.discriminator) return;
            const schArr = schema;
            const valid = gen.let("valid", false);
            const passing = gen.let("passing", null);
            const schValid = gen.name("_valid");
            cxt.setParams({ passing });
            // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
            gen.block(validateOneOf);
            cxt.result(
              valid,
              () => cxt.reset(),
              () => cxt.error(true),
            );
            function validateOneOf() {
              schArr.forEach((sch, i) => {
                let schCxt;
                if ((0, util_1.alwaysValidSchema)(it, sch)) {
                  gen.var(schValid, true);
                } else {
                  schCxt = cxt.subschema(
                    {
                      keyword: "oneOf",
                      schemaProp: i,
                      compositeRule: true,
                    },
                    schValid,
                  );
                }
                if (i > 0) {
                  gen
                    .if((0, codegen_1._)`${schValid} && ${valid}`)
                    .assign(valid, false)
                    .assign(passing, (0, codegen_1._)`[${passing}, ${i}]`)
                    .else();
                }
                gen.if(schValid, () => {
                  gen.assign(valid, true);
                  gen.assign(passing, i);
                  if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);
                });
              });
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57 },
    ],
    93: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const code_1 = require("../code");
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const util_2 = require("../../compile/util");
        const def = {
          keyword: "patternProperties",
          type: "object",
          schemaType: "object",
          code(cxt) {
            const { gen, schema, data, parentSchema, it } = cxt;
            const { opts } = it;
            const patterns = (0, code_1.allSchemaProperties)(schema);
            const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
            if (
              patterns.length === 0 ||
              (alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true))
            ) {
              return;
            }
            const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
            const valid = gen.name("valid");
            if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
              it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
            }
            const { props } = it;
            validatePatternProperties();
            function validatePatternProperties() {
              for (const pat of patterns) {
                if (checkProperties) checkMatchingProperties(pat);
                if (it.allErrors) {
                  validateProperties(pat);
                } else {
                  gen.var(valid, true); // TODO var
                  validateProperties(pat);
                  gen.if(valid);
                }
              }
            }
            function checkMatchingProperties(pat) {
              for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                  (0, util_1.checkStrictMode)(
                    it,
                    `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`,
                  );
                }
              }
            }
            function validateProperties(pat) {
              gen.forIn("key", data, (key) => {
                gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
                  const alwaysValid = alwaysValidPatterns.includes(pat);
                  if (!alwaysValid) {
                    cxt.subschema(
                      {
                        keyword: "patternProperties",
                        schemaProp: pat,
                        dataProp: key,
                        dataPropType: util_2.Type.Str,
                      },
                      valid,
                    );
                  }
                  if (it.opts.unevaluated && props !== true) {
                    gen.assign((0, codegen_1._)`${props}[${key}]`, true);
                  } else if (!alwaysValid && !it.allErrors) {
                    // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                    // or if all properties were evaluated (props === true)
                    gen.if((0, codegen_1.not)(valid), () => gen.break());
                  }
                });
              });
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../code": 98 },
    ],
    94: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const items_1 = require("./items");
        const def = {
          keyword: "prefixItems",
          type: "array",
          schemaType: ["array"],
          before: "uniqueItems",
          code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
        };
        exports.default = def;
      },
      { "./items": 89 },
    ],
    95: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const validate_1 = require("../../compile/validate");
        const code_1 = require("../code");
        const util_1 = require("../../compile/util");
        const additionalProperties_1 = require("./additionalProperties");
        const def = {
          keyword: "properties",
          type: "object",
          schemaType: "object",
          code(cxt) {
            const { gen, schema, parentSchema, data, it } = cxt;
            if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
              additionalProperties_1.default.code(
                new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"),
              );
            }
            const allProps = (0, code_1.allSchemaProperties)(schema);
            for (const prop of allProps) {
              it.definedProperties.add(prop);
            }
            if (it.opts.unevaluated && allProps.length && it.props !== true) {
              it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
            }
            const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
            if (properties.length === 0) return;
            const valid = gen.name("valid");
            for (const prop of properties) {
              if (hasDefault(prop)) {
                applyPropertySchema(prop);
              } else {
                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors) gen.else().var(valid, true);
                gen.endIf();
              }
              cxt.it.definedProperties.add(prop);
              cxt.ok(valid);
            }
            function hasDefault(prop) {
              return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
            }
            function applyPropertySchema(prop) {
              cxt.subschema(
                {
                  keyword: "properties",
                  schemaProp: prop,
                  dataProp: prop,
                },
                valid,
              );
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/util": 57, "../../compile/validate": 62, "../code": 98, "./additionalProperties": 81 },
    ],
    96: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const error = {
          message: "property name must be valid",
          params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`,
        };
        const def = {
          keyword: "propertyNames",
          type: "object",
          schemaType: ["object", "boolean"],
          error,
          code(cxt) {
            const { gen, schema, data, it } = cxt;
            if ((0, util_1.alwaysValidSchema)(it, schema)) return;
            const valid = gen.name("valid");
            gen.forIn("key", data, (key) => {
              cxt.setParams({ propertyName: key });
              cxt.subschema(
                {
                  keyword: "propertyNames",
                  data: key,
                  dataTypes: ["string"],
                  propertyName: key,
                  compositeRule: true,
                },
                valid,
              );
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.error(true);
                if (!it.allErrors) gen.break();
              });
            });
            cxt.ok(valid);
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57 },
    ],
    97: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const util_1 = require("../../compile/util");
        const def = {
          keyword: ["then", "else"],
          schemaType: ["object", "boolean"],
          code({ keyword, parentSchema, it }) {
            if (parentSchema.if === undefined) (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
          },
        };
        exports.default = def;
      },
      { "../../compile/util": 57 },
    ],
    98: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.validateUnion =
          exports.validateArray =
          exports.usePattern =
          exports.callValidateCode =
          exports.schemaProperties =
          exports.allSchemaProperties =
          exports.noPropertyInData =
          exports.propertyInData =
          exports.isOwnProperty =
          exports.hasPropFunc =
          exports.reportMissingProp =
          exports.checkMissingProp =
          exports.checkReportMissingProp =
            void 0;
        const codegen_1 = require("../compile/codegen");
        const util_1 = require("../compile/util");
        const names_1 = require("../compile/names");
        const util_2 = require("../compile/util");
        function checkReportMissingProp(cxt, prop) {
          const { gen, data, it } = cxt;
          gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
            cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
            cxt.error();
          });
        }
        exports.checkReportMissingProp = checkReportMissingProp;
        function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
          return (0, codegen_1.or)(
            ...properties.map((prop) =>
              (0, codegen_1.and)(
                noPropertyInData(gen, data, prop, opts.ownProperties),
                (0, codegen_1._)`${missing} = ${prop}`,
              ),
            ),
          );
        }
        exports.checkMissingProp = checkMissingProp;
        function reportMissingProp(cxt, missing) {
          cxt.setParams({ missingProperty: missing }, true);
          cxt.error();
        }
        exports.reportMissingProp = reportMissingProp;
        function hasPropFunc(gen) {
          return gen.scopeValue("func", {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            ref: Object.prototype.hasOwnProperty,
            code: (0, codegen_1._)`Object.prototype.hasOwnProperty`,
          });
        }
        exports.hasPropFunc = hasPropFunc;
        function isOwnProperty(gen, data, property) {
          return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
        }
        exports.isOwnProperty = isOwnProperty;
        function propertyInData(gen, data, property, ownProperties) {
          const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
          return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
        }
        exports.propertyInData = propertyInData;
        function noPropertyInData(gen, data, property, ownProperties) {
          const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
          return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
        }
        exports.noPropertyInData = noPropertyInData;
        function allSchemaProperties(schemaMap) {
          return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
        }
        exports.allSchemaProperties = allSchemaProperties;
        function schemaProperties(it, schemaMap) {
          return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
        }
        exports.schemaProperties = schemaProperties;
        function callValidateCode(
          { schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it },
          func,
          context,
          passSchema,
        ) {
          const dataAndSchema = passSchema
            ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}`
            : data;
          const valCxt = [
            [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
            [names_1.default.parentData, it.parentData],
            [names_1.default.parentDataProperty, it.parentDataProperty],
            [names_1.default.rootData, names_1.default.rootData],
          ];
          if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
          const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
          return context !== codegen_1.nil
            ? (0, codegen_1._)`${func}.call(${context}, ${args})`
            : (0, codegen_1._)`${func}(${args})`;
        }
        exports.callValidateCode = callValidateCode;
        const newRegExp = (0, codegen_1._)`new RegExp`;
        function usePattern({ gen, it: { opts } }, pattern) {
          const u = opts.unicodeRegExp ? "u" : "";
          const { regExp } = opts.code;
          const rx = regExp(pattern, u);
          return gen.scopeValue("pattern", {
            key: rx.toString(),
            ref: rx,
            code: (0,
            codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
          });
        }
        exports.usePattern = usePattern;
        function validateArray(cxt) {
          const { gen, data, keyword, it } = cxt;
          const valid = gen.name("valid");
          if (it.allErrors) {
            const validArr = gen.let("valid", true);
            validateItems(() => gen.assign(validArr, false));
            return validArr;
          }
          gen.var(valid, true);
          validateItems(() => gen.break());
          return valid;
          function validateItems(notValid) {
            const len = gen.const("len", (0, codegen_1._)`${data}.length`);
            gen.forRange("i", 0, len, (i) => {
              cxt.subschema(
                {
                  keyword,
                  dataProp: i,
                  dataPropType: util_1.Type.Num,
                },
                valid,
              );
              gen.if((0, codegen_1.not)(valid), notValid);
            });
          }
        }
        exports.validateArray = validateArray;
        function validateUnion(cxt) {
          const { gen, schema, keyword, it } = cxt;
          /* istanbul ignore if */
          if (!Array.isArray(schema)) throw new Error("ajv implementation error");
          const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
          if (alwaysValid && !it.opts.unevaluated) return;
          const valid = gen.let("valid", false);
          const schValid = gen.name("_valid");
          gen.block(() =>
            schema.forEach((_sch, i) => {
              const schCxt = cxt.subschema(
                {
                  keyword,
                  schemaProp: i,
                  compositeRule: true,
                },
                schValid,
              );
              gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
              const merged = cxt.mergeValidEvaluated(schCxt, schValid);
              // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
              // or if all properties and items were evaluated (it.props === true && it.items === true)
              if (!merged) gen.if((0, codegen_1.not)(valid));
            }),
          );
          cxt.result(
            valid,
            () => cxt.reset(),
            () => cxt.error(true),
          );
        }
        exports.validateUnion = validateUnion;
      },
      { "../compile/codegen": 49, "../compile/names": 53, "../compile/util": 57 },
    ],
    99: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const def = {
          keyword: "id",
          code() {
            throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
          },
        };
        exports.default = def;
      },
      {},
    ],
    100: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const id_1 = require("./id");
        const ref_1 = require("./ref");
        const core = [
          "$schema",
          "$id",
          "$defs",
          "$vocabulary",
          { keyword: "$comment" },
          "definitions",
          id_1.default,
          ref_1.default,
        ];
        exports.default = core;
      },
      { "./id": 99, "./ref": 101 },
    ],
    101: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.callRef = exports.getValidate = void 0;
        const ref_error_1 = require("../../compile/ref_error");
        const code_1 = require("../code");
        const codegen_1 = require("../../compile/codegen");
        const names_1 = require("../../compile/names");
        const compile_1 = require("../../compile");
        const util_1 = require("../../compile/util");
        const def = {
          keyword: "$ref",
          schemaType: "string",
          code(cxt) {
            const { gen, schema: $ref, it } = cxt;
            const { baseId, schemaEnv: env, validateName, opts, self } = it;
            const { root } = env;
            if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
            const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
            if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
            if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);
            return inlineRefSchema(schOrEnv);
            function callRootRef() {
              if (env === root) return callRef(cxt, validateName, env, env.$async);
              const rootName = gen.scopeValue("root", { ref: root });
              return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
            }
            function callValidate(sch) {
              const v = getValidate(cxt, sch);
              callRef(cxt, v, sch, sch.$async);
            }
            function inlineRefSchema(sch) {
              const schName = gen.scopeValue(
                "schema",
                opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch },
              );
              const valid = gen.name("valid");
              const schCxt = cxt.subschema(
                {
                  schema: sch,
                  dataTypes: [],
                  schemaPath: codegen_1.nil,
                  topSchemaRef: schName,
                  errSchemaPath: $ref,
                },
                valid,
              );
              cxt.mergeEvaluated(schCxt);
              cxt.ok(valid);
            }
          },
        };
        function getValidate(cxt, sch) {
          const { gen } = cxt;
          return sch.validate
            ? gen.scopeValue("validate", { ref: sch.validate })
            : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
        }
        exports.getValidate = getValidate;
        function callRef(cxt, v, sch, $async) {
          const { gen, it } = cxt;
          const { allErrors, schemaEnv: env, opts } = it;
          const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
          if ($async) callAsyncRef();
          else callSyncRef();
          function callAsyncRef() {
            if (!env.$async) throw new Error("async schema referenced by sync schema");
            const valid = gen.let("valid");
            gen.try(
              () => {
                gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
                addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
                if (!allErrors) gen.assign(valid, true);
              },
              (e) => {
                gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
                addErrorsFrom(e);
                if (!allErrors) gen.assign(valid, false);
              },
            );
            cxt.ok(valid);
          }
          function callSyncRef() {
            cxt.result(
              (0, code_1.callValidateCode)(cxt, v, passCxt),
              () => addEvaluatedFrom(v),
              () => addErrorsFrom(v),
            );
          }
          function addErrorsFrom(source) {
            const errs = (0, codegen_1._)`${source}.errors`;
            gen.assign(
              names_1.default.vErrors,
              (0,
              codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`,
            ); // TODO tagged
            gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
          }
          function addEvaluatedFrom(source) {
            var _a;
            if (!it.opts.unevaluated) return;
            const schEvaluated =
              (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0
                ? void 0
                : _a.evaluated;
            // TODO refactor
            if (it.props !== true) {
              if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                  it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
              } else {
                const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
              }
            }
            if (it.items !== true) {
              if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                  it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
              } else {
                const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
              }
            }
          }
        }
        exports.callRef = callRef;
        exports.default = def;
      },
      {
        "../../compile": 52,
        "../../compile/codegen": 49,
        "../../compile/names": 53,
        "../../compile/ref_error": 54,
        "../../compile/util": 57,
        "../code": 98,
      },
    ],
    102: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const types_1 = require("../discriminator/types");
        const compile_1 = require("../../compile");
        const util_1 = require("../../compile/util");
        const error = {
          message: ({ params: { discrError, tagName } }) =>
            discrError === types_1.DiscrError.Tag
              ? `tag "${tagName}" must be string`
              : `value of tag "${tagName}" must be in oneOf`,
          params: ({ params: { discrError, tag, tagName } }) =>
            (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
        };
        const def = {
          keyword: "discriminator",
          type: "object",
          schemaType: "object",
          error,
          code(cxt) {
            const { gen, data, schema, parentSchema, it } = cxt;
            const { oneOf } = parentSchema;
            if (!it.opts.discriminator) {
              throw new Error("discriminator: requires discriminator option");
            }
            const tagName = schema.propertyName;
            if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
            if (schema.mapping) throw new Error("discriminator: mapping is not supported");
            if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
            const valid = gen.let("valid", false);
            const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
            gen.if(
              (0, codegen_1._)`typeof ${tag} == "string"`,
              () => validateMapping(),
              () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }),
            );
            cxt.ok(valid);
            function validateMapping() {
              const mapping = getMapping();
              gen.if(false);
              for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
              }
              gen.else();
              cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
              gen.endIf();
            }
            function applyTagSchema(schemaProp) {
              const _valid = gen.name("valid");
              const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
              return _valid;
            }
            function getMapping() {
              var _a;
              const oneOfMapping = {};
              const topRequired = hasRequired(parentSchema);
              let tagRequired = true;
              for (let i = 0; i < oneOf.length; i++) {
                let sch = oneOf[i];
                if (
                  (sch === null || sch === void 0 ? void 0 : sch.$ref) &&
                  !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)
                ) {
                  sch = compile_1.resolveRef.call(
                    it.self,
                    it.schemaEnv.root,
                    it.baseId,
                    sch === null || sch === void 0 ? void 0 : sch.$ref,
                  );
                  if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
                }
                const propSch =
                  (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0
                    ? void 0
                    : _a[tagName];
                if (typeof propSch != "object") {
                  throw new Error(
                    `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`,
                  );
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
              }
              if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
              return oneOfMapping;
              function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
              }
              function addMappings(sch, i) {
                if (sch.const) {
                  addMapping(sch.const, i);
                } else if (sch.enum) {
                  for (const tagValue of sch.enum) {
                    addMapping(tagValue, i);
                  }
                } else {
                  throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
              }
              function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                  throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                oneOfMapping[tagValue] = i;
              }
            }
          },
        };
        exports.default = def;
      },
      { "../../compile": 52, "../../compile/codegen": 49, "../../compile/util": 57, "../discriminator/types": 103 },
    ],
    103: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.DiscrError = void 0;
        var DiscrError;
        (function (DiscrError) {
          DiscrError["Tag"] = "tag";
          DiscrError["Mapping"] = "mapping";
        })((DiscrError = exports.DiscrError || (exports.DiscrError = {})));
      },
      {},
    ],
    104: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const core_1 = require("./core");
        const validation_1 = require("./validation");
        const applicator_1 = require("./applicator");
        const dynamic_1 = require("./dynamic");
        const next_1 = require("./next");
        const unevaluated_1 = require("./unevaluated");
        const format_1 = require("./format");
        const metadata_1 = require("./metadata");
        const draft2020Vocabularies = [
          dynamic_1.default,
          core_1.default,
          validation_1.default,
          (0, applicator_1.default)(true),
          format_1.default,
          metadata_1.metadataVocabulary,
          metadata_1.contentVocabulary,
          next_1.default,
          unevaluated_1.default,
        ];
        exports.default = draft2020Vocabularies;
      },
      {
        "./applicator": 88,
        "./core": 100,
        "./dynamic": 107,
        "./format": 111,
        "./metadata": 112,
        "./next": 113,
        "./unevaluated": 114,
        "./validation": 120,
      },
    ],
    105: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.dynamicAnchor = void 0;
        const codegen_1 = require("../../compile/codegen");
        const names_1 = require("../../compile/names");
        const compile_1 = require("../../compile");
        const ref_1 = require("../core/ref");
        const def = {
          keyword: "$dynamicAnchor",
          schemaType: "string",
          code: (cxt) => dynamicAnchor(cxt, cxt.schema),
        };
        function dynamicAnchor(cxt, anchor) {
          const { gen, it } = cxt;
          it.schemaEnv.root.dynamicAnchors[anchor] = true;
          const v = (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;
          const validate = it.errSchemaPath === "#" ? it.validateName : _getValidate(cxt);
          gen.if((0, codegen_1._)`!${v}`, () => gen.assign(v, validate));
        }
        exports.dynamicAnchor = dynamicAnchor;
        function _getValidate(cxt) {
          const { schemaEnv, schema, self } = cxt.it;
          const { root, baseId, localRefs, meta } = schemaEnv.root;
          const { schemaId } = self.opts;
          const sch = new compile_1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });
          compile_1.compileSchema.call(self, sch);
          return (0, ref_1.getValidate)(cxt, sch);
        }
        exports.default = def;
      },
      { "../../compile": 52, "../../compile/codegen": 49, "../../compile/names": 53, "../core/ref": 101 },
    ],
    106: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.dynamicRef = void 0;
        const codegen_1 = require("../../compile/codegen");
        const names_1 = require("../../compile/names");
        const ref_1 = require("../core/ref");
        const def = {
          keyword: "$dynamicRef",
          schemaType: "string",
          code: (cxt) => dynamicRef(cxt, cxt.schema),
        };
        function dynamicRef(cxt, ref) {
          const { gen, keyword, it } = cxt;
          if (ref[0] !== "#") throw new Error(`"${keyword}" only supports hash fragment reference`);
          const anchor = ref.slice(1);
          if (it.allErrors) {
            _dynamicRef();
          } else {
            const valid = gen.let("valid", false);
            _dynamicRef(valid);
            cxt.ok(valid);
          }
          function _dynamicRef(valid) {
            // TODO the assumption here is that `recursiveRef: #` always points to the root
            // of the schema object, which is not correct, because there may be $id that
            // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.
            // Because of that 2 tests in recursiveRef.json fail.
            // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ "$ref": "#" }`).
            // (This problem is not tested in JSON-Schema-Test-Suite)
            if (it.schemaEnv.root.dynamicAnchors[anchor]) {
              const v = gen.let(
                "_v",
                (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`,
              );
              gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
            } else {
              _callRef(it.validateName, valid)();
            }
          }
          function _callRef(validate, valid) {
            return valid
              ? () =>
                  gen.block(() => {
                    (0, ref_1.callRef)(cxt, validate);
                    gen.let(valid, true);
                  })
              : () => (0, ref_1.callRef)(cxt, validate);
          }
        }
        exports.dynamicRef = dynamicRef;
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/names": 53, "../core/ref": 101 },
    ],
    107: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const dynamicAnchor_1 = require("./dynamicAnchor");
        const dynamicRef_1 = require("./dynamicRef");
        const recursiveAnchor_1 = require("./recursiveAnchor");
        const recursiveRef_1 = require("./recursiveRef");
        const dynamic = [
          dynamicAnchor_1.default,
          dynamicRef_1.default,
          recursiveAnchor_1.default,
          recursiveRef_1.default,
        ];
        exports.default = dynamic;
      },
      { "./dynamicAnchor": 105, "./dynamicRef": 106, "./recursiveAnchor": 108, "./recursiveRef": 109 },
    ],
    108: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const dynamicAnchor_1 = require("./dynamicAnchor");
        const util_1 = require("../../compile/util");
        const def = {
          keyword: "$recursiveAnchor",
          schemaType: "boolean",
          code(cxt) {
            if (cxt.schema) (0, dynamicAnchor_1.dynamicAnchor)(cxt, "");
            else (0, util_1.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
          },
        };
        exports.default = def;
      },
      { "../../compile/util": 57, "./dynamicAnchor": 105 },
    ],
    109: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const dynamicRef_1 = require("./dynamicRef");
        const def = {
          keyword: "$recursiveRef",
          schemaType: "string",
          code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema),
        };
        exports.default = def;
      },
      { "./dynamicRef": 106 },
    ],
    110: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const error = {
          message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
          params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`,
        };
        const def = {
          keyword: "format",
          type: ["number", "string"],
          schemaType: "string",
          $data: true,
          error,
          code(cxt, ruleType) {
            const { gen, data, $data, schema, schemaCode, it } = cxt;
            const { opts, errSchemaPath, schemaEnv, self } = it;
            if (!opts.validateFormats) return;
            if ($data) validate$DataFormat();
            else validateFormat();
            function validate$DataFormat() {
              const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
              });
              const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
              const fType = gen.let("fType");
              const format = gen.let("format");
              // TODO simplify
              gen.if(
                (0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`,
                () =>
                  gen
                    .assign(fType, (0, codegen_1._)`${fDef}.type || "string"`)
                    .assign(format, (0, codegen_1._)`${fDef}.validate`),
                () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef),
              );
              cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
              function unknownFmt() {
                if (opts.strictSchema === false) return codegen_1.nil;
                return (0, codegen_1._)`${schemaCode} && !${format}`;
              }
              function invalidFmt() {
                const callFormat = schemaEnv.$async
                  ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                  : (0, codegen_1._)`${format}(${data})`;
                const validData = (0,
                codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
              }
            }
            function validateFormat() {
              const formatDef = self.formats[schema];
              if (!formatDef) {
                unknownFormat();
                return;
              }
              if (formatDef === true) return;
              const [fmtType, format, fmtRef] = getFormat(formatDef);
              if (fmtType === ruleType) cxt.pass(validCondition());
              function unknownFormat() {
                if (opts.strictSchema === false) {
                  self.logger.warn(unknownMsg());
                  return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                  return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
              }
              function getFormat(fmtDef) {
                const code =
                  fmtDef instanceof RegExp
                    ? (0, codegen_1.regexpCode)(fmtDef)
                    : opts.code.formats
                      ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
                      : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                  return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
              }
              function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                  if (!schemaEnv.$async) throw new Error("async format in sync schema");
                  return (0, codegen_1._)`await ${fmtRef}(${data})`;
                }
                return typeof format == "function"
                  ? (0, codegen_1._)`${fmtRef}(${data})`
                  : (0, codegen_1._)`${fmtRef}.test(${data})`;
              }
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49 },
    ],
    111: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const format_1 = require("./format");
        const format = [format_1.default];
        exports.default = format;
      },
      { "./format": 110 },
    ],
    112: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.contentVocabulary = exports.metadataVocabulary = void 0;
        exports.metadataVocabulary = [
          "title",
          "description",
          "default",
          "deprecated",
          "readOnly",
          "writeOnly",
          "examples",
        ];
        exports.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
      },
      {},
    ],
    113: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const dependentRequired_1 = require("./validation/dependentRequired");
        const dependentSchemas_1 = require("./applicator/dependentSchemas");
        const limitContains_1 = require("./validation/limitContains");
        const next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
        exports.default = next;
      },
      { "./applicator/dependentSchemas": 86, "./validation/dependentRequired": 118, "./validation/limitContains": 121 },
    ],
    114: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const unevaluatedProperties_1 = require("./unevaluatedProperties");
        const unevaluatedItems_1 = require("./unevaluatedItems");
        const unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
        exports.default = unevaluated;
      },
      { "./unevaluatedItems": 115, "./unevaluatedProperties": 116 },
    ],
    115: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const error = {
          message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
          params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`,
        };
        const def = {
          keyword: "unevaluatedItems",
          type: "array",
          schemaType: ["boolean", "object"],
          error,
          code(cxt) {
            const { gen, schema, data, it } = cxt;
            const items = it.items || 0;
            if (items === true) return;
            const len = gen.const("len", (0, codegen_1._)`${data}.length`);
            if (schema === false) {
              cxt.setParams({ len: items });
              cxt.fail((0, codegen_1._)`${len} > ${items}`);
            } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
              const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items}`);
              gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items));
              cxt.ok(valid);
            }
            it.items = true;
            function validateItems(valid, from) {
              gen.forRange("i", from, len, (i) => {
                cxt.subschema({ keyword: "unevaluatedItems", dataProp: i, dataPropType: util_1.Type.Num }, valid);
                if (!it.allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
              });
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57 },
    ],
    116: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const names_1 = require("../../compile/names");
        const error = {
          message: "must NOT have unevaluated properties",
          params: ({ params }) => (0, codegen_1._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`,
        };
        const def = {
          keyword: "unevaluatedProperties",
          type: "object",
          schemaType: ["boolean", "object"],
          trackErrors: true,
          error,
          code(cxt) {
            const { gen, schema, data, errsCount, it } = cxt;
            /* istanbul ignore if */
            if (!errsCount) throw new Error("ajv implementation error");
            const { allErrors, props } = it;
            if (props instanceof codegen_1.Name) {
              gen.if((0, codegen_1._)`${props} !== true`, () =>
                gen.forIn("key", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))),
              );
            } else if (props !== true) {
              gen.forIn("key", data, (key) =>
                props === undefined
                  ? unevaluatedPropCode(key)
                  : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)),
              );
            }
            it.props = true;
            cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
            function unevaluatedPropCode(key) {
              if (schema === false) {
                cxt.setParams({ unevaluatedProperty: key });
                cxt.error();
                if (!allErrors) gen.break();
                return;
              }
              if (!(0, util_1.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                cxt.subschema(
                  {
                    keyword: "unevaluatedProperties",
                    dataProp: key,
                    dataPropType: util_1.Type.Str,
                  },
                  valid,
                );
                if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            }
            function unevaluatedDynamic(evaluatedProps, key) {
              return (0, codegen_1._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
            }
            function unevaluatedStatic(evaluatedProps, key) {
              const ps = [];
              for (const p in evaluatedProps) {
                if (evaluatedProps[p] === true) ps.push((0, codegen_1._)`${key} !== ${p}`);
              }
              return (0, codegen_1.and)(...ps);
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/names": 53, "../../compile/util": 57 },
    ],
    117: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const equal_1 = require("../../runtime/equal");
        const error = {
          message: "must be equal to constant",
          params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`,
        };
        const def = {
          keyword: "const",
          $data: true,
          error,
          code(cxt) {
            const { gen, data, $data, schemaCode, schema } = cxt;
            if ($data || (schema && typeof schema == "object")) {
              cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
            } else {
              cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../../runtime/equal": 76 },
    ],
    118: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const dependencies_1 = require("../applicator/dependencies");
        const def = {
          keyword: "dependentRequired",
          type: "object",
          schemaType: "object",
          error: dependencies_1.error,
          code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt),
        };
        exports.default = def;
      },
      { "../applicator/dependencies": 85 },
    ],
    119: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const equal_1 = require("../../runtime/equal");
        const error = {
          message: "must be equal to one of the allowed values",
          params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`,
        };
        const def = {
          keyword: "enum",
          schemaType: "array",
          $data: true,
          error,
          code(cxt) {
            const { gen, data, $data, schema, schemaCode, it } = cxt;
            if (!$data && schema.length === 0) throw new Error("enum must have non-empty array");
            const useLoop = schema.length >= it.opts.loopEnum;
            let eql;
            const getEql = () =>
              eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default));
            let valid;
            if (useLoop || $data) {
              valid = gen.let("valid");
              cxt.block$data(valid, loopEnum);
            } else {
              /* istanbul ignore if */
              if (!Array.isArray(schema)) throw new Error("ajv implementation error");
              const vSchema = gen.const("vSchema", schemaCode);
              valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
            }
            cxt.pass(valid);
            function loopEnum() {
              gen.assign(valid, false);
              gen.forOf("v", schemaCode, (v) =>
                gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()),
              );
            }
            function equalCode(vSchema, i) {
              const sch = schema[i];
              return typeof sch === "object" && sch !== null
                ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])`
                : (0, codegen_1._)`${data} === ${sch}`;
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../../runtime/equal": 76 },
    ],
    120: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const limitNumber_1 = require("./limitNumber");
        const multipleOf_1 = require("./multipleOf");
        const limitLength_1 = require("./limitLength");
        const pattern_1 = require("./pattern");
        const limitProperties_1 = require("./limitProperties");
        const required_1 = require("./required");
        const limitItems_1 = require("./limitItems");
        const uniqueItems_1 = require("./uniqueItems");
        const const_1 = require("./const");
        const enum_1 = require("./enum");
        const validation = [
          // number
          limitNumber_1.default,
          multipleOf_1.default,
          // string
          limitLength_1.default,
          pattern_1.default,
          // object
          limitProperties_1.default,
          required_1.default,
          // array
          limitItems_1.default,
          uniqueItems_1.default,
          // any
          { keyword: "type", schemaType: ["string", "array"] },
          { keyword: "nullable", schemaType: "boolean" },
          const_1.default,
          enum_1.default,
        ];
        exports.default = validation;
      },
      {
        "./const": 117,
        "./enum": 119,
        "./limitItems": 122,
        "./limitLength": 123,
        "./limitNumber": 124,
        "./limitProperties": 125,
        "./multipleOf": 126,
        "./pattern": 127,
        "./required": 128,
        "./uniqueItems": 129,
      },
    ],
    121: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const util_1 = require("../../compile/util");
        const def = {
          keyword: ["maxContains", "minContains"],
          type: "array",
          schemaType: "number",
          code({ keyword, parentSchema, it }) {
            if (parentSchema.contains === undefined) {
              (0, util_1.checkStrictMode)(it, `"${keyword}" without "contains" is ignored`);
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/util": 57 },
    ],
    122: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const error = {
          message({ keyword, schemaCode }) {
            const comp = keyword === "maxItems" ? "more" : "fewer";
            return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
          },
          params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
        };
        const def = {
          keyword: ["maxItems", "minItems"],
          type: "array",
          schemaType: "number",
          $data: true,
          error,
          code(cxt) {
            const { keyword, data, schemaCode } = cxt;
            const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
            cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49 },
    ],
    123: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const ucs2length_1 = require("../../runtime/ucs2length");
        const error = {
          message({ keyword, schemaCode }) {
            const comp = keyword === "maxLength" ? "more" : "fewer";
            return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
          },
          params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
        };
        const def = {
          keyword: ["maxLength", "minLength"],
          type: "string",
          schemaType: "number",
          $data: true,
          error,
          code(cxt) {
            const { keyword, data, schemaCode, it } = cxt;
            const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
            const len =
              it.opts.unicode === false
                ? (0, codegen_1._)`${data}.length`
                : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
            cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../../runtime/ucs2length": 77 },
    ],
    124: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const ops = codegen_1.operators;
        const KWDs = {
          maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
          minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
          exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
          exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
        };
        const error = {
          message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
          params: ({ keyword, schemaCode }) =>
            (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
        };
        const def = {
          keyword: Object.keys(KWDs),
          type: "number",
          schemaType: "number",
          $data: true,
          error,
          code(cxt) {
            const { keyword, data, schemaCode } = cxt;
            cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49 },
    ],
    125: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const error = {
          message({ keyword, schemaCode }) {
            const comp = keyword === "maxProperties" ? "more" : "fewer";
            return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
          },
          params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
        };
        const def = {
          keyword: ["maxProperties", "minProperties"],
          type: "object",
          schemaType: "number",
          $data: true,
          error,
          code(cxt) {
            const { keyword, data, schemaCode } = cxt;
            const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
            cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49 },
    ],
    126: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const codegen_1 = require("../../compile/codegen");
        const error = {
          message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
          params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`,
        };
        const def = {
          keyword: "multipleOf",
          type: "number",
          schemaType: "number",
          $data: true,
          error,
          code(cxt) {
            const { gen, data, schemaCode, it } = cxt;
            // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
            const prec = it.opts.multipleOfPrecision;
            const res = gen.let("res");
            const invalid = prec
              ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
              : (0, codegen_1._)`${res} !== parseInt(${res})`;
            cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49 },
    ],
    127: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const code_1 = require("../code");
        const codegen_1 = require("../../compile/codegen");
        const error = {
          message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
          params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`,
        };
        const def = {
          keyword: "pattern",
          type: "string",
          schemaType: "string",
          $data: true,
          error,
          code(cxt) {
            const { data, $data, schema, schemaCode, it } = cxt;
            // TODO regexp should be wrapped in try/catchs
            const u = it.opts.unicodeRegExp ? "u" : "";
            const regExp = $data
              ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))`
              : (0, code_1.usePattern)(cxt, schema);
            cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../code": 98 },
    ],
    128: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const code_1 = require("../code");
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const error = {
          message: ({ params: { missingProperty } }) =>
            (0, codegen_1.str)`must have required property '${missingProperty}'`,
          params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`,
        };
        const def = {
          keyword: "required",
          type: "object",
          schemaType: "array",
          $data: true,
          error,
          code(cxt) {
            const { gen, schema, schemaCode, data, $data, it } = cxt;
            const { opts } = it;
            if (!$data && schema.length === 0) return;
            const useLoop = schema.length >= opts.loopRequired;
            if (it.allErrors) allErrorsMode();
            else exitOnErrorMode();
            if (opts.strictRequired) {
              const props = cxt.parentSchema.properties;
              const { definedProperties } = cxt.it;
              for (const requiredKey of schema) {
                if (
                  (props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined &&
                  !definedProperties.has(requiredKey)
                ) {
                  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                  const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                  (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
                }
              }
            }
            function allErrorsMode() {
              if (useLoop || $data) {
                cxt.block$data(codegen_1.nil, loopAllRequired);
              } else {
                for (const prop of schema) {
                  (0, code_1.checkReportMissingProp)(cxt, prop);
                }
              }
            }
            function exitOnErrorMode() {
              const missing = gen.let("missing");
              if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
              } else {
                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
                (0, code_1.reportMissingProp)(cxt, missing);
                gen.else();
              }
            }
            function loopAllRequired() {
              gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
              });
            }
            function loopUntilMissing(missing, valid) {
              cxt.setParams({ missingProperty: missing });
              gen.forOf(
                missing,
                schemaCode,
                () => {
                  gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
                  gen.if((0, codegen_1.not)(valid), () => {
                    cxt.error();
                    gen.break();
                  });
                },
                codegen_1.nil,
              );
            }
          },
        };
        exports.default = def;
      },
      { "../../compile/codegen": 49, "../../compile/util": 57, "../code": 98 },
    ],
    129: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const dataType_1 = require("../../compile/validate/dataType");
        const codegen_1 = require("../../compile/codegen");
        const util_1 = require("../../compile/util");
        const equal_1 = require("../../runtime/equal");
        const error = {
          message: ({ params: { i, j } }) =>
            (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
          params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`,
        };
        const def = {
          keyword: "uniqueItems",
          type: "array",
          schemaType: "boolean",
          $data: true,
          error,
          code(cxt) {
            const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
            if (!$data && !schema) return;
            const valid = gen.let("valid");
            const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
            cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
            cxt.ok(valid);
            function validateUniqueItems() {
              const i = gen.let("i", (0, codegen_1._)`${data}.length`);
              const j = gen.let("j");
              cxt.setParams({ i, j });
              gen.assign(valid, true);
              gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
            }
            function canOptimize() {
              return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
            }
            function loopN(i, j) {
              const item = gen.name("item");
              const wrongType = (0, dataType_1.checkDataTypes)(
                itemTypes,
                item,
                it.opts.strictNumbers,
                dataType_1.DataType.Wrong,
              );
              const indices = gen.const("indices", (0, codegen_1._)`{}`);
              gen.for((0, codegen_1._)`;${i}--;`, () => {
                gen.let(item, (0, codegen_1._)`${data}[${i}]`);
                gen.if(wrongType, (0, codegen_1._)`continue`);
                if (itemTypes.length > 1)
                  gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
                gen
                  .if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                  })
                  .code((0, codegen_1._)`${indices}[${item}] = ${i}`);
              });
            }
            function loopN2(i, j) {
              const eql = (0, util_1.useFunc)(gen, equal_1.default);
              const outer = gen.name("outer");
              gen.label(outer).for((0, codegen_1._)`;${i}--;`, () =>
                gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () =>
                  gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
                    cxt.error();
                    gen.assign(valid, false).break(outer);
                  }),
                ),
              );
            }
          },
        };
        exports.default = def;
      },
      {
        "../../compile/codegen": 49,
        "../../compile/util": 57,
        "../../compile/validate/dataType": 60,
        "../../runtime/equal": 76,
      },
    ],
    130: [
      function (require, module, exports) {
        "use strict";

        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;

        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }

        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;

        function getLens(b64) {
          var len = b64.length;

          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }

          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf("=");
          if (validLen === -1) validLen = len;

          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);

          return [validLen, placeHoldersLen];
        }

        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];

          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

          var curByte = 0;

          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

          var i;
          for (i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)];
            arr[curByte++] = (tmp >> 16) & 0xff;
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 2) {
            tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2);
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          return arr;
        }

        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] + lookup[(num >> 12) & 0x3f] + lookup[(num >> 6) & 0x3f] + lookup[num & 0x3f]
          );
        }

        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp = ((uint8[i] << 16) & 0xff0000) + ((uint8[i + 1] << 8) & 0xff00) + (uint8[i + 2] & 0xff);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }

        function fromByteArray(uint8) {
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
          var parts = [];
          var maxChunkLength = 16383; // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3f] + lookup[(tmp << 2) & 0x3f] + "=");
          }

          return parts.join("");
        }
      },
      {},
    ],
    131: [function (require, module, exports) {}, {}],
    132: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */
            /* eslint-disable no-proto */

            "use strict";

            var base64 = require("base64-js");
            var ieee754 = require("ieee754");

            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;

            var K_MAX_LENGTH = 0x7fffffff;
            exports.kMaxLength = K_MAX_LENGTH;

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Print warning and recommend using `buffer` v4.x which has an Object
             *               implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * We report that the browser does not support typed arrays if the are not subclassable
             * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
             * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
             * for __proto__ and has a buggy typed array implementation.
             */
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
              console.error(
                "This browser lacks typed array (Uint8Array) support which is required by " +
                  "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.",
              );
            }

            function typedArraySupport() {
              // Can typed array instances can be augmented?
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = {
                  __proto__: Uint8Array.prototype,
                  foo: function () {
                    return 42;
                  },
                };
                return arr.foo() === 42;
              } catch (e) {
                return false;
              }
            }

            Object.defineProperty(Buffer.prototype, "parent", {
              enumerable: true,
              get: function () {
                if (!Buffer.isBuffer(this)) return undefined;
                return this.buffer;
              },
            });

            Object.defineProperty(Buffer.prototype, "offset", {
              enumerable: true,
              get: function () {
                if (!Buffer.isBuffer(this)) return undefined;
                return this.byteOffset;
              },
            });

            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
              }
              // Return an augmented `Uint8Array` instance
              var buf = new Uint8Array(length);
              buf.__proto__ = Buffer.prototype;
              return buf;
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer(arg, encodingOrOffset, length) {
              // Common case.
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }

            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
              Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true,
                enumerable: false,
                writable: false,
              });
            }

            Buffer.poolSize = 8192; // not used by this implementation

            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }

              if (ArrayBuffer.isView(value)) {
                return fromArrayLike(value);
              }

              if (value == null) {
                throw TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                    "or Array-like Object. Received type " +
                    typeof value,
                );
              }

              if (isInstance(value, ArrayBuffer) || (value && isInstance(value.buffer, ArrayBuffer))) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }

              if (typeof value === "number") {
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              }

              var valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer.from(valueOf, encodingOrOffset, length);
              }

              var b = fromObject(value);
              if (b) return b;

              if (
                typeof Symbol !== "undefined" &&
                Symbol.toPrimitive != null &&
                typeof value[Symbol.toPrimitive] === "function"
              ) {
                return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
              }

              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                  "or Array-like Object. Received type " +
                  typeof value,
              );
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };

            // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
            // https://github.com/feross/buffer/pull/148
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;

            function assertSize(size) {
              if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size < 0) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
            }

            function alloc(size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(size);
              }
              if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === "string"
                  ? createBuffer(size).fill(fill, encoding)
                  : createBuffer(size).fill(fill);
              }
              return createBuffer(size);
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
              return alloc(size, fill, encoding);
            };

            function allocUnsafe(size) {
              assertSize(size);
              return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
              return allocUnsafe(size);
            };
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
              return allocUnsafe(size);
            };

            function fromString(string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }

              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }

              var length = byteLength(string, encoding) | 0;
              var buf = createBuffer(length);

              var actual = buf.write(string, encoding);

              if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                buf = buf.slice(0, actual);
              }

              return buf;
            }

            function fromArrayLike(array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              var buf = createBuffer(length);
              for (var i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255;
              }
              return buf;
            }

            function fromArrayBuffer(array, byteOffset, length) {
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }

              var buf;
              if (byteOffset === undefined && length === undefined) {
                buf = new Uint8Array(array);
              } else if (length === undefined) {
                buf = new Uint8Array(array, byteOffset);
              } else {
                buf = new Uint8Array(array, byteOffset, length);
              }

              // Return an augmented `Uint8Array` instance
              buf.__proto__ = Buffer.prototype;
              return buf;
            }

            function fromObject(obj) {
              if (Buffer.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);

                if (buf.length === 0) {
                  return buf;
                }

                obj.copy(buf, 0, 0, len);
                return buf;
              }

              if (obj.length !== undefined) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }

              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }

            function checked(length) {
              // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
              // length is NaN (which is otherwise coerced to zero.)
              if (length >= K_MAX_LENGTH) {
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum " + "size: 0x" + K_MAX_LENGTH.toString(16) + " bytes",
                );
              }
              return length | 0;
            }

            function SlowBuffer(length) {
              if (+length != length) {
                // eslint-disable-line eqeqeq
                length = 0;
              }
              return Buffer.alloc(+length);
            }

            Buffer.isBuffer = function isBuffer(b) {
              return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
            };

            Buffer.compare = function compare(a, b) {
              if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
              if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
              if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              }

              if (a === b) return 0;

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }

              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };

            Buffer.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };

            Buffer.concat = function concat(list, length) {
              if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }

              if (list.length === 0) {
                return Buffer.alloc(0);
              }

              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (isInstance(buf, Uint8Array)) {
                  buf = Buffer.from(buf);
                }
                if (!Buffer.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };

            function byteLength(string, encoding) {
              if (Buffer.isBuffer(string)) {
                return string.length;
              }
              if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                    "Received type " +
                    typeof string,
                );
              }

              var len = string.length;
              var mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0) return 0;

              // Use a for loop to avoid recursion
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.byteLength = byteLength;

            function slowToString(encoding, start, end) {
              var loweredCase = false;

              // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
              // property of a typed array.

              // This behaves neither like String nor Uint8Array in that we set start/end
              // to their upper/lower bounds if the value passed is out of range.
              // undefined is handled specially as per ECMA-262 6th Edition,
              // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
              if (start === undefined || start < 0) {
                start = 0;
              }
              // Return early if start > this.length. Done here to prevent potential uint32
              // coercion fail below.
              if (start > this.length) {
                return "";
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return "";
              }

              // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return "";
              }

              if (!encoding) encoding = "utf8";

              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }

            // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
            // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
            // reliably in a browserify context because there could be multiple different
            // copies of the 'buffer' package in use. This method works even for Buffer
            // instances that were created from another copy of the `buffer` package.
            // See: https://github.com/feross/buffer/issues/154
            Buffer.prototype._isBuffer = true;

            function swap(b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };

            Buffer.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };

            Buffer.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };

            Buffer.prototype.toString = function toString() {
              var length = this.length;
              if (length === 0) return "";
              if (arguments.length === 0) return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };

            Buffer.prototype.toLocaleString = Buffer.prototype.toString;

            Buffer.prototype.equals = function equals(b) {
              if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
              if (this === b) return true;
              return Buffer.compare(this, b) === 0;
            };

            Buffer.prototype.inspect = function inspect() {
              var str = "";
              var max = exports.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max)
                .replace(/(.{2})/g, "$1 ")
                .trim();
              if (this.length > max) str += " ... ";
              return "<Buffer " + str + ">";
            };

            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer.from(target, target.offset, target.byteLength);
              }
              if (!Buffer.isBuffer(target)) {
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof target,
                );
              }

              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;

              if (this === target) return 0;

              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);

              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }

              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
              // Empty buffer means no match
              if (buffer.length === 0) return -1;

              // Normalize byteOffset
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }
              byteOffset = +byteOffset; // Coerce to Number.
              if (numberIsNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : buffer.length - 1;
              }

              // Normalize byteOffset: negative offsets start from the end of the buffer
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1;
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1;
              }

              // Normalize val
              if (typeof val === "string") {
                val = Buffer.from(val, encoding);
              }

              // Finally, search either indexOf (if dir is true) or lastIndexOf
              if (Buffer.isBuffer(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 0xff; // Search for a byte value [0-255]
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }

              throw new TypeError("val must be string, number or Buffer");
            }

            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read(buf, i) {
                if (indexSize === 1) {
                  return buf[i];
                } else {
                  return buf.readUInt16BE(i * indexSize);
                }
              }

              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found) return i;
                }
              }

              return -1;
            }

            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };

            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };

            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };

            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }

              var strLen = string.length;

              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed)) return i;
                buf[offset + i] = parsed;
              }
              return i;
            }

            function utf8Write(buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }

            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }

            function latin1Write(buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length);
            }

            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }

            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }

            Buffer.prototype.write = function write(string, offset, length, encoding) {
              // Buffer#write(string)
              if (offset === undefined) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
                // Buffer#write(string, encoding)
              } else if (length === undefined && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
                // Buffer#write(string, offset[, length][, encoding])
              } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding === undefined) encoding = "utf8";
                } else {
                  encoding = length;
                  length = undefined;
                }
              } else {
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining) length = remaining;

              if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }

              if (!encoding) encoding = "utf8";

              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);

                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);

                  case "ascii":
                    return asciiWrite(this, string, offset, length);

                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset, length);

                  case "base64":
                    // Warning: maxLength not taken into account in base64Write
                    return base64Write(this, string, offset, length);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0),
              };
            };

            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }

            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];

              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 0xc0) === 0x80) {
                        tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                        if (tempCodePoint > 0x7f) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {
                        tempCodePoint = ((firstByte & 0xf) << 0xc) | ((secondByte & 0x3f) << 0x6) | (thirdByte & 0x3f);
                        if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {
                        tempCodePoint =
                          ((firstByte & 0xf) << 0x12) |
                          ((secondByte & 0x3f) << 0xc) |
                          ((thirdByte & 0x3f) << 0x6) |
                          (fourthByte & 0x3f);
                        if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  // we did not generate a valid codePoint so insert a
                  // replacement char (U+FFFD) and advance only 1 byte
                  codePoint = 0xfffd;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xffff) {
                  // encode to utf16 (surrogate pair dance)
                  codePoint -= 0x10000;
                  res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                  codePoint = 0xdc00 | (codePoint & 0x3ff);
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray(res);
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
              }

              // Decode in chunks to avoid "call stack size exceeded".
              var res = "";
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)));
              }
              return res;
            }

            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7f);
              }
              return ret;
            }

            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }

            function hexSlice(buf, start, end) {
              var len = buf.length;

              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;

              var out = "";
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out;
            }

            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }

            Buffer.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;

              var newBuf = this.subarray(start, end);
              // Return an augmented `Uint8Array` instance
              newBuf.__proto__ = Buffer.prototype;
              return newBuf;
            };

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
              if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
            }

            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val;
            };

            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val;
            };

            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset];
            };

            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8);
            };

            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1];
            };

            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + this[offset + 3] * 0x1000000;
            };

            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return this[offset] * 0x1000000 + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
            };

            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val;
            };

            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val;
            };

            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return this[offset];
              return (0xff - this[offset] + 1) * -1;
            };

            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return val & 0x8000 ? val | 0xffff0000 : val;
            };

            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return val & 0x8000 ? val | 0xffff0000 : val;
            };

            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
            };

            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3];
            };

            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };

            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };

            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };

            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };

            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length) throw new RangeError("Index out of range");
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xff;
              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xff;
              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
              this[offset] = value & 0xff;
              return offset + 1;
            };

            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };

            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
              return offset + 2;
            };

            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 0xff;
              return offset + 4;
            };

            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
              return offset + 4;
            };

            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xff;
              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xff;
              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = value & 0xff;
              return offset + 1;
            };

            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };

            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
              return offset + 2;
            };

            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
              return offset + 4;
            };

            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
              return offset + 4;
            };

            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length) throw new RangeError("Index out of range");
              if (offset < 0) throw new RangeError("Index out of range");
            }

            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert);
            };

            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert);
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
              if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;

              // Copy 0 bytes; we're done
              if (end === start) return 0;
              if (target.length === 0 || this.length === 0) return 0;

              // Fatal error conditions
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
              if (end < 0) throw new RangeError("sourceEnd out of bounds");

              // Are we oob?
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;

              if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                // Use built-in when available, missing from IE11
                this.copyWithin(targetStart, start, end);
              } else if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (var i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
              }

              return len;
            };

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
              // Handle string cases:
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (encoding !== undefined && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if ((encoding === "utf8" && code < 128) || encoding === "latin1") {
                    // Fast path: If `val` fits into a single byte, use that numeric value.
                    val = code;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }

              // Invalid ranges are not set to a default, so can range check early.
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }

              if (end <= start) {
                return this;
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;

              if (!val) val = 0;

              var i;
              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                var len = bytes.length;
                if (len === 0) {
                  throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this;
            };

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

            function base64clean(str) {
              // Node takes equal signs as end of the Base64 encoding
              str = str.split("=")[0];
              // Node strips out invalid characters like \n and \t from the string, base64-js does not
              str = str.trim().replace(INVALID_BASE64_RE, "");
              // Node converts strings with length < 2 to ''
              if (str.length < 2) return "";
              // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }

            function toHex(n) {
              if (n < 16) return "0" + n.toString(16);
              return n.toString(16);
            }

            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                // is surrogate component
                if (codePoint > 0xd7ff && codePoint < 0xe000) {
                  // last char was a lead
                  if (!leadSurrogate) {
                    // no lead yet
                    if (codePoint > 0xdbff) {
                      // unexpected trail
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                      continue;
                    } else if (i + 1 === length) {
                      // unpaired lead
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                      continue;
                    }

                    // valid lead
                    leadSurrogate = codePoint;

                    continue;
                  }

                  // 2 leads in a row
                  if (codePoint < 0xdc00) {
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                    leadSurrogate = codePoint;
                    continue;
                  }

                  // valid surrogate pair
                  codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
                } else if (leadSurrogate) {
                  // valid bmp char, but last char was a lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                }

                leadSurrogate = null;

                // encode utf8
                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break;
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break;
                  bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break;
                  bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break;
                  bytes.push(
                    (codePoint >> 0x12) | 0xf0,
                    ((codePoint >> 0xc) & 0x3f) | 0x80,
                    ((codePoint >> 0x6) & 0x3f) | 0x80,
                    (codePoint & 0x3f) | 0x80,
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }

              return bytes;
            }

            function asciiToBytes(str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xff);
              }
              return byteArray;
            }

            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break;

                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray;
            }

            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }

            function blitBuffer(src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
              }
              return i;
            }

            // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
            // the `instanceof` check but they should be treated as of that type.
            // See: https://github.com/feross/buffer/issues/166
            function isInstance(obj, type) {
              return (
                obj instanceof type ||
                (obj != null &&
                  obj.constructor != null &&
                  obj.constructor.name != null &&
                  obj.constructor.name === type.name)
              );
            }
            function numberIsNaN(obj) {
              // For IE11 support
              return obj !== obj; // eslint-disable-line no-self-compare
            }
          }).call(this);
        }).call(this, require("buffer").Buffer);
      },
      { "base64-js": 130, buffer: 132, ieee754: 138 },
    ],
    133: [
      function (require, module, exports) {
        module.exports = {
          100: "Continue",
          101: "Switching Protocols",
          102: "Processing",
          200: "OK",
          201: "Created",
          202: "Accepted",
          203: "Non-Authoritative Information",
          204: "No Content",
          205: "Reset Content",
          206: "Partial Content",
          207: "Multi-Status",
          208: "Already Reported",
          226: "IM Used",
          300: "Multiple Choices",
          301: "Moved Permanently",
          302: "Found",
          303: "See Other",
          304: "Not Modified",
          305: "Use Proxy",
          307: "Temporary Redirect",
          308: "Permanent Redirect",
          400: "Bad Request",
          401: "Unauthorized",
          402: "Payment Required",
          403: "Forbidden",
          404: "Not Found",
          405: "Method Not Allowed",
          406: "Not Acceptable",
          407: "Proxy Authentication Required",
          408: "Request Timeout",
          409: "Conflict",
          410: "Gone",
          411: "Length Required",
          412: "Precondition Failed",
          413: "Payload Too Large",
          414: "URI Too Long",
          415: "Unsupported Media Type",
          416: "Range Not Satisfiable",
          417: "Expectation Failed",
          418: "I'm a teapot",
          421: "Misdirected Request",
          422: "Unprocessable Entity",
          423: "Locked",
          424: "Failed Dependency",
          425: "Unordered Collection",
          426: "Upgrade Required",
          428: "Precondition Required",
          429: "Too Many Requests",
          431: "Request Header Fields Too Large",
          451: "Unavailable For Legal Reasons",
          500: "Internal Server Error",
          501: "Not Implemented",
          502: "Bad Gateway",
          503: "Service Unavailable",
          504: "Gateway Timeout",
          505: "HTTP Version Not Supported",
          506: "Variant Also Negotiates",
          507: "Insufficient Storage",
          508: "Loop Detected",
          509: "Bandwidth Limit Exceeded",
          510: "Not Extended",
          511: "Network Authentication Required",
        };
      },
      {},
    ],
    134: [
      function (require, module, exports) {
        (function (process, global) {
          (function () {
            "use strict";

            var next =
              (global.process && process.nextTick) ||
              global.setImmediate ||
              function (f) {
                setTimeout(f, 0);
              };

            module.exports = function maybe(cb, promise) {
              if (cb) {
                promise.then(
                  function (result) {
                    next(function () {
                      cb(null, result);
                    });
                  },
                  function (err) {
                    next(function () {
                      cb(err);
                    });
                  },
                );
                return undefined;
              } else {
                return promise;
              }
            };
          }).call(this);
        }).call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      { _process: 172 },
    ],
    135: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var objectCreate = Object.create || objectCreatePolyfill;
        var objectKeys = Object.keys || objectKeysPolyfill;
        var bind = Function.prototype.bind || functionBindPolyfill;

        function EventEmitter() {
          if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          }

          this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;

        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10;

        var hasDefineProperty;
        try {
          var o = {};
          if (Object.defineProperty) Object.defineProperty(o, "x", { value: 0 });
          hasDefineProperty = o.x === 0;
        } catch (err) {
          hasDefineProperty = false;
        }
        if (hasDefineProperty) {
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function () {
              return defaultMaxListeners;
            },
            set: function (arg) {
              // check whether the input is a positive number (whose value is zero or
              // greater and not a NaN).
              if (typeof arg !== "number" || arg < 0 || arg !== arg)
                throw new TypeError('"defaultMaxListeners" must be a positive number');
              defaultMaxListeners = arg;
            },
          });
        } else {
          EventEmitter.defaultMaxListeners = defaultMaxListeners;
        }

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
          this._maxListeners = n;
          return this;
        };

        function $getMaxListeners(that) {
          if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this);
        };

        // These standalone emit* functions are used to optimize calling of event
        // handlers for fast cases because emit() itself often has a variable number of
        // arguments and can be deoptimized because of that. These functions always have
        // the same number of arguments and thus do not get deoptimized, so the code
        // inside them can execute faster.
        function emitNone(handler, isFn, self) {
          if (isFn) handler.call(self);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].call(self);
          }
        }
        function emitOne(handler, isFn, self, arg1) {
          if (isFn) handler.call(self, arg1);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
          }
        }
        function emitTwo(handler, isFn, self, arg1, arg2) {
          if (isFn) handler.call(self, arg1, arg2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
          }
        }
        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
          if (isFn) handler.call(self, arg1, arg2, arg3);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
          }
        }

        function emitMany(handler, isFn, self, args) {
          if (isFn) handler.apply(self, args);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
          }
        }

        EventEmitter.prototype.emit = function emit(type) {
          var er, handler, len, args, i, events;
          var doError = type === "error";

          events = this._events;
          if (events) doError = doError && events.error == null;
          else if (!doError) return false;

          // If there is no 'error' event listener then throw.
          if (doError) {
            if (arguments.length > 1) er = arguments[1];
            if (er instanceof Error) {
              throw er; // Unhandled 'error' event
            } else {
              // At least give some kind of context to the user
              var err = new Error('Unhandled "error" event. (' + er + ")");
              err.context = er;
              throw err;
            }
            return false;
          }

          handler = events[type];

          if (!handler) return false;

          var isFn = typeof handler === "function";
          len = arguments.length;
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this);
              break;
            case 2:
              emitOne(handler, isFn, this, arguments[1]);
              break;
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2]);
              break;
            case 4:
              emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
              break;
            // slower
            default:
              args = new Array(len - 1);
              for (i = 1; i < len; i++) args[i - 1] = arguments[i];
              emitMany(handler, isFn, this, args);
          }

          return true;
        };

        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;

          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');

          events = target._events;
          if (!events) {
            events = target._events = objectCreate(null);
            target._eventsCount = 0;
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener) {
              target.emit("newListener", type, listener.listener ? listener.listener : listener);

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events;
            }
            existing = events[type];
          }

          if (!existing) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              // Adding the second element, need to change to array.
              existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            } else {
              // If we've already got an array, just append.
              if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
            }

            // Check for listener leak
            if (!existing.warned) {
              m = $getMaxListeners(target);
              if (m && m > 0 && existing.length > m) {
                existing.warned = true;
                var w = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    existing.length +
                    ' "' +
                    String(type) +
                    '" listeners ' +
                    "added. Use emitter.setMaxListeners() to " +
                    "increase limit.",
                );
                w.name = "MaxListenersExceededWarning";
                w.emitter = target;
                w.type = type;
                w.count = existing.length;
                if (typeof console === "object" && console.warn) {
                  console.warn("%s: %s", w.name, w.message);
                }
              }
            }
          }

          return target;
        }

        EventEmitter.prototype.addListener = function addListener(type, listener) {
          return _addListener(this, type, listener, false);
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener;

        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            switch (arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);
              case 3:
                return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
              default:
                var args = new Array(arguments.length);
                for (var i = 0; i < args.length; ++i) args[i] = arguments[i];
                this.listener.apply(this.target, args);
            }
          }
        }

        function _onceWrap(target, type, listener) {
          var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
          var wrapped = bind.call(onceWrapper, state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }

        EventEmitter.prototype.once = function once(type, listener) {
          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };

        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events) return this;

          list = events[type];
          if (!list) return this;

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0) this._events = objectCreate(null);
            else {
              delete events[type];
              if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0) return this;

            if (position === 0) list.shift();
            else spliceOne(list, position);

            if (list.length === 1) events[type] = list[0];

            if (events.removeListener) this.emit("removeListener", type, originalListener || listener);
          }

          return this;
        };

        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
          var listeners, events, i;

          events = this._events;
          if (!events) return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = objectCreate(null);
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0) this._events = objectCreate(null);
              else delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = objectKeys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener") continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = objectCreate(null);
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }

          return this;
        };

        function _listeners(target, type, unwrap) {
          var events = target._events;

          if (!events) return [];

          var evlistener = events[type];
          if (!evlistener) return [];

          if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];

          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };

        EventEmitter.listenerCount = function (emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };

        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;

          if (events) {
            var evlistener = events[type];

            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener) {
              return evlistener.length;
            }
          }

          return 0;
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };

        // About 1.5x faster than the two-arg version of Array#splice().
        function spliceOne(list, index) {
          for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
          list.pop();
        }

        function arrayClone(arr, n) {
          var copy = new Array(n);
          for (var i = 0; i < n; ++i) copy[i] = arr[i];
          return copy;
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }

        function objectCreatePolyfill(proto) {
          var F = function () {};
          F.prototype = proto;
          return new F();
        }
        function objectKeysPolyfill(obj) {
          var keys = [];
          for (var k in obj)
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              keys.push(k);
            }
          return k;
        }
        function functionBindPolyfill(context) {
          var fn = this;
          return function () {
            return fn.apply(context, arguments);
          };
        }
      },
      {},
    ],
    136: [
      function (require, module, exports) {
        "use strict";

        // do not edit .js files directly - edit src/index.jst

        module.exports = function equal(a, b) {
          if (a === b) return true;

          if (a && b && typeof a == "object" && typeof b == "object") {
            if (a.constructor !== b.constructor) return false;

            var length, i, keys;
            if (Array.isArray(a)) {
              length = a.length;
              if (length != b.length) return false;
              for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false;
              return true;
            }

            if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
            if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
            if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

            keys = Object.keys(a);
            length = keys.length;
            if (length !== Object.keys(b).length) return false;

            for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

            for (i = length; i-- !== 0; ) {
              var key = keys[i];

              if (!equal(a[key], b[key])) return false;
            }

            return true;
          }

          // true if both NaN, false otherwise
          return a !== a && b !== b;
        };
      },
      {},
    ],
    137: [
      function (require, module, exports) {
        var http = require("http");
        var url = require("url");

        var https = module.exports;

        for (var key in http) {
          if (http.hasOwnProperty(key)) https[key] = http[key];
        }

        https.request = function (params, cb) {
          params = validateParams(params);
          return http.request.call(this, params, cb);
        };

        https.get = function (params, cb) {
          params = validateParams(params);
          return http.get.call(this, params, cb);
        };

        function validateParams(params) {
          if (typeof params === "string") {
            params = url.parse(params);
          }
          if (!params.protocol) {
            params.protocol = "https:";
          }
          if (params.protocol !== "https:") {
            throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
          }
          return params;
        }
      },
      { http: 192, url: 199 },
    ],
    138: [
      function (require, module, exports) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];

          i += d;

          e = s & ((1 << -nBits) - 1);
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

          m = e & ((1 << -nBits) - 1);
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

          value = Math.abs(value);

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }

            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }

          for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

          e = (e << mLen) | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

          buffer[offset + i - d] |= s * 128;
        };
      },
      {},
    ],
    139: [
      function (require, module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              });
            }
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function () {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      },
      {},
    ],
    140: [
      function (require, module, exports) {
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */

        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function (obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };

        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }

        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
        }
      },
      {},
    ],
    141: [
      function (require, module, exports) {
        "use strict";

        var yaml = require("./lib/js-yaml.js");

        module.exports = yaml;
      },
      { "./lib/js-yaml.js": 142 },
    ],
    142: [
      function (require, module, exports) {
        "use strict";

        var loader = require("./js-yaml/loader");
        var dumper = require("./js-yaml/dumper");

        function deprecated(name) {
          return function () {
            throw new Error("Function " + name + " is deprecated and cannot be used.");
          };
        }

        module.exports.Type = require("./js-yaml/type");
        module.exports.Schema = require("./js-yaml/schema");
        module.exports.FAILSAFE_SCHEMA = require("./js-yaml/schema/failsafe");
        module.exports.JSON_SCHEMA = require("./js-yaml/schema/json");
        module.exports.CORE_SCHEMA = require("./js-yaml/schema/core");
        module.exports.DEFAULT_SAFE_SCHEMA = require("./js-yaml/schema/default_safe");
        module.exports.DEFAULT_FULL_SCHEMA = require("./js-yaml/schema/default_full");
        module.exports.load = loader.load;
        module.exports.loadAll = loader.loadAll;
        module.exports.safeLoad = loader.safeLoad;
        module.exports.safeLoadAll = loader.safeLoadAll;
        module.exports.dump = dumper.dump;
        module.exports.safeDump = dumper.safeDump;
        module.exports.YAMLException = require("./js-yaml/exception");

        // Deprecated schema names from JS-YAML 2.0.x
        module.exports.MINIMAL_SCHEMA = require("./js-yaml/schema/failsafe");
        module.exports.SAFE_SCHEMA = require("./js-yaml/schema/default_safe");
        module.exports.DEFAULT_SCHEMA = require("./js-yaml/schema/default_full");

        // Deprecated functions from JS-YAML 1.x.x
        module.exports.scan = deprecated("scan");
        module.exports.parse = deprecated("parse");
        module.exports.compose = deprecated("compose");
        module.exports.addConstructor = deprecated("addConstructor");
      },
      {
        "./js-yaml/dumper": 144,
        "./js-yaml/exception": 145,
        "./js-yaml/loader": 146,
        "./js-yaml/schema": 148,
        "./js-yaml/schema/core": 149,
        "./js-yaml/schema/default_full": 150,
        "./js-yaml/schema/default_safe": 151,
        "./js-yaml/schema/failsafe": 152,
        "./js-yaml/schema/json": 153,
        "./js-yaml/type": 154,
      },
    ],
    143: [
      function (require, module, exports) {
        "use strict";

        function isNothing(subject) {
          return typeof subject === "undefined" || subject === null;
        }

        function isObject(subject) {
          return typeof subject === "object" && subject !== null;
        }

        function toArray(sequence) {
          if (Array.isArray(sequence)) return sequence;
          else if (isNothing(sequence)) return [];

          return [sequence];
        }

        function extend(target, source) {
          var index, length, key, sourceKeys;

          if (source) {
            sourceKeys = Object.keys(source);

            for (index = 0, length = sourceKeys.length; index < length; index += 1) {
              key = sourceKeys[index];
              target[key] = source[key];
            }
          }

          return target;
        }

        function repeat(string, count) {
          var result = "",
            cycle;

          for (cycle = 0; cycle < count; cycle += 1) {
            result += string;
          }

          return result;
        }

        function isNegativeZero(number) {
          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
        }

        module.exports.isNothing = isNothing;
        module.exports.isObject = isObject;
        module.exports.toArray = toArray;
        module.exports.repeat = repeat;
        module.exports.isNegativeZero = isNegativeZero;
        module.exports.extend = extend;
      },
      {},
    ],
    144: [
      function (require, module, exports) {
        "use strict";

        /*eslint-disable no-use-before-define*/

        var common = require("./common");
        var YAMLException = require("./exception");
        var DEFAULT_FULL_SCHEMA = require("./schema/default_full");
        var DEFAULT_SAFE_SCHEMA = require("./schema/default_safe");

        var _toString = Object.prototype.toString;
        var _hasOwnProperty = Object.prototype.hasOwnProperty;

        var CHAR_TAB = 0x09; /* Tab */
        var CHAR_LINE_FEED = 0x0a; /* LF */
        var CHAR_CARRIAGE_RETURN = 0x0d; /* CR */
        var CHAR_SPACE = 0x20; /* Space */
        var CHAR_EXCLAMATION = 0x21; /* ! */
        var CHAR_DOUBLE_QUOTE = 0x22; /* " */
        var CHAR_SHARP = 0x23; /* # */
        var CHAR_PERCENT = 0x25; /* % */
        var CHAR_AMPERSAND = 0x26; /* & */
        var CHAR_SINGLE_QUOTE = 0x27; /* ' */
        var CHAR_ASTERISK = 0x2a; /* * */
        var CHAR_COMMA = 0x2c; /* , */
        var CHAR_MINUS = 0x2d; /* - */
        var CHAR_COLON = 0x3a; /* : */
        var CHAR_EQUALS = 0x3d; /* = */
        var CHAR_GREATER_THAN = 0x3e; /* > */
        var CHAR_QUESTION = 0x3f; /* ? */
        var CHAR_COMMERCIAL_AT = 0x40; /* @ */
        var CHAR_LEFT_SQUARE_BRACKET = 0x5b; /* [ */
        var CHAR_RIGHT_SQUARE_BRACKET = 0x5d; /* ] */
        var CHAR_GRAVE_ACCENT = 0x60; /* ` */
        var CHAR_LEFT_CURLY_BRACKET = 0x7b; /* { */
        var CHAR_VERTICAL_LINE = 0x7c; /* | */
        var CHAR_RIGHT_CURLY_BRACKET = 0x7d; /* } */

        var ESCAPE_SEQUENCES = {};

        ESCAPE_SEQUENCES[0x00] = "\\0";
        ESCAPE_SEQUENCES[0x07] = "\\a";
        ESCAPE_SEQUENCES[0x08] = "\\b";
        ESCAPE_SEQUENCES[0x09] = "\\t";
        ESCAPE_SEQUENCES[0x0a] = "\\n";
        ESCAPE_SEQUENCES[0x0b] = "\\v";
        ESCAPE_SEQUENCES[0x0c] = "\\f";
        ESCAPE_SEQUENCES[0x0d] = "\\r";
        ESCAPE_SEQUENCES[0x1b] = "\\e";
        ESCAPE_SEQUENCES[0x22] = '\\"';
        ESCAPE_SEQUENCES[0x5c] = "\\\\";
        ESCAPE_SEQUENCES[0x85] = "\\N";
        ESCAPE_SEQUENCES[0xa0] = "\\_";
        ESCAPE_SEQUENCES[0x2028] = "\\L";
        ESCAPE_SEQUENCES[0x2029] = "\\P";

        var DEPRECATED_BOOLEANS_SYNTAX = [
          "y",
          "Y",
          "yes",
          "Yes",
          "YES",
          "on",
          "On",
          "ON",
          "n",
          "N",
          "no",
          "No",
          "NO",
          "off",
          "Off",
          "OFF",
        ];

        function compileStyleMap(schema, map) {
          var result, keys, index, length, tag, style, type;

          if (map === null) return {};

          result = {};
          keys = Object.keys(map);

          for (index = 0, length = keys.length; index < length; index += 1) {
            tag = keys[index];
            style = String(map[tag]);

            if (tag.slice(0, 2) === "!!") {
              tag = "tag:yaml.org,2002:" + tag.slice(2);
            }
            type = schema.compiledTypeMap["fallback"][tag];

            if (type && _hasOwnProperty.call(type.styleAliases, style)) {
              style = type.styleAliases[style];
            }

            result[tag] = style;
          }

          return result;
        }

        function encodeHex(character) {
          var string, handle, length;

          string = character.toString(16).toUpperCase();

          if (character <= 0xff) {
            handle = "x";
            length = 2;
          } else if (character <= 0xffff) {
            handle = "u";
            length = 4;
          } else if (character <= 0xffffffff) {
            handle = "U";
            length = 8;
          } else {
            throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
          }

          return "\\" + handle + common.repeat("0", length - string.length) + string;
        }

        function State(options) {
          this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
          this.indent = Math.max(1, options["indent"] || 2);
          this.noArrayIndent = options["noArrayIndent"] || false;
          this.skipInvalid = options["skipInvalid"] || false;
          this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
          this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
          this.sortKeys = options["sortKeys"] || false;
          this.lineWidth = options["lineWidth"] || 80;
          this.noRefs = options["noRefs"] || false;
          this.noCompatMode = options["noCompatMode"] || false;
          this.condenseFlow = options["condenseFlow"] || false;

          this.implicitTypes = this.schema.compiledImplicit;
          this.explicitTypes = this.schema.compiledExplicit;

          this.tag = null;
          this.result = "";

          this.duplicates = [];
          this.usedDuplicates = null;
        }

        // Indents every line in a string. Empty lines (\n only) are not indented.
        function indentString(string, spaces) {
          var ind = common.repeat(" ", spaces),
            position = 0,
            next = -1,
            result = "",
            line,
            length = string.length;

          while (position < length) {
            next = string.indexOf("\n", position);
            if (next === -1) {
              line = string.slice(position);
              position = length;
            } else {
              line = string.slice(position, next + 1);
              position = next + 1;
            }

            if (line.length && line !== "\n") result += ind;

            result += line;
          }

          return result;
        }

        function generateNextLine(state, level) {
          return "\n" + common.repeat(" ", state.indent * level);
        }

        function testImplicitResolving(state, str) {
          var index, length, type;

          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
            type = state.implicitTypes[index];

            if (type.resolve(str)) {
              return true;
            }
          }

          return false;
        }

        // [33] s-white ::= s-space | s-tab
        function isWhitespace(c) {
          return c === CHAR_SPACE || c === CHAR_TAB;
        }

        // Returns true if the character can be printed without escaping.
        // From YAML 1.2: "any allowed characters known to be non-printable
        // should also be escaped. [However,] This isnt mandatory"
        // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
        function isPrintable(c) {
          return (
            (0x00020 <= c && c <= 0x00007e) ||
            (0x000a1 <= c && c <= 0x00d7ff && c !== 0x2028 && c !== 0x2029) ||
            (0x0e000 <= c && c <= 0x00fffd && c !== 0xfeff) /* BOM */ ||
            (0x10000 <= c && c <= 0x10ffff)
          );
        }

        // [34] ns-char ::= nb-char - s-white
        // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
        // [26] b-char  ::= b-line-feed | b-carriage-return
        // [24] b-line-feed       ::=     #xA    /* LF */
        // [25] b-carriage-return ::=     #xD    /* CR */
        // [3]  c-byte-order-mark ::=     #xFEFF
        function isNsChar(c) {
          return (
            isPrintable(c) &&
            !isWhitespace(c) &&
            // byte-order-mark
            c !== 0xfeff &&
            // b-char
            c !== CHAR_CARRIAGE_RETURN &&
            c !== CHAR_LINE_FEED
          );
        }

        // Simplified test for values allowed after the first character in plain style.
        function isPlainSafe(c, prev) {
          // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
          // where nb-char ::= c-printable - b-char - c-byte-order-mark.
          return (
            isPrintable(c) &&
            c !== 0xfeff &&
            // - c-flow-indicator
            c !== CHAR_COMMA &&
            c !== CHAR_LEFT_SQUARE_BRACKET &&
            c !== CHAR_RIGHT_SQUARE_BRACKET &&
            c !== CHAR_LEFT_CURLY_BRACKET &&
            c !== CHAR_RIGHT_CURLY_BRACKET &&
            // - ":" - "#"
            // /* An ns-char preceding */ "#"
            c !== CHAR_COLON &&
            (c !== CHAR_SHARP || (prev && isNsChar(prev)))
          );
        }

        // Simplified test for values allowed as the first character in plain style.
        function isPlainSafeFirst(c) {
          // Uses a subset of ns-char - c-indicator
          // where ns-char = nb-char - s-white.
          return (
            isPrintable(c) &&
            c !== 0xfeff &&
            !isWhitespace(c) && // - s-white
            // - (c-indicator ::=
            // - | ? | : | , | [ | ] | { | }
            c !== CHAR_MINUS &&
            c !== CHAR_QUESTION &&
            c !== CHAR_COLON &&
            c !== CHAR_COMMA &&
            c !== CHAR_LEFT_SQUARE_BRACKET &&
            c !== CHAR_RIGHT_SQUARE_BRACKET &&
            c !== CHAR_LEFT_CURLY_BRACKET &&
            c !== CHAR_RIGHT_CURLY_BRACKET &&
            // | # | & | * | ! | | | = | > | ' | "
            c !== CHAR_SHARP &&
            c !== CHAR_AMPERSAND &&
            c !== CHAR_ASTERISK &&
            c !== CHAR_EXCLAMATION &&
            c !== CHAR_VERTICAL_LINE &&
            c !== CHAR_EQUALS &&
            c !== CHAR_GREATER_THAN &&
            c !== CHAR_SINGLE_QUOTE &&
            c !== CHAR_DOUBLE_QUOTE &&
            // | % | @ | `)
            c !== CHAR_PERCENT &&
            c !== CHAR_COMMERCIAL_AT &&
            c !== CHAR_GRAVE_ACCENT
          );
        }

        // Determines whether block indentation indicator is required.
        function needIndentIndicator(string) {
          var leadingSpaceRe = /^\n* /;
          return leadingSpaceRe.test(string);
        }

        var STYLE_PLAIN = 1,
          STYLE_SINGLE = 2,
          STYLE_LITERAL = 3,
          STYLE_FOLDED = 4,
          STYLE_DOUBLE = 5;

        // Determines which scalar styles are possible and returns the preferred style.
        // lineWidth = -1 => no limit.
        // Pre-conditions: str.length > 0.
        // Post-conditions:
        //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
        //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
        //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
          var i;
          var char, prev_char;
          var hasLineBreak = false;
          var hasFoldableLine = false; // only checked if shouldTrackWidth
          var shouldTrackWidth = lineWidth !== -1;
          var previousLineBreak = -1; // count the first line correctly
          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));

          if (singleLineOnly) {
            // Case: no block styles.
            // Check for disallowed characters to rule out plain and single.
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
              plain = plain && isPlainSafe(char, prev_char);
            }
          } else {
            // Case: block styles permitted.
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                  hasFoldableLine =
                    hasFoldableLine ||
                    // Foldable line = too long, and not more-indented.
                    (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
                  previousLineBreak = i;
                }
              } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
              plain = plain && isPlainSafe(char, prev_char);
            }
            // in case the end is missing a \n
            hasFoldableLine =
              hasFoldableLine ||
              (shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
          }
          // Although every style can represent \n without escaping, prefer block styles
          // for multiline, since they're more readable and they don't add empty lines.
          // Also prefer folding a super-long line.
          if (!hasLineBreak && !hasFoldableLine) {
            // Strings interpretable as another type have to be quoted;
            // e.g. the string 'true' vs. the boolean true.
            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
          }
          // Edge case: block indentation indicator can only have one digit.
          if (indentPerLevel > 9 && needIndentIndicator(string)) {
            return STYLE_DOUBLE;
          }
          // At this point we know block styles are valid.
          // Prefer literal style unless we want to fold.
          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
        }

        // Note: line breaking/folding is implemented for only the folded style.
        // NB. We drop the last trailing newline (if any) of a returned block scalar
        //  since the dumper adds its own newline. This always works:
        //     No ending newline => unaffected; already using strip "-" chomping.
        //     Ending newline    => removed then restored.
        //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
        function writeScalar(state, string, level, iskey) {
          state.dump = (function () {
            if (string.length === 0) {
              return "''";
            }
            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
              return "'" + string + "'";
            }

            var indent = state.indent * Math.max(1, level); // no 0-indent scalars
            // As indentation gets deeper, let the width decrease monotonically
            // to the lower bound min(state.lineWidth, 40).
            // Note that this implies
            //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
            //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
            // This behaves better than a constant minimum width which disallows narrower options,
            // or an indent threshold which causes the width to suddenly increase.
            var lineWidth =
              state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

            // Without knowing if keys are implicit/explicit, assume implicit for safety.
            var singleLineOnly =
              iskey ||
              // No block styles in flow mode.
              (state.flowLevel > -1 && level >= state.flowLevel);
            function testAmbiguity(string) {
              return testImplicitResolving(state, string);
            }

            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
              case STYLE_PLAIN:
                return string;
              case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
              case STYLE_LITERAL:
                return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
              case STYLE_FOLDED:
                return (
                  ">" +
                  blockHeader(string, state.indent) +
                  dropEndingNewline(indentString(foldString(string, lineWidth), indent))
                );
              case STYLE_DOUBLE:
                return '"' + escapeString(string, lineWidth) + '"';
              default:
                throw new YAMLException("impossible error: invalid scalar style");
            }
          })();
        }

        // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
        function blockHeader(string, indentPerLevel) {
          var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";

          // note the special case: the string '\n' counts as a "trailing" empty line.
          var clip = string[string.length - 1] === "\n";
          var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
          var chomp = keep ? "+" : clip ? "" : "-";

          return indentIndicator + chomp + "\n";
        }

        // (See the note for writeScalar.)
        function dropEndingNewline(string) {
          return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
        }

        // Note: a long line without a suitable break point will exceed the width limit.
        // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
        function foldString(string, width) {
          // In folded style, $k$ consecutive newlines output as $k+1$ newlines
          // unless they're before or after a more-indented line, or at the very
          // beginning or end, in which case $k$ maps to $k$.
          // Therefore, parse each chunk as newline(s) followed by a content line.
          var lineRe = /(\n+)([^\n]*)/g;

          // first line (possibly an empty line)
          var result = (function () {
            var nextLF = string.indexOf("\n");
            nextLF = nextLF !== -1 ? nextLF : string.length;
            lineRe.lastIndex = nextLF;
            return foldLine(string.slice(0, nextLF), width);
          })();
          // If we haven't reached the first content line yet, don't add an extra \n.
          var prevMoreIndented = string[0] === "\n" || string[0] === " ";
          var moreIndented;

          // rest of the lines
          var match;
          while ((match = lineRe.exec(string))) {
            var prefix = match[1],
              line = match[2];
            moreIndented = line[0] === " ";
            result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
            prevMoreIndented = moreIndented;
          }

          return result;
        }

        // Greedy line breaking.
        // Picks the longest line under the limit each time,
        // otherwise settles for the shortest line over the limit.
        // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
        function foldLine(line, width) {
          if (line === "" || line[0] === " ") return line;

          // Since a more-indented line adds a \n, breaks can't be followed by a space.
          var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
          var match;
          // start is an inclusive index. end, curr, and next are exclusive.
          var start = 0,
            end,
            curr = 0,
            next = 0;
          var result = "";

          // Invariants: 0 <= start <= length-1.
          //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
          // Inside the loop:
          //   A match implies length >= 2, so curr and next are <= length-2.
          while ((match = breakRe.exec(line))) {
            next = match.index;
            // maintain invariant: curr - start <= width
            if (next - start > width) {
              end = curr > start ? curr : next; // derive end <= length-2
              result += "\n" + line.slice(start, end);
              // skip the space that was output as \n
              start = end + 1; // derive start <= length-1
            }
            curr = next;
          }

          // By the invariants, start <= length-1, so there is something left over.
          // It is either the whole string or a part starting from non-whitespace.
          result += "\n";
          // Insert a break if the remainder is too long and there is a break available.
          if (line.length - start > width && curr > start) {
            result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
          } else {
            result += line.slice(start);
          }

          return result.slice(1); // drop extra \n joiner
        }

        // Escapes a double-quoted string.
        function escapeString(string) {
          var result = "";
          var char, nextChar;
          var escapeSeq;

          for (var i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
            if (char >= 0xd800 && char <= 0xdbff /* high surrogate */) {
              nextChar = string.charCodeAt(i + 1);
              if (nextChar >= 0xdc00 && nextChar <= 0xdfff /* low surrogate */) {
                // Combine the surrogate pair and store it escaped.
                result += encodeHex((char - 0xd800) * 0x400 + nextChar - 0xdc00 + 0x10000);
                // Advance index one extra since we already used that char here.
                i++;
                continue;
              }
            }
            escapeSeq = ESCAPE_SEQUENCES[char];
            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
          }

          return result;
        }

        function writeFlowSequence(state, level, object) {
          var _result = "",
            _tag = state.tag,
            index,
            length;

          for (index = 0, length = object.length; index < length; index += 1) {
            // Write only valid elements.
            if (writeNode(state, level, object[index], false, false)) {
              if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
              _result += state.dump;
            }
          }

          state.tag = _tag;
          state.dump = "[" + _result + "]";
        }

        function writeBlockSequence(state, level, object, compact) {
          var _result = "",
            _tag = state.tag,
            index,
            length;

          for (index = 0, length = object.length; index < length; index += 1) {
            // Write only valid elements.
            if (writeNode(state, level + 1, object[index], true, true)) {
              if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
              }

              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += "-";
              } else {
                _result += "- ";
              }

              _result += state.dump;
            }
          }

          state.tag = _tag;
          state.dump = _result || "[]"; // Empty sequence if no valid values.
        }

        function writeFlowMapping(state, level, object) {
          var _result = "",
            _tag = state.tag,
            objectKeyList = Object.keys(object),
            index,
            length,
            objectKey,
            objectValue,
            pairBuffer;

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = "";
            if (index !== 0) pairBuffer += ", ";

            if (state.condenseFlow) pairBuffer += '"';

            objectKey = objectKeyList[index];
            objectValue = object[objectKey];

            if (!writeNode(state, level, objectKey, false, false)) {
              continue; // Skip this pair because of invalid key;
            }

            if (state.dump.length > 1024) pairBuffer += "? ";

            pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");

            if (!writeNode(state, level, objectValue, false, false)) {
              continue; // Skip this pair because of invalid value.
            }

            pairBuffer += state.dump;

            // Both key and value are valid.
            _result += pairBuffer;
          }

          state.tag = _tag;
          state.dump = "{" + _result + "}";
        }

        function writeBlockMapping(state, level, object, compact) {
          var _result = "",
            _tag = state.tag,
            objectKeyList = Object.keys(object),
            index,
            length,
            objectKey,
            objectValue,
            explicitPair,
            pairBuffer;

          // Allow sorting keys so that the output file is deterministic
          if (state.sortKeys === true) {
            // Default sorting
            objectKeyList.sort();
          } else if (typeof state.sortKeys === "function") {
            // Custom sort function
            objectKeyList.sort(state.sortKeys);
          } else if (state.sortKeys) {
            // Something is wrong
            throw new YAMLException("sortKeys must be a boolean or a function");
          }

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = "";

            if (!compact || index !== 0) {
              pairBuffer += generateNextLine(state, level);
            }

            objectKey = objectKeyList[index];
            objectValue = object[objectKey];

            if (!writeNode(state, level + 1, objectKey, true, true, true)) {
              continue; // Skip this pair because of invalid key.
            }

            explicitPair = (state.tag !== null && state.tag !== "?") || (state.dump && state.dump.length > 1024);

            if (explicitPair) {
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += "?";
              } else {
                pairBuffer += "? ";
              }
            }

            pairBuffer += state.dump;

            if (explicitPair) {
              pairBuffer += generateNextLine(state, level);
            }

            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
              continue; // Skip this pair because of invalid value.
            }

            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += ":";
            } else {
              pairBuffer += ": ";
            }

            pairBuffer += state.dump;

            // Both key and value are valid.
            _result += pairBuffer;
          }

          state.tag = _tag;
          state.dump = _result || "{}"; // Empty mapping if no valid pairs.
        }

        function detectType(state, object, explicit) {
          var _result, typeList, index, length, type, style;

          typeList = explicit ? state.explicitTypes : state.implicitTypes;

          for (index = 0, length = typeList.length; index < length; index += 1) {
            type = typeList[index];

            if (
              (type.instanceOf || type.predicate) &&
              (!type.instanceOf || (typeof object === "object" && object instanceof type.instanceOf)) &&
              (!type.predicate || type.predicate(object))
            ) {
              state.tag = explicit ? type.tag : "?";

              if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;

                if (_toString.call(type.represent) === "[object Function]") {
                  _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                  _result = type.represent[style](object, style);
                } else {
                  throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                }

                state.dump = _result;
              }

              return true;
            }
          }

          return false;
        }

        // Serializes `object` and writes it to global `result`.
        // Returns true on success, or false on invalid object.
        //
        function writeNode(state, level, object, block, compact, iskey) {
          state.tag = null;
          state.dump = object;

          if (!detectType(state, object, false)) {
            detectType(state, object, true);
          }

          var type = _toString.call(state.dump);

          if (block) {
            block = state.flowLevel < 0 || state.flowLevel > level;
          }

          var objectOrArray = type === "[object Object]" || type === "[object Array]",
            duplicateIndex,
            duplicate;

          if (objectOrArray) {
            duplicateIndex = state.duplicates.indexOf(object);
            duplicate = duplicateIndex !== -1;
          }

          if ((state.tag !== null && state.tag !== "?") || duplicate || (state.indent !== 2 && level > 0)) {
            compact = false;
          }

          if (duplicate && state.usedDuplicates[duplicateIndex]) {
            state.dump = "*ref_" + duplicateIndex;
          } else {
            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
              state.usedDuplicates[duplicateIndex] = true;
            }
            if (type === "[object Object]") {
              if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + state.dump;
                }
              } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
              }
            } else if (type === "[object Array]") {
              var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
              if (block && state.dump.length !== 0) {
                writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + state.dump;
                }
              } else {
                writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
              }
            } else if (type === "[object String]") {
              if (state.tag !== "?") {
                writeScalar(state, state.dump, level, iskey);
              }
            } else {
              if (state.skipInvalid) return false;
              throw new YAMLException("unacceptable kind of an object to dump " + type);
            }

            if (state.tag !== null && state.tag !== "?") {
              state.dump = "!<" + state.tag + "> " + state.dump;
            }
          }

          return true;
        }

        function getDuplicateReferences(object, state) {
          var objects = [],
            duplicatesIndexes = [],
            index,
            length;

          inspectNode(object, objects, duplicatesIndexes);

          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
            state.duplicates.push(objects[duplicatesIndexes[index]]);
          }
          state.usedDuplicates = new Array(length);
        }

        function inspectNode(object, objects, duplicatesIndexes) {
          var objectKeyList, index, length;

          if (object !== null && typeof object === "object") {
            index = objects.indexOf(object);
            if (index !== -1) {
              if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
              }
            } else {
              objects.push(object);

              if (Array.isArray(object)) {
                for (index = 0, length = object.length; index < length; index += 1) {
                  inspectNode(object[index], objects, duplicatesIndexes);
                }
              } else {
                objectKeyList = Object.keys(object);

                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
              }
            }
          }
        }

        function dump(input, options) {
          options = options || {};

          var state = new State(options);

          if (!state.noRefs) getDuplicateReferences(input, state);

          if (writeNode(state, 0, input, true, true)) return state.dump + "\n";

          return "";
        }

        function safeDump(input, options) {
          return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }

        module.exports.dump = dump;
        module.exports.safeDump = safeDump;
      },
      { "./common": 143, "./exception": 145, "./schema/default_full": 150, "./schema/default_safe": 151 },
    ],
    145: [
      function (require, module, exports) {
        // YAML error class. http://stackoverflow.com/questions/8458984
        //
        "use strict";

        function YAMLException(reason, mark) {
          // Super constructor
          Error.call(this);

          this.name = "YAMLException";
          this.reason = reason;
          this.mark = mark;
          this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");

          // Include stack trace in error object
          if (Error.captureStackTrace) {
            // Chrome and NodeJS
            Error.captureStackTrace(this, this.constructor);
          } else {
            // FF, IE 10+ and Safari 6+. Fallback for others
            this.stack = new Error().stack || "";
          }
        }

        // Inherit from Error
        YAMLException.prototype = Object.create(Error.prototype);
        YAMLException.prototype.constructor = YAMLException;

        YAMLException.prototype.toString = function toString(compact) {
          var result = this.name + ": ";

          result += this.reason || "(unknown reason)";

          if (!compact && this.mark) {
            result += " " + this.mark.toString();
          }

          return result;
        };

        module.exports = YAMLException;
      },
      {},
    ],
    146: [
      function (require, module, exports) {
        "use strict";

        /*eslint-disable max-len,no-use-before-define*/

        var common = require("./common");
        var YAMLException = require("./exception");
        var Mark = require("./mark");
        var DEFAULT_SAFE_SCHEMA = require("./schema/default_safe");
        var DEFAULT_FULL_SCHEMA = require("./schema/default_full");

        var _hasOwnProperty = Object.prototype.hasOwnProperty;

        var CONTEXT_FLOW_IN = 1;
        var CONTEXT_FLOW_OUT = 2;
        var CONTEXT_BLOCK_IN = 3;
        var CONTEXT_BLOCK_OUT = 4;

        var CHOMPING_CLIP = 1;
        var CHOMPING_STRIP = 2;
        var CHOMPING_KEEP = 3;

        var PATTERN_NON_PRINTABLE =
          /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
        var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
        var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

        function _class(obj) {
          return Object.prototype.toString.call(obj);
        }

        function is_EOL(c) {
          return c === 0x0a /* LF */ || c === 0x0d /* CR */;
        }

        function is_WHITE_SPACE(c) {
          return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
        }

        function is_WS_OR_EOL(c) {
          return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0a /* LF */ || c === 0x0d /* CR */;
        }

        function is_FLOW_INDICATOR(c) {
          return (
            c === 0x2c /* , */ || c === 0x5b /* [ */ || c === 0x5d /* ] */ || c === 0x7b /* { */ || c === 0x7d /* } */
          );
        }

        function fromHexCode(c) {
          var lc;

          if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
            return c - 0x30;
          }

          /*eslint-disable no-bitwise*/
          lc = c | 0x20;

          if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
            return lc - 0x61 + 10;
          }

          return -1;
        }

        function escapedHexLen(c) {
          if (c === 0x78 /* x */) {
            return 2;
          }
          if (c === 0x75 /* u */) {
            return 4;
          }
          if (c === 0x55 /* U */) {
            return 8;
          }
          return 0;
        }

        function fromDecimalCode(c) {
          if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
            return c - 0x30;
          }

          return -1;
        }

        function simpleEscapeSequence(c) {
          /* eslint-disable indent */
          return c === 0x30 /* 0 */
            ? "\x00"
            : c === 0x61 /* a */
              ? "\x07"
              : c === 0x62 /* b */
                ? "\x08"
                : c === 0x74 /* t */
                  ? "\x09"
                  : c === 0x09 /* Tab */
                    ? "\x09"
                    : c === 0x6e /* n */
                      ? "\x0A"
                      : c === 0x76 /* v */
                        ? "\x0B"
                        : c === 0x66 /* f */
                          ? "\x0C"
                          : c === 0x72 /* r */
                            ? "\x0D"
                            : c === 0x65 /* e */
                              ? "\x1B"
                              : c === 0x20 /* Space */
                                ? " "
                                : c === 0x22 /* " */
                                  ? "\x22"
                                  : c === 0x2f /* / */
                                    ? "/"
                                    : c === 0x5c /* \ */
                                      ? "\x5C"
                                      : c === 0x4e /* N */
                                        ? "\x85"
                                        : c === 0x5f /* _ */
                                          ? "\xA0"
                                          : c === 0x4c /* L */
                                            ? "\u2028"
                                            : c === 0x50 /* P */
                                              ? "\u2029"
                                              : "";
        }

        function charFromCodepoint(c) {
          if (c <= 0xffff) {
            return String.fromCharCode(c);
          }
          // Encode UTF-16 surrogate pair
          // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
          return String.fromCharCode(((c - 0x010000) >> 10) + 0xd800, ((c - 0x010000) & 0x03ff) + 0xdc00);
        }

        var simpleEscapeCheck = new Array(256); // integer, for fast access
        var simpleEscapeMap = new Array(256);
        for (var i = 0; i < 256; i++) {
          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
          simpleEscapeMap[i] = simpleEscapeSequence(i);
        }

        function State(input, options) {
          this.input = input;

          this.filename = options["filename"] || null;
          this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
          this.onWarning = options["onWarning"] || null;
          this.legacy = options["legacy"] || false;
          this.json = options["json"] || false;
          this.listener = options["listener"] || null;

          this.implicitTypes = this.schema.compiledImplicit;
          this.typeMap = this.schema.compiledTypeMap;

          this.length = input.length;
          this.position = 0;
          this.line = 0;
          this.lineStart = 0;
          this.lineIndent = 0;

          this.documents = [];

          /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
        }

        function generateError(state, message) {
          return new YAMLException(
            message,
            new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart),
          );
        }

        function throwError(state, message) {
          throw generateError(state, message);
        }

        function throwWarning(state, message) {
          if (state.onWarning) {
            state.onWarning.call(null, generateError(state, message));
          }
        }

        var directiveHandlers = {
          YAML: function handleYamlDirective(state, name, args) {
            var match, major, minor;

            if (state.version !== null) {
              throwError(state, "duplication of %YAML directive");
            }

            if (args.length !== 1) {
              throwError(state, "YAML directive accepts exactly one argument");
            }

            match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

            if (match === null) {
              throwError(state, "ill-formed argument of the YAML directive");
            }

            major = parseInt(match[1], 10);
            minor = parseInt(match[2], 10);

            if (major !== 1) {
              throwError(state, "unacceptable YAML version of the document");
            }

            state.version = args[0];
            state.checkLineBreaks = minor < 2;

            if (minor !== 1 && minor !== 2) {
              throwWarning(state, "unsupported YAML version of the document");
            }
          },

          TAG: function handleTagDirective(state, name, args) {
            var handle, prefix;

            if (args.length !== 2) {
              throwError(state, "TAG directive accepts exactly two arguments");
            }

            handle = args[0];
            prefix = args[1];

            if (!PATTERN_TAG_HANDLE.test(handle)) {
              throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
            }

            if (_hasOwnProperty.call(state.tagMap, handle)) {
              throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
            }

            if (!PATTERN_TAG_URI.test(prefix)) {
              throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
            }

            state.tagMap[handle] = prefix;
          },
        };

        function captureSegment(state, start, end, checkJson) {
          var _position, _length, _character, _result;

          if (start < end) {
            _result = state.input.slice(start, end);

            if (checkJson) {
              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                _character = _result.charCodeAt(_position);
                if (!(_character === 0x09 || (0x20 <= _character && _character <= 0x10ffff))) {
                  throwError(state, "expected valid JSON character");
                }
              }
            } else if (PATTERN_NON_PRINTABLE.test(_result)) {
              throwError(state, "the stream contains non-printable characters");
            }

            state.result += _result;
          }
        }

        function mergeMappings(state, destination, source, overridableKeys) {
          var sourceKeys, key, index, quantity;

          if (!common.isObject(source)) {
            throwError(state, "cannot merge mappings; the provided source object is unacceptable");
          }

          sourceKeys = Object.keys(source);

          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
            key = sourceKeys[index];

            if (!_hasOwnProperty.call(destination, key)) {
              destination[key] = source[key];
              overridableKeys[key] = true;
            }
          }
        }

        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
          var index, quantity;

          // The output is a plain object here, so keys can only be strings.
          // We need to convert keyNode to a string, but doing so can hang the process
          // (deeply nested arrays that explode exponentially using aliases).
          if (Array.isArray(keyNode)) {
            keyNode = Array.prototype.slice.call(keyNode);

            for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
              if (Array.isArray(keyNode[index])) {
                throwError(state, "nested arrays are not supported inside keys");
              }

              if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
                keyNode[index] = "[object Object]";
              }
            }
          }

          // Avoid code execution in load() via toString property
          // (still use its own toString for arrays, timestamps,
          // and whatever user schema extensions happen to have @@toStringTag)
          if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
            keyNode = "[object Object]";
          }

          keyNode = String(keyNode);

          if (_result === null) {
            _result = {};
          }

          if (keyTag === "tag:yaml.org,2002:merge") {
            if (Array.isArray(valueNode)) {
              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                mergeMappings(state, _result, valueNode[index], overridableKeys);
              }
            } else {
              mergeMappings(state, _result, valueNode, overridableKeys);
            }
          } else {
            if (
              !state.json &&
              !_hasOwnProperty.call(overridableKeys, keyNode) &&
              _hasOwnProperty.call(_result, keyNode)
            ) {
              state.line = startLine || state.line;
              state.position = startPos || state.position;
              throwError(state, "duplicated mapping key");
            }
            _result[keyNode] = valueNode;
            delete overridableKeys[keyNode];
          }

          return _result;
        }

        function readLineBreak(state) {
          var ch;

          ch = state.input.charCodeAt(state.position);

          if (ch === 0x0a /* LF */) {
            state.position++;
          } else if (ch === 0x0d /* CR */) {
            state.position++;
            if (state.input.charCodeAt(state.position) === 0x0a /* LF */) {
              state.position++;
            }
          } else {
            throwError(state, "a line break is expected");
          }

          state.line += 1;
          state.lineStart = state.position;
        }

        function skipSeparationSpace(state, allowComments, checkIndent) {
          var lineBreaks = 0,
            ch = state.input.charCodeAt(state.position);

          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }

            if (allowComments && ch === 0x23 /* # */) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0x0a /* LF */ && ch !== 0x0d /* CR */ && ch !== 0);
            }

            if (is_EOL(ch)) {
              readLineBreak(state);

              ch = state.input.charCodeAt(state.position);
              lineBreaks++;
              state.lineIndent = 0;

              while (ch === 0x20 /* Space */) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
            } else {
              break;
            }
          }

          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
            throwWarning(state, "deficient indentation");
          }

          return lineBreaks;
        }

        function testDocumentSeparator(state) {
          var _position = state.position,
            ch;

          ch = state.input.charCodeAt(_position);

          // Condition state.position === state.lineStart is tested
          // in parent on each call, for efficiency. No needs to test here again.
          if (
            (ch === 0x2d /* - */ || ch === 0x2e) /* . */ &&
            ch === state.input.charCodeAt(_position + 1) &&
            ch === state.input.charCodeAt(_position + 2)
          ) {
            _position += 3;

            ch = state.input.charCodeAt(_position);

            if (ch === 0 || is_WS_OR_EOL(ch)) {
              return true;
            }
          }

          return false;
        }

        function writeFoldedLines(state, count) {
          if (count === 1) {
            state.result += " ";
          } else if (count > 1) {
            state.result += common.repeat("\n", count - 1);
          }
        }

        function readPlainScalar(state, nodeIndent, withinFlowCollection) {
          var preceding,
            following,
            captureStart,
            captureEnd,
            hasPendingContent,
            _line,
            _lineStart,
            _lineIndent,
            _kind = state.kind,
            _result = state.result,
            ch;

          ch = state.input.charCodeAt(state.position);

          if (
            is_WS_OR_EOL(ch) ||
            is_FLOW_INDICATOR(ch) ||
            ch === 0x23 /* # */ ||
            ch === 0x26 /* & */ ||
            ch === 0x2a /* * */ ||
            ch === 0x21 /* ! */ ||
            ch === 0x7c /* | */ ||
            ch === 0x3e /* > */ ||
            ch === 0x27 /* ' */ ||
            ch === 0x22 /* " */ ||
            ch === 0x25 /* % */ ||
            ch === 0x40 /* @ */ ||
            ch === 0x60 /* ` */
          ) {
            return false;
          }

          if (ch === 0x3f /* ? */ || ch === 0x2d /* - */) {
            following = state.input.charCodeAt(state.position + 1);

            if (is_WS_OR_EOL(following) || (withinFlowCollection && is_FLOW_INDICATOR(following))) {
              return false;
            }
          }

          state.kind = "scalar";
          state.result = "";
          captureStart = captureEnd = state.position;
          hasPendingContent = false;

          while (ch !== 0) {
            if (ch === 0x3a /* : */) {
              following = state.input.charCodeAt(state.position + 1);

              if (is_WS_OR_EOL(following) || (withinFlowCollection && is_FLOW_INDICATOR(following))) {
                break;
              }
            } else if (ch === 0x23 /* # */) {
              preceding = state.input.charCodeAt(state.position - 1);

              if (is_WS_OR_EOL(preceding)) {
                break;
              }
            } else if (
              (state.position === state.lineStart && testDocumentSeparator(state)) ||
              (withinFlowCollection && is_FLOW_INDICATOR(ch))
            ) {
              break;
            } else if (is_EOL(ch)) {
              _line = state.line;
              _lineStart = state.lineStart;
              _lineIndent = state.lineIndent;
              skipSeparationSpace(state, false, -1);

              if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
              } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
              }
            }

            if (hasPendingContent) {
              captureSegment(state, captureStart, captureEnd, false);
              writeFoldedLines(state, state.line - _line);
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
            }

            if (!is_WHITE_SPACE(ch)) {
              captureEnd = state.position + 1;
            }

            ch = state.input.charCodeAt(++state.position);
          }

          captureSegment(state, captureStart, captureEnd, false);

          if (state.result) {
            return true;
          }

          state.kind = _kind;
          state.result = _result;
          return false;
        }

        function readSingleQuotedScalar(state, nodeIndent) {
          var ch, captureStart, captureEnd;

          ch = state.input.charCodeAt(state.position);

          if (ch !== 0x27 /* ' */) {
            return false;
          }

          state.kind = "scalar";
          state.result = "";
          state.position++;
          captureStart = captureEnd = state.position;

          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 0x27 /* ' */) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);

              if (ch === 0x27 /* ' */) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
              } else {
                return true;
              }
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, "unexpected end of the document within a single quoted scalar");
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }

          throwError(state, "unexpected end of the stream within a single quoted scalar");
        }

        function readDoubleQuotedScalar(state, nodeIndent) {
          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;

          ch = state.input.charCodeAt(state.position);

          if (ch !== 0x22 /* " */) {
            return false;
          }

          state.kind = "scalar";
          state.result = "";
          state.position++;
          captureStart = captureEnd = state.position;

          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 0x22 /* " */) {
              captureSegment(state, captureStart, state.position, true);
              state.position++;
              return true;
            } else if (ch === 0x5c /* \ */) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);

              if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);

                // TODO: rework to inline fn with no type cast?
              } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
              } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;

                for (; hexLength > 0; hexLength--) {
                  ch = state.input.charCodeAt(++state.position);

                  if ((tmp = fromHexCode(ch)) >= 0) {
                    hexResult = (hexResult << 4) + tmp;
                  } else {
                    throwError(state, "expected hexadecimal character");
                  }
                }

                state.result += charFromCodepoint(hexResult);

                state.position++;
              } else {
                throwError(state, "unknown escape sequence");
              }

              captureStart = captureEnd = state.position;
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, "unexpected end of the document within a double quoted scalar");
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }

          throwError(state, "unexpected end of the stream within a double quoted scalar");
        }

        function readFlowCollection(state, nodeIndent) {
          var readNext = true,
            _line,
            _tag = state.tag,
            _result,
            _anchor = state.anchor,
            following,
            terminator,
            isPair,
            isExplicitPair,
            isMapping,
            overridableKeys = {},
            keyNode,
            keyTag,
            valueNode,
            ch;

          ch = state.input.charCodeAt(state.position);

          if (ch === 0x5b /* [ */) {
            terminator = 0x5d; /* ] */
            isMapping = false;
            _result = [];
          } else if (ch === 0x7b /* { */) {
            terminator = 0x7d; /* } */
            isMapping = true;
            _result = {};
          } else {
            return false;
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }

          ch = state.input.charCodeAt(++state.position);

          while (ch !== 0) {
            skipSeparationSpace(state, true, nodeIndent);

            ch = state.input.charCodeAt(state.position);

            if (ch === terminator) {
              state.position++;
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = isMapping ? "mapping" : "sequence";
              state.result = _result;
              return true;
            } else if (!readNext) {
              throwError(state, "missed comma between flow collection entries");
            }

            keyTag = keyNode = valueNode = null;
            isPair = isExplicitPair = false;

            if (ch === 0x3f /* ? */) {
              following = state.input.charCodeAt(state.position + 1);

              if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
              }
            }

            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            keyTag = state.tag;
            keyNode = state.result;
            skipSeparationSpace(state, true, nodeIndent);

            ch = state.input.charCodeAt(state.position);

            if ((isExplicitPair || state.line === _line) && ch === 0x3a /* : */) {
              isPair = true;
              ch = state.input.charCodeAt(++state.position);
              skipSeparationSpace(state, true, nodeIndent);
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              valueNode = state.result;
            }

            if (isMapping) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
            } else if (isPair) {
              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
            } else {
              _result.push(keyNode);
            }

            skipSeparationSpace(state, true, nodeIndent);

            ch = state.input.charCodeAt(state.position);

            if (ch === 0x2c /* , */) {
              readNext = true;
              ch = state.input.charCodeAt(++state.position);
            } else {
              readNext = false;
            }
          }

          throwError(state, "unexpected end of the stream within a flow collection");
        }

        function readBlockScalar(state, nodeIndent) {
          var captureStart,
            folding,
            chomping = CHOMPING_CLIP,
            didReadContent = false,
            detectedIndent = false,
            textIndent = nodeIndent,
            emptyLines = 0,
            atMoreIndented = false,
            tmp,
            ch;

          ch = state.input.charCodeAt(state.position);

          if (ch === 0x7c /* | */) {
            folding = false;
          } else if (ch === 0x3e /* > */) {
            folding = true;
          } else {
            return false;
          }

          state.kind = "scalar";
          state.result = "";

          while (ch !== 0) {
            ch = state.input.charCodeAt(++state.position);

            if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
              if (CHOMPING_CLIP === chomping) {
                chomping = ch === 0x2b /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
              } else {
                throwError(state, "repeat of a chomping mode identifier");
              }
            } else if ((tmp = fromDecimalCode(ch)) >= 0) {
              if (tmp === 0) {
                throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
              } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
              } else {
                throwError(state, "repeat of an indentation width identifier");
              }
            } else {
              break;
            }
          }

          if (is_WHITE_SPACE(ch)) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (is_WHITE_SPACE(ch));

            if (ch === 0x23 /* # */) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (!is_EOL(ch) && ch !== 0);
            }
          }

          while (ch !== 0) {
            readLineBreak(state);
            state.lineIndent = 0;

            ch = state.input.charCodeAt(state.position);

            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }

            if (!detectedIndent && state.lineIndent > textIndent) {
              textIndent = state.lineIndent;
            }

            if (is_EOL(ch)) {
              emptyLines++;
              continue;
            }

            // End of the scalar.
            if (state.lineIndent < textIndent) {
              // Perform the chomping.
              if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
              } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                  // i.e. only if the scalar is not empty.
                  state.result += "\n";
                }
              }

              // Break this `while` cycle and go to the funciton's epilogue.
              break;
            }

            // Folded style: use fancy rules to handle line breaks.
            if (folding) {
              // Lines starting with white space characters (more-indented lines) are not folded.
              if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);

                // End of more-indented block.
              } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat("\n", emptyLines + 1);

                // Just one line break - perceive as the same line.
              } else if (emptyLines === 0) {
                if (didReadContent) {
                  // i.e. only if we have already read some scalar content.
                  state.result += " ";
                }

                // Several line breaks - perceive as different lines.
              } else {
                state.result += common.repeat("\n", emptyLines);
              }

              // Literal style: just add exact number of line breaks between content lines.
            } else {
              // Keep all line breaks except the header line break.
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            }

            didReadContent = true;
            detectedIndent = true;
            emptyLines = 0;
            captureStart = state.position;

            while (!is_EOL(ch) && ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
            }

            captureSegment(state, captureStart, state.position, false);
          }

          return true;
        }

        function readBlockSequence(state, nodeIndent) {
          var _line,
            _tag = state.tag,
            _anchor = state.anchor,
            _result = [],
            following,
            detected = false,
            ch;

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }

          ch = state.input.charCodeAt(state.position);

          while (ch !== 0) {
            if (ch !== 0x2d /* - */) {
              break;
            }

            following = state.input.charCodeAt(state.position + 1);

            if (!is_WS_OR_EOL(following)) {
              break;
            }

            detected = true;
            state.position++;

            if (skipSeparationSpace(state, true, -1)) {
              if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
              }
            }

            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
            _result.push(state.result);
            skipSeparationSpace(state, true, -1);

            ch = state.input.charCodeAt(state.position);

            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
              throwError(state, "bad indentation of a sequence entry");
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }

          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = "sequence";
            state.result = _result;
            return true;
          }
          return false;
        }

        function readBlockMapping(state, nodeIndent, flowIndent) {
          var following,
            allowCompact,
            _line,
            _pos,
            _tag = state.tag,
            _anchor = state.anchor,
            _result = {},
            overridableKeys = {},
            keyTag = null,
            keyNode = null,
            valueNode = null,
            atExplicitKey = false,
            detected = false,
            ch;

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }

          ch = state.input.charCodeAt(state.position);

          while (ch !== 0) {
            following = state.input.charCodeAt(state.position + 1);
            _line = state.line; // Save the current line.
            _pos = state.position;

            //
            // Explicit notation case. There are two separate blocks:
            // first for the key (denoted by "?") and second for the value (denoted by ":")
            //
            if ((ch === 0x3f /* ? */ || ch === 0x3a) /* : */ && is_WS_OR_EOL(following)) {
              if (ch === 0x3f /* ? */) {
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                  keyTag = keyNode = valueNode = null;
                }

                detected = true;
                atExplicitKey = true;
                allowCompact = true;
              } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
              } else {
                throwError(
                  state,
                  "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line",
                );
              }

              state.position += 1;
              ch = following;

              //
              // Implicit notation case. Flow-style node as the key first, then ":", and the value.
              //
            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
              if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);

                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }

                if (ch === 0x3a /* : */) {
                  ch = state.input.charCodeAt(++state.position);

                  if (!is_WS_OR_EOL(ch)) {
                    throwError(
                      state,
                      "a whitespace character is expected after the key-value separator within a block mapping",
                    );
                  }

                  if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                  }

                  detected = true;
                  atExplicitKey = false;
                  allowCompact = false;
                  keyTag = state.tag;
                  keyNode = state.result;
                } else if (detected) {
                  throwError(state, "can not read an implicit mapping pair; a colon is missed");
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true; // Keep the result of `composeNode`.
                }
              } else if (detected) {
                throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
              }
            } else {
              break; // Reading is done. Go to the epilogue.
            }

            //
            // Common reading code for both explicit and implicit notations.
            //
            if (state.line === _line || state.lineIndent > nodeIndent) {
              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                  keyNode = state.result;
                } else {
                  valueNode = state.result;
                }
              }

              if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
              }

              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
            }

            if (state.lineIndent > nodeIndent && ch !== 0) {
              throwError(state, "bad indentation of a mapping entry");
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }

          //
          // Epilogue.
          //

          // Special case: last mapping's node contains only the key in explicit notation.
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          }

          // Expose the resulting mapping.
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = "mapping";
            state.result = _result;
          }

          return detected;
        }

        function readTagProperty(state) {
          var _position,
            isVerbatim = false,
            isNamed = false,
            tagHandle,
            tagName,
            ch;

          ch = state.input.charCodeAt(state.position);

          if (ch !== 0x21 /* ! */) return false;

          if (state.tag !== null) {
            throwError(state, "duplication of a tag property");
          }

          ch = state.input.charCodeAt(++state.position);

          if (ch === 0x3c /* < */) {
            isVerbatim = true;
            ch = state.input.charCodeAt(++state.position);
          } else if (ch === 0x21 /* ! */) {
            isNamed = true;
            tagHandle = "!!";
            ch = state.input.charCodeAt(++state.position);
          } else {
            tagHandle = "!";
          }

          _position = state.position;

          if (isVerbatim) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && ch !== 0x3e /* > */);

            if (state.position < state.length) {
              tagName = state.input.slice(_position, state.position);
              ch = state.input.charCodeAt(++state.position);
            } else {
              throwError(state, "unexpected end of the stream within a verbatim tag");
            }
          } else {
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              if (ch === 0x21 /* ! */) {
                if (!isNamed) {
                  tagHandle = state.input.slice(_position - 1, state.position + 1);

                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                    throwError(state, "named tag handle cannot contain such characters");
                  }

                  isNamed = true;
                  _position = state.position + 1;
                } else {
                  throwError(state, "tag suffix cannot contain exclamation marks");
                }
              }

              ch = state.input.charCodeAt(++state.position);
            }

            tagName = state.input.slice(_position, state.position);

            if (PATTERN_FLOW_INDICATORS.test(tagName)) {
              throwError(state, "tag suffix cannot contain flow indicator characters");
            }
          }

          if (tagName && !PATTERN_TAG_URI.test(tagName)) {
            throwError(state, "tag name cannot contain such characters: " + tagName);
          }

          if (isVerbatim) {
            state.tag = tagName;
          } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
            state.tag = state.tagMap[tagHandle] + tagName;
          } else if (tagHandle === "!") {
            state.tag = "!" + tagName;
          } else if (tagHandle === "!!") {
            state.tag = "tag:yaml.org,2002:" + tagName;
          } else {
            throwError(state, 'undeclared tag handle "' + tagHandle + '"');
          }

          return true;
        }

        function readAnchorProperty(state) {
          var _position, ch;

          ch = state.input.charCodeAt(state.position);

          if (ch !== 0x26 /* & */) return false;

          if (state.anchor !== null) {
            throwError(state, "duplication of an anchor property");
          }

          ch = state.input.charCodeAt(++state.position);
          _position = state.position;

          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (state.position === _position) {
            throwError(state, "name of an anchor node must contain at least one character");
          }

          state.anchor = state.input.slice(_position, state.position);
          return true;
        }

        function readAlias(state) {
          var _position, alias, ch;

          ch = state.input.charCodeAt(state.position);

          if (ch !== 0x2a /* * */) return false;

          ch = state.input.charCodeAt(++state.position);
          _position = state.position;

          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (state.position === _position) {
            throwError(state, "name of an alias node must contain at least one character");
          }

          alias = state.input.slice(_position, state.position);

          if (!_hasOwnProperty.call(state.anchorMap, alias)) {
            throwError(state, 'unidentified alias "' + alias + '"');
          }

          state.result = state.anchorMap[alias];
          skipSeparationSpace(state, true, -1);
          return true;
        }

        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
          var allowBlockStyles,
            allowBlockScalars,
            allowBlockCollections,
            indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
            atNewLine = false,
            hasContent = false,
            typeIndex,
            typeQuantity,
            type,
            flowIndent,
            blockIndent;

          if (state.listener !== null) {
            state.listener("open", state);
          }

          state.tag = null;
          state.anchor = null;
          state.kind = null;
          state.result = null;

          allowBlockStyles =
            allowBlockScalars =
            allowBlockCollections =
              CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

          if (allowToSeek) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;

              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            }
          }

          if (indentStatus === 1) {
            while (readTagProperty(state) || readAnchorProperty(state)) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;

                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              } else {
                allowBlockCollections = false;
              }
            }
          }

          if (allowBlockCollections) {
            allowBlockCollections = atNewLine || allowCompact;
          }

          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
              flowIndent = parentIndent;
            } else {
              flowIndent = parentIndent + 1;
            }

            blockIndent = state.position - state.lineStart;

            if (indentStatus === 1) {
              if (
                (allowBlockCollections &&
                  (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent))) ||
                readFlowCollection(state, flowIndent)
              ) {
                hasContent = true;
              } else {
                if (
                  (allowBlockScalars && readBlockScalar(state, flowIndent)) ||
                  readSingleQuotedScalar(state, flowIndent) ||
                  readDoubleQuotedScalar(state, flowIndent)
                ) {
                  hasContent = true;
                } else if (readAlias(state)) {
                  hasContent = true;

                  if (state.tag !== null || state.anchor !== null) {
                    throwError(state, "alias node should not have any properties");
                  }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                  hasContent = true;

                  if (state.tag === null) {
                    state.tag = "?";
                  }
                }

                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else if (indentStatus === 0) {
              // Special case: block sequences are allowed to have same indentation level as the parent.
              // http://www.yaml.org/spec/1.2/spec.html#id2799784
              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
            }
          }

          if (state.tag !== null && state.tag !== "!") {
            if (state.tag === "?") {
              // Implicit resolving is not allowed for non-scalar types, and '?'
              // non-specific tag is only automatically assigned to plain scalars.
              //
              // We only need to check kind conformity in case user explicitly assigns '?'
              // tag, for example like this: "!<?> [0]"
              //
              if (state.result !== null && state.kind !== "scalar") {
                throwError(
                  state,
                  'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"',
                );
              }

              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];

                if (type.resolve(state.result)) {
                  // `state.result` updated in resolver if matched
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
              type = state.typeMap[state.kind || "fallback"][state.tag];

              if (state.result !== null && type.kind !== state.kind) {
                throwError(
                  state,
                  "unacceptable node kind for !<" +
                    state.tag +
                    '> tag; it should be "' +
                    type.kind +
                    '", not "' +
                    state.kind +
                    '"',
                );
              }

              if (!type.resolve(state.result)) {
                // `state.result` updated in resolver if matched
                throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
              } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else {
              throwError(state, "unknown tag !<" + state.tag + ">");
            }
          }

          if (state.listener !== null) {
            state.listener("close", state);
          }
          return state.tag !== null || state.anchor !== null || hasContent;
        }

        function readDocument(state) {
          var documentStart = state.position,
            _position,
            directiveName,
            directiveArgs,
            hasDirectives = false,
            ch;

          state.version = null;
          state.checkLineBreaks = state.legacy;
          state.tagMap = {};
          state.anchorMap = {};

          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            skipSeparationSpace(state, true, -1);

            ch = state.input.charCodeAt(state.position);

            if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
              break;
            }

            hasDirectives = true;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;

            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }

            directiveName = state.input.slice(_position, state.position);
            directiveArgs = [];

            if (directiveName.length < 1) {
              throwError(state, "directive name must not be less than one character in length");
            }

            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }

              if (ch === 0x23 /* # */) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0 && !is_EOL(ch));
                break;
              }

              if (is_EOL(ch)) break;

              _position = state.position;

              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }

              directiveArgs.push(state.input.slice(_position, state.position));
            }

            if (ch !== 0) readLineBreak(state);

            if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
              directiveHandlers[directiveName](state, directiveName, directiveArgs);
            } else {
              throwWarning(state, 'unknown document directive "' + directiveName + '"');
            }
          }

          skipSeparationSpace(state, true, -1);

          if (
            state.lineIndent === 0 &&
            state.input.charCodeAt(state.position) === 0x2d /* - */ &&
            state.input.charCodeAt(state.position + 1) === 0x2d /* - */ &&
            state.input.charCodeAt(state.position + 2) === 0x2d /* - */
          ) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          } else if (hasDirectives) {
            throwError(state, "directives end mark is expected");
          }

          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
          skipSeparationSpace(state, true, -1);

          if (
            state.checkLineBreaks &&
            PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))
          ) {
            throwWarning(state, "non-ASCII line breaks are interpreted as content");
          }

          state.documents.push(state.result);

          if (state.position === state.lineStart && testDocumentSeparator(state)) {
            if (state.input.charCodeAt(state.position) === 0x2e /* . */) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            }
            return;
          }

          if (state.position < state.length - 1) {
            throwError(state, "end of the stream or a document separator is expected");
          } else {
            return;
          }
        }

        function loadDocuments(input, options) {
          input = String(input);
          options = options || {};

          if (input.length !== 0) {
            // Add tailing `\n` if not exists
            if (
              input.charCodeAt(input.length - 1) !== 0x0a /* LF */ &&
              input.charCodeAt(input.length - 1) !== 0x0d /* CR */
            ) {
              input += "\n";
            }

            // Strip BOM
            if (input.charCodeAt(0) === 0xfeff) {
              input = input.slice(1);
            }
          }

          var state = new State(input, options);

          var nullpos = input.indexOf("\0");

          if (nullpos !== -1) {
            state.position = nullpos;
            throwError(state, "null byte is not allowed in input");
          }

          // Use 0 as string terminator. That significantly simplifies bounds check.
          state.input += "\0";

          while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
            state.lineIndent += 1;
            state.position += 1;
          }

          while (state.position < state.length - 1) {
            readDocument(state);
          }

          return state.documents;
        }

        function loadAll(input, iterator, options) {
          if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
            options = iterator;
            iterator = null;
          }

          var documents = loadDocuments(input, options);

          if (typeof iterator !== "function") {
            return documents;
          }

          for (var index = 0, length = documents.length; index < length; index += 1) {
            iterator(documents[index]);
          }
        }

        function load(input, options) {
          var documents = loadDocuments(input, options);

          if (documents.length === 0) {
            /*eslint-disable no-undefined*/
            return undefined;
          } else if (documents.length === 1) {
            return documents[0];
          }
          throw new YAMLException("expected a single document in the stream, but found more");
        }

        function safeLoadAll(input, iterator, options) {
          if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
            options = iterator;
            iterator = null;
          }

          return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }

        function safeLoad(input, options) {
          return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }

        module.exports.loadAll = loadAll;
        module.exports.load = load;
        module.exports.safeLoadAll = safeLoadAll;
        module.exports.safeLoad = safeLoad;
      },
      {
        "./common": 143,
        "./exception": 145,
        "./mark": 147,
        "./schema/default_full": 150,
        "./schema/default_safe": 151,
      },
    ],
    147: [
      function (require, module, exports) {
        "use strict";

        var common = require("./common");

        function Mark(name, buffer, position, line, column) {
          this.name = name;
          this.buffer = buffer;
          this.position = position;
          this.line = line;
          this.column = column;
        }

        Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
          var head, start, tail, end, snippet;

          if (!this.buffer) return null;

          indent = indent || 4;
          maxLength = maxLength || 75;

          head = "";
          start = this.position;

          while (start > 0 && "\x00\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
            start -= 1;
            if (this.position - start > maxLength / 2 - 1) {
              head = " ... ";
              start += 5;
              break;
            }
          }

          tail = "";
          end = this.position;

          while (end < this.buffer.length && "\x00\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
            end += 1;
            if (end - this.position > maxLength / 2 - 1) {
              tail = " ... ";
              end -= 5;
              break;
            }
          }

          snippet = this.buffer.slice(start, end);

          return (
            common.repeat(" ", indent) +
            head +
            snippet +
            tail +
            "\n" +
            common.repeat(" ", indent + this.position - start + head.length) +
            "^"
          );
        };

        Mark.prototype.toString = function toString(compact) {
          var snippet,
            where = "";

          if (this.name) {
            where += 'in "' + this.name + '" ';
          }

          where += "at line " + (this.line + 1) + ", column " + (this.column + 1);

          if (!compact) {
            snippet = this.getSnippet();

            if (snippet) {
              where += ":\n" + snippet;
            }
          }

          return where;
        };

        module.exports = Mark;
      },
      { "./common": 143 },
    ],
    148: [
      function (require, module, exports) {
        "use strict";

        /*eslint-disable max-len*/

        var common = require("./common");
        var YAMLException = require("./exception");
        var Type = require("./type");

        function compileList(schema, name, result) {
          var exclude = [];

          schema.include.forEach(function (includedSchema) {
            result = compileList(includedSchema, name, result);
          });

          schema[name].forEach(function (currentType) {
            result.forEach(function (previousType, previousIndex) {
              if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
                exclude.push(previousIndex);
              }
            });

            result.push(currentType);
          });

          return result.filter(function (type, index) {
            return exclude.indexOf(index) === -1;
          });
        }

        function compileMap(/* lists... */) {
          var result = {
              scalar: {},
              sequence: {},
              mapping: {},
              fallback: {},
            },
            index,
            length;

          function collectType(type) {
            result[type.kind][type.tag] = result["fallback"][type.tag] = type;
          }

          for (index = 0, length = arguments.length; index < length; index += 1) {
            arguments[index].forEach(collectType);
          }
          return result;
        }

        function Schema(definition) {
          this.include = definition.include || [];
          this.implicit = definition.implicit || [];
          this.explicit = definition.explicit || [];

          this.implicit.forEach(function (type) {
            if (type.loadKind && type.loadKind !== "scalar") {
              throw new YAMLException(
                "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
              );
            }
          });

          this.compiledImplicit = compileList(this, "implicit", []);
          this.compiledExplicit = compileList(this, "explicit", []);
          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
        }

        Schema.DEFAULT = null;

        Schema.create = function createSchema() {
          var schemas, types;

          switch (arguments.length) {
            case 1:
              schemas = Schema.DEFAULT;
              types = arguments[0];
              break;

            case 2:
              schemas = arguments[0];
              types = arguments[1];
              break;

            default:
              throw new YAMLException("Wrong number of arguments for Schema.create function");
          }

          schemas = common.toArray(schemas);
          types = common.toArray(types);

          if (
            !schemas.every(function (schema) {
              return schema instanceof Schema;
            })
          ) {
            throw new YAMLException(
              "Specified list of super schemas (or a single Schema object) contains a non-Schema object.",
            );
          }

          if (
            !types.every(function (type) {
              return type instanceof Type;
            })
          ) {
            throw new YAMLException(
              "Specified list of YAML types (or a single Type object) contains a non-Type object.",
            );
          }

          return new Schema({
            include: schemas,
            explicit: types,
          });
        };

        module.exports = Schema;
      },
      { "./common": 143, "./exception": 145, "./type": 154 },
    ],
    149: [
      function (require, module, exports) {
        // Standard YAML's Core schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2804923
        //
        // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
        // So, Core schema has no distinctions from JSON schema is JS-YAML.

        "use strict";

        var Schema = require("../schema");

        module.exports = new Schema({
          include: [require("./json")],
        });
      },
      { "../schema": 148, "./json": 153 },
    ],
    150: [
      function (require, module, exports) {
        // JS-YAML's default schema for `load` function.
        // It is not described in the YAML specification.
        //
        // This schema is based on JS-YAML's default safe schema and includes
        // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
        //
        // Also this schema is used as default base schema at `Schema.create` function.

        "use strict";

        var Schema = require("../schema");

        module.exports = Schema.DEFAULT = new Schema({
          include: [require("./default_safe")],
          explicit: [require("../type/js/undefined"), require("../type/js/regexp"), require("../type/js/function")],
        });
      },
      {
        "../schema": 148,
        "../type/js/function": 159,
        "../type/js/regexp": 160,
        "../type/js/undefined": 161,
        "./default_safe": 151,
      },
    ],
    151: [
      function (require, module, exports) {
        // JS-YAML's default schema for `safeLoad` function.
        // It is not described in the YAML specification.
        //
        // This schema is based on standard YAML's Core schema and includes most of
        // extra types described at YAML tag repository. (http://yaml.org/type/)

        "use strict";

        var Schema = require("../schema");

        module.exports = new Schema({
          include: [require("./core")],
          implicit: [require("../type/timestamp"), require("../type/merge")],
          explicit: [
            require("../type/binary"),
            require("../type/omap"),
            require("../type/pairs"),
            require("../type/set"),
          ],
        });
      },
      {
        "../schema": 148,
        "../type/binary": 155,
        "../type/merge": 163,
        "../type/omap": 165,
        "../type/pairs": 166,
        "../type/set": 168,
        "../type/timestamp": 170,
        "./core": 149,
      },
    ],
    152: [
      function (require, module, exports) {
        // Standard YAML's Failsafe schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2802346

        "use strict";

        var Schema = require("../schema");

        module.exports = new Schema({
          explicit: [require("../type/str"), require("../type/seq"), require("../type/map")],
        });
      },
      { "../schema": 148, "../type/map": 162, "../type/seq": 167, "../type/str": 169 },
    ],
    153: [
      function (require, module, exports) {
        // Standard YAML's JSON schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2803231
        //
        // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
        // So, this schema is not such strict as defined in the YAML specification.
        // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

        "use strict";

        var Schema = require("../schema");

        module.exports = new Schema({
          include: [require("./failsafe")],
          implicit: [
            require("../type/null"),
            require("../type/bool"),
            require("../type/int"),
            require("../type/float"),
          ],
        });
      },
      {
        "../schema": 148,
        "../type/bool": 156,
        "../type/float": 157,
        "../type/int": 158,
        "../type/null": 164,
        "./failsafe": 152,
      },
    ],
    154: [
      function (require, module, exports) {
        "use strict";

        var YAMLException = require("./exception");

        var TYPE_CONSTRUCTOR_OPTIONS = [
          "kind",
          "resolve",
          "construct",
          "instanceOf",
          "predicate",
          "represent",
          "defaultStyle",
          "styleAliases",
        ];

        var YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];

        function compileStyleAliases(map) {
          var result = {};

          if (map !== null) {
            Object.keys(map).forEach(function (style) {
              map[style].forEach(function (alias) {
                result[String(alias)] = style;
              });
            });
          }

          return result;
        }

        function Type(tag, options) {
          options = options || {};

          Object.keys(options).forEach(function (name) {
            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
              throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
            }
          });

          // TODO: Add tag format check.
          this.tag = tag;
          this.kind = options["kind"] || null;
          this.resolve =
            options["resolve"] ||
            function () {
              return true;
            };
          this.construct =
            options["construct"] ||
            function (data) {
              return data;
            };
          this.instanceOf = options["instanceOf"] || null;
          this.predicate = options["predicate"] || null;
          this.represent = options["represent"] || null;
          this.defaultStyle = options["defaultStyle"] || null;
          this.styleAliases = compileStyleAliases(options["styleAliases"] || null);

          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
            throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
          }
        }

        module.exports = Type;
      },
      { "./exception": 145 },
    ],
    155: [
      function (require, module, exports) {
        "use strict";

        /*eslint-disable no-bitwise*/

        var NodeBuffer;

        try {
          // A trick for browserified version, to not include `Buffer` shim
          var _require = require;
          NodeBuffer = _require("buffer").Buffer;
        } catch (__) {}

        var Type = require("../type");

        // [ 64, 65, 66 ] -> [ padding, CR, LF ]
        var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";

        function resolveYamlBinary(data) {
          if (data === null) return false;

          var code,
            idx,
            bitlen = 0,
            max = data.length,
            map = BASE64_MAP;

          // Convert one by one.
          for (idx = 0; idx < max; idx++) {
            code = map.indexOf(data.charAt(idx));

            // Skip CR/LF
            if (code > 64) continue;

            // Fail on illegal characters
            if (code < 0) return false;

            bitlen += 6;
          }

          // If there are any bits left, source was corrupted
          return bitlen % 8 === 0;
        }

        function constructYamlBinary(data) {
          var idx,
            tailbits,
            input = data.replace(/[\r\n=]/g, ""), // remove CR/LF & padding to simplify scan
            max = input.length,
            map = BASE64_MAP,
            bits = 0,
            result = [];

          // Collect by 6*4 bits (3 bytes)

          for (idx = 0; idx < max; idx++) {
            if (idx % 4 === 0 && idx) {
              result.push((bits >> 16) & 0xff);
              result.push((bits >> 8) & 0xff);
              result.push(bits & 0xff);
            }

            bits = (bits << 6) | map.indexOf(input.charAt(idx));
          }

          // Dump tail

          tailbits = (max % 4) * 6;

          if (tailbits === 0) {
            result.push((bits >> 16) & 0xff);
            result.push((bits >> 8) & 0xff);
            result.push(bits & 0xff);
          } else if (tailbits === 18) {
            result.push((bits >> 10) & 0xff);
            result.push((bits >> 2) & 0xff);
          } else if (tailbits === 12) {
            result.push((bits >> 4) & 0xff);
          }

          // Wrap into Buffer for NodeJS and leave Array for browser
          if (NodeBuffer) {
            // Support node 6.+ Buffer API when available
            return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
          }

          return result;
        }

        function representYamlBinary(object /*, style*/) {
          var result = "",
            bits = 0,
            idx,
            tail,
            max = object.length,
            map = BASE64_MAP;

          // Convert every three bytes to 4 ASCII characters.

          for (idx = 0; idx < max; idx++) {
            if (idx % 3 === 0 && idx) {
              result += map[(bits >> 18) & 0x3f];
              result += map[(bits >> 12) & 0x3f];
              result += map[(bits >> 6) & 0x3f];
              result += map[bits & 0x3f];
            }

            bits = (bits << 8) + object[idx];
          }

          // Dump tail

          tail = max % 3;

          if (tail === 0) {
            result += map[(bits >> 18) & 0x3f];
            result += map[(bits >> 12) & 0x3f];
            result += map[(bits >> 6) & 0x3f];
            result += map[bits & 0x3f];
          } else if (tail === 2) {
            result += map[(bits >> 10) & 0x3f];
            result += map[(bits >> 4) & 0x3f];
            result += map[(bits << 2) & 0x3f];
            result += map[64];
          } else if (tail === 1) {
            result += map[(bits >> 2) & 0x3f];
            result += map[(bits << 4) & 0x3f];
            result += map[64];
            result += map[64];
          }

          return result;
        }

        function isBinary(object) {
          return NodeBuffer && NodeBuffer.isBuffer(object);
        }

        module.exports = new Type("tag:yaml.org,2002:binary", {
          kind: "scalar",
          resolve: resolveYamlBinary,
          construct: constructYamlBinary,
          predicate: isBinary,
          represent: representYamlBinary,
        });
      },
      { "../type": 154 },
    ],
    156: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        function resolveYamlBoolean(data) {
          if (data === null) return false;

          var max = data.length;

          return (
            (max === 4 && (data === "true" || data === "True" || data === "TRUE")) ||
            (max === 5 && (data === "false" || data === "False" || data === "FALSE"))
          );
        }

        function constructYamlBoolean(data) {
          return data === "true" || data === "True" || data === "TRUE";
        }

        function isBoolean(object) {
          return Object.prototype.toString.call(object) === "[object Boolean]";
        }

        module.exports = new Type("tag:yaml.org,2002:bool", {
          kind: "scalar",
          resolve: resolveYamlBoolean,
          construct: constructYamlBoolean,
          predicate: isBoolean,
          represent: {
            lowercase: function (object) {
              return object ? "true" : "false";
            },
            uppercase: function (object) {
              return object ? "TRUE" : "FALSE";
            },
            camelcase: function (object) {
              return object ? "True" : "False";
            },
          },
          defaultStyle: "lowercase",
        });
      },
      { "../type": 154 },
    ],
    157: [
      function (require, module, exports) {
        "use strict";

        var common = require("../common");
        var Type = require("../type");

        var YAML_FLOAT_PATTERN = new RegExp(
          // 2.5e4, 2.5 and integers
          "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" +
            // .2e4, .2
            // special case, seems not from spec
            "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" +
            // 20:59
            "|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" +
            // .inf
            "|[-+]?\\.(?:inf|Inf|INF)" +
            // .nan
            "|\\.(?:nan|NaN|NAN))$",
        );

        function resolveYamlFloat(data) {
          if (data === null) return false;

          if (
            !YAML_FLOAT_PATTERN.test(data) ||
            // Quick hack to not allow integers end with `_`
            // Probably should update regexp & check speed
            data[data.length - 1] === "_"
          ) {
            return false;
          }

          return true;
        }

        function constructYamlFloat(data) {
          var value, sign, base, digits;

          value = data.replace(/_/g, "").toLowerCase();
          sign = value[0] === "-" ? -1 : 1;
          digits = [];

          if ("+-".indexOf(value[0]) >= 0) {
            value = value.slice(1);
          }

          if (value === ".inf") {
            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          } else if (value === ".nan") {
            return NaN;
          } else if (value.indexOf(":") >= 0) {
            value.split(":").forEach(function (v) {
              digits.unshift(parseFloat(v, 10));
            });

            value = 0.0;
            base = 1;

            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });

            return sign * value;
          }
          return sign * parseFloat(value, 10);
        }

        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

        function representYamlFloat(object, style) {
          var res;

          if (isNaN(object)) {
            switch (style) {
              case "lowercase":
                return ".nan";
              case "uppercase":
                return ".NAN";
              case "camelcase":
                return ".NaN";
            }
          } else if (Number.POSITIVE_INFINITY === object) {
            switch (style) {
              case "lowercase":
                return ".inf";
              case "uppercase":
                return ".INF";
              case "camelcase":
                return ".Inf";
            }
          } else if (Number.NEGATIVE_INFINITY === object) {
            switch (style) {
              case "lowercase":
                return "-.inf";
              case "uppercase":
                return "-.INF";
              case "camelcase":
                return "-.Inf";
            }
          } else if (common.isNegativeZero(object)) {
            return "-0.0";
          }

          res = object.toString(10);

          // JS stringifier can build scientific format without dots: 5e-100,
          // while YAML requres dot: 5.e-100. Fix it with simple hack

          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
        }

        function isFloat(object) {
          return (
            Object.prototype.toString.call(object) === "[object Number]" &&
            (object % 1 !== 0 || common.isNegativeZero(object))
          );
        }

        module.exports = new Type("tag:yaml.org,2002:float", {
          kind: "scalar",
          resolve: resolveYamlFloat,
          construct: constructYamlFloat,
          predicate: isFloat,
          represent: representYamlFloat,
          defaultStyle: "lowercase",
        });
      },
      { "../common": 143, "../type": 154 },
    ],
    158: [
      function (require, module, exports) {
        "use strict";

        var common = require("../common");
        var Type = require("../type");

        function isHexCode(c) {
          return (
            (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) ||
            (0x41 /* A */ <= c && c <= 0x46 /* F */) ||
            (0x61 /* a */ <= c && c <= 0x66 /* f */)
          );
        }

        function isOctCode(c) {
          return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
        }

        function isDecCode(c) {
          return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
        }

        function resolveYamlInteger(data) {
          if (data === null) return false;

          var max = data.length,
            index = 0,
            hasDigits = false,
            ch;

          if (!max) return false;

          ch = data[index];

          // sign
          if (ch === "-" || ch === "+") {
            ch = data[++index];
          }

          if (ch === "0") {
            // 0
            if (index + 1 === max) return true;
            ch = data[++index];

            // base 2, base 8, base 16

            if (ch === "b") {
              // base 2
              index++;

              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_") continue;
                if (ch !== "0" && ch !== "1") return false;
                hasDigits = true;
              }
              return hasDigits && ch !== "_";
            }

            if (ch === "x") {
              // base 16
              index++;

              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_") continue;
                if (!isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
              }
              return hasDigits && ch !== "_";
            }

            // base 8
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (!isOctCode(data.charCodeAt(index))) return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }

          // base 10 (except 0) or base 60

          // value should not start with `_`;
          if (ch === "_") return false;

          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (ch === ":") break;
            if (!isDecCode(data.charCodeAt(index))) {
              return false;
            }
            hasDigits = true;
          }

          // Should have digits and should not end with `_`
          if (!hasDigits || ch === "_") return false;

          // if !base60 - done;
          if (ch !== ":") return true;

          // base60 almost not used, no needs to optimize
          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
        }

        function constructYamlInteger(data) {
          var value = data,
            sign = 1,
            ch,
            base,
            digits = [];

          if (value.indexOf("_") !== -1) {
            value = value.replace(/_/g, "");
          }

          ch = value[0];

          if (ch === "-" || ch === "+") {
            if (ch === "-") sign = -1;
            value = value.slice(1);
            ch = value[0];
          }

          if (value === "0") return 0;

          if (ch === "0") {
            if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
            if (value[1] === "x") return sign * parseInt(value, 16);
            return sign * parseInt(value, 8);
          }

          if (value.indexOf(":") !== -1) {
            value.split(":").forEach(function (v) {
              digits.unshift(parseInt(v, 10));
            });

            value = 0;
            base = 1;

            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });

            return sign * value;
          }

          return sign * parseInt(value, 10);
        }

        function isInteger(object) {
          return (
            Object.prototype.toString.call(object) === "[object Number]" &&
            object % 1 === 0 &&
            !common.isNegativeZero(object)
          );
        }

        module.exports = new Type("tag:yaml.org,2002:int", {
          kind: "scalar",
          resolve: resolveYamlInteger,
          construct: constructYamlInteger,
          predicate: isInteger,
          represent: {
            binary: function (obj) {
              return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
            },
            octal: function (obj) {
              return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
            },
            decimal: function (obj) {
              return obj.toString(10);
            },
            /* eslint-disable max-len */
            hexadecimal: function (obj) {
              return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
            },
          },
          defaultStyle: "decimal",
          styleAliases: {
            binary: [2, "bin"],
            octal: [8, "oct"],
            decimal: [10, "dec"],
            hexadecimal: [16, "hex"],
          },
        });
      },
      { "../common": 143, "../type": 154 },
    ],
    159: [
      function (require, module, exports) {
        "use strict";

        var esprima;

        // Browserified version does not have esprima
        //
        // 1. For node.js just require module as deps
        // 2. For browser try to require mudule via external AMD system.
        //    If not found - try to fallback to window.esprima. If not
        //    found too - then fail to parse.
        //
        try {
          // workaround to exclude package from browserify list.
          var _require = require;
          esprima = _require("esprima");
        } catch (_) {
          /* eslint-disable no-redeclare */
          /* global window */
          if (typeof window !== "undefined") esprima = window.esprima;
        }

        var Type = require("../../type");

        function resolveJavascriptFunction(data) {
          if (data === null) return false;

          try {
            var source = "(" + data + ")",
              ast = esprima.parse(source, { range: true });

            if (
              ast.type !== "Program" ||
              ast.body.length !== 1 ||
              ast.body[0].type !== "ExpressionStatement" ||
              (ast.body[0].expression.type !== "ArrowFunctionExpression" &&
                ast.body[0].expression.type !== "FunctionExpression")
            ) {
              return false;
            }

            return true;
          } catch (err) {
            return false;
          }
        }

        function constructJavascriptFunction(data) {
          /*jslint evil:true*/

          var source = "(" + data + ")",
            ast = esprima.parse(source, { range: true }),
            params = [],
            body;

          if (
            ast.type !== "Program" ||
            ast.body.length !== 1 ||
            ast.body[0].type !== "ExpressionStatement" ||
            (ast.body[0].expression.type !== "ArrowFunctionExpression" &&
              ast.body[0].expression.type !== "FunctionExpression")
          ) {
            throw new Error("Failed to resolve function");
          }

          ast.body[0].expression.params.forEach(function (param) {
            params.push(param.name);
          });

          body = ast.body[0].expression.body.range;

          // Esprima's ranges include the first '{' and the last '}' characters on
          // function expressions. So cut them out.
          if (ast.body[0].expression.body.type === "BlockStatement") {
            /*eslint-disable no-new-func*/
            return new Function(params, source.slice(body[0] + 1, body[1] - 1));
          }
          // ES6 arrow functions can omit the BlockStatement. In that case, just return
          // the body.
          /*eslint-disable no-new-func*/
          return new Function(params, "return " + source.slice(body[0], body[1]));
        }

        function representJavascriptFunction(object /*, style*/) {
          return object.toString();
        }

        function isFunction(object) {
          return Object.prototype.toString.call(object) === "[object Function]";
        }

        module.exports = new Type("tag:yaml.org,2002:js/function", {
          kind: "scalar",
          resolve: resolveJavascriptFunction,
          construct: constructJavascriptFunction,
          predicate: isFunction,
          represent: representJavascriptFunction,
        });
      },
      { "../../type": 154 },
    ],
    160: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../../type");

        function resolveJavascriptRegExp(data) {
          if (data === null) return false;
          if (data.length === 0) return false;

          var regexp = data,
            tail = /\/([gim]*)$/.exec(data),
            modifiers = "";

          // if regexp starts with '/' it can have modifiers and must be properly closed
          // `/foo/gim` - modifiers tail can be maximum 3 chars
          if (regexp[0] === "/") {
            if (tail) modifiers = tail[1];

            if (modifiers.length > 3) return false;
            // if expression starts with /, is should be properly terminated
            if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
          }

          return true;
        }

        function constructJavascriptRegExp(data) {
          var regexp = data,
            tail = /\/([gim]*)$/.exec(data),
            modifiers = "";

          // `/foo/gim` - tail can be maximum 4 chars
          if (regexp[0] === "/") {
            if (tail) modifiers = tail[1];
            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
          }

          return new RegExp(regexp, modifiers);
        }

        function representJavascriptRegExp(object /*, style*/) {
          var result = "/" + object.source + "/";

          if (object.global) result += "g";
          if (object.multiline) result += "m";
          if (object.ignoreCase) result += "i";

          return result;
        }

        function isRegExp(object) {
          return Object.prototype.toString.call(object) === "[object RegExp]";
        }

        module.exports = new Type("tag:yaml.org,2002:js/regexp", {
          kind: "scalar",
          resolve: resolveJavascriptRegExp,
          construct: constructJavascriptRegExp,
          predicate: isRegExp,
          represent: representJavascriptRegExp,
        });
      },
      { "../../type": 154 },
    ],
    161: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../../type");

        function resolveJavascriptUndefined() {
          return true;
        }

        function constructJavascriptUndefined() {
          /*eslint-disable no-undefined*/
          return undefined;
        }

        function representJavascriptUndefined() {
          return "";
        }

        function isUndefined(object) {
          return typeof object === "undefined";
        }

        module.exports = new Type("tag:yaml.org,2002:js/undefined", {
          kind: "scalar",
          resolve: resolveJavascriptUndefined,
          construct: constructJavascriptUndefined,
          predicate: isUndefined,
          represent: representJavascriptUndefined,
        });
      },
      { "../../type": 154 },
    ],
    162: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        module.exports = new Type("tag:yaml.org,2002:map", {
          kind: "mapping",
          construct: function (data) {
            return data !== null ? data : {};
          },
        });
      },
      { "../type": 154 },
    ],
    163: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        function resolveYamlMerge(data) {
          return data === "<<" || data === null;
        }

        module.exports = new Type("tag:yaml.org,2002:merge", {
          kind: "scalar",
          resolve: resolveYamlMerge,
        });
      },
      { "../type": 154 },
    ],
    164: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        function resolveYamlNull(data) {
          if (data === null) return true;

          var max = data.length;

          return (max === 1 && data === "~") || (max === 4 && (data === "null" || data === "Null" || data === "NULL"));
        }

        function constructYamlNull() {
          return null;
        }

        function isNull(object) {
          return object === null;
        }

        module.exports = new Type("tag:yaml.org,2002:null", {
          kind: "scalar",
          resolve: resolveYamlNull,
          construct: constructYamlNull,
          predicate: isNull,
          represent: {
            canonical: function () {
              return "~";
            },
            lowercase: function () {
              return "null";
            },
            uppercase: function () {
              return "NULL";
            },
            camelcase: function () {
              return "Null";
            },
          },
          defaultStyle: "lowercase",
        });
      },
      { "../type": 154 },
    ],
    165: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var _toString = Object.prototype.toString;

        function resolveYamlOmap(data) {
          if (data === null) return true;

          var objectKeys = [],
            index,
            length,
            pair,
            pairKey,
            pairHasKey,
            object = data;

          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            pairHasKey = false;

            if (_toString.call(pair) !== "[object Object]") return false;

            for (pairKey in pair) {
              if (_hasOwnProperty.call(pair, pairKey)) {
                if (!pairHasKey) pairHasKey = true;
                else return false;
              }
            }

            if (!pairHasKey) return false;

            if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
            else return false;
          }

          return true;
        }

        function constructYamlOmap(data) {
          return data !== null ? data : [];
        }

        module.exports = new Type("tag:yaml.org,2002:omap", {
          kind: "sequence",
          resolve: resolveYamlOmap,
          construct: constructYamlOmap,
        });
      },
      { "../type": 154 },
    ],
    166: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        var _toString = Object.prototype.toString;

        function resolveYamlPairs(data) {
          if (data === null) return true;

          var index,
            length,
            pair,
            keys,
            result,
            object = data;

          result = new Array(object.length);

          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];

            if (_toString.call(pair) !== "[object Object]") return false;

            keys = Object.keys(pair);

            if (keys.length !== 1) return false;

            result[index] = [keys[0], pair[keys[0]]];
          }

          return true;
        }

        function constructYamlPairs(data) {
          if (data === null) return [];

          var index,
            length,
            pair,
            keys,
            result,
            object = data;

          result = new Array(object.length);

          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];

            keys = Object.keys(pair);

            result[index] = [keys[0], pair[keys[0]]];
          }

          return result;
        }

        module.exports = new Type("tag:yaml.org,2002:pairs", {
          kind: "sequence",
          resolve: resolveYamlPairs,
          construct: constructYamlPairs,
        });
      },
      { "../type": 154 },
    ],
    167: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        module.exports = new Type("tag:yaml.org,2002:seq", {
          kind: "sequence",
          construct: function (data) {
            return data !== null ? data : [];
          },
        });
      },
      { "../type": 154 },
    ],
    168: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        var _hasOwnProperty = Object.prototype.hasOwnProperty;

        function resolveYamlSet(data) {
          if (data === null) return true;

          var key,
            object = data;

          for (key in object) {
            if (_hasOwnProperty.call(object, key)) {
              if (object[key] !== null) return false;
            }
          }

          return true;
        }

        function constructYamlSet(data) {
          return data !== null ? data : {};
        }

        module.exports = new Type("tag:yaml.org,2002:set", {
          kind: "mapping",
          resolve: resolveYamlSet,
          construct: constructYamlSet,
        });
      },
      { "../type": 154 },
    ],
    169: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        module.exports = new Type("tag:yaml.org,2002:str", {
          kind: "scalar",
          construct: function (data) {
            return data !== null ? data : "";
          },
        });
      },
      { "../type": 154 },
    ],
    170: [
      function (require, module, exports) {
        "use strict";

        var Type = require("../type");

        var YAML_DATE_REGEXP = new RegExp(
          "^([0-9][0-9][0-9][0-9])" + // [1] year
            "-([0-9][0-9])" + // [2] month
            "-([0-9][0-9])$",
        ); // [3] day

        var YAML_TIMESTAMP_REGEXP = new RegExp(
          "^([0-9][0-9][0-9][0-9])" + // [1] year
            "-([0-9][0-9]?)" + // [2] month
            "-([0-9][0-9]?)" + // [3] day
            "(?:[Tt]|[ \\t]+)" + // ...
            "([0-9][0-9]?)" + // [4] hour
            ":([0-9][0-9])" + // [5] minute
            ":([0-9][0-9])" + // [6] second
            "(?:\\.([0-9]*))?" + // [7] fraction
            "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + // [8] tz [9] tz_sign [10] tz_hour
            "(?::([0-9][0-9]))?))?$",
        ); // [11] tz_minute

        function resolveYamlTimestamp(data) {
          if (data === null) return false;
          if (YAML_DATE_REGEXP.exec(data) !== null) return true;
          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
          return false;
        }

        function constructYamlTimestamp(data) {
          var match,
            year,
            month,
            day,
            hour,
            minute,
            second,
            fraction = 0,
            delta = null,
            tz_hour,
            tz_minute,
            date;

          match = YAML_DATE_REGEXP.exec(data);
          if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

          if (match === null) throw new Error("Date resolve error");

          // match: [1] year [2] month [3] day

          year = +match[1];
          month = +match[2] - 1; // JS month starts with 0
          day = +match[3];

          if (!match[4]) {
            // no hour
            return new Date(Date.UTC(year, month, day));
          }

          // match: [4] hour [5] minute [6] second [7] fraction

          hour = +match[4];
          minute = +match[5];
          second = +match[6];

          if (match[7]) {
            fraction = match[7].slice(0, 3);
            while (fraction.length < 3) {
              // milli-seconds
              fraction += "0";
            }
            fraction = +fraction;
          }

          // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

          if (match[9]) {
            tz_hour = +match[10];
            tz_minute = +(match[11] || 0);
            delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
            if (match[9] === "-") delta = -delta;
          }

          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

          if (delta) date.setTime(date.getTime() - delta);

          return date;
        }

        function representYamlTimestamp(object /*, style*/) {
          return object.toISOString();
        }

        module.exports = new Type("tag:yaml.org,2002:timestamp", {
          kind: "scalar",
          resolve: resolveYamlTimestamp,
          construct: constructYamlTimestamp,
          instanceOf: Date,
          represent: representYamlTimestamp,
        });
      },
      { "../type": 154 },
    ],
    171: [
      function (require, module, exports) {
        "use strict";

        var traverse = (module.exports = function (schema, opts, cb) {
          // Legacy support for v0.3.1 and earlier.
          if (typeof opts == "function") {
            cb = opts;
            opts = {};
          }

          cb = opts.cb || cb;
          var pre = typeof cb == "function" ? cb : cb.pre || function () {};
          var post = cb.post || function () {};

          _traverse(opts, pre, post, schema, "", schema);
        });

        traverse.keywords = {
          additionalItems: true,
          items: true,
          contains: true,
          additionalProperties: true,
          propertyNames: true,
          not: true,
          if: true,
          then: true,
          else: true,
        };

        traverse.arrayKeywords = {
          items: true,
          allOf: true,
          anyOf: true,
          oneOf: true,
        };

        traverse.propsKeywords = {
          $defs: true,
          definitions: true,
          properties: true,
          patternProperties: true,
          dependencies: true,
        };

        traverse.skipKeywords = {
          default: true,
          enum: true,
          const: true,
          required: true,
          maximum: true,
          minimum: true,
          exclusiveMaximum: true,
          exclusiveMinimum: true,
          multipleOf: true,
          maxLength: true,
          minLength: true,
          pattern: true,
          format: true,
          maxItems: true,
          minItems: true,
          uniqueItems: true,
          maxProperties: true,
          minProperties: true,
        };

        function _traverse(
          opts,
          pre,
          post,
          schema,
          jsonPtr,
          rootSchema,
          parentJsonPtr,
          parentKeyword,
          parentSchema,
          keyIndex,
        ) {
          if (schema && typeof schema == "object" && !Array.isArray(schema)) {
            pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
            for (var key in schema) {
              var sch = schema[key];
              if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) {
                  for (var i = 0; i < sch.length; i++)
                    _traverse(
                      opts,
                      pre,
                      post,
                      sch[i],
                      jsonPtr + "/" + key + "/" + i,
                      rootSchema,
                      jsonPtr,
                      key,
                      schema,
                      i,
                    );
                }
              } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == "object") {
                  for (var prop in sch)
                    _traverse(
                      opts,
                      pre,
                      post,
                      sch[prop],
                      jsonPtr + "/" + key + "/" + escapeJsonPtr(prop),
                      rootSchema,
                      jsonPtr,
                      key,
                      schema,
                      prop,
                    );
                }
              } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
                _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
              }
            }
            post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          }
        }

        function escapeJsonPtr(str) {
          return str.replace(/~/g, "~0").replace(/\//g, "~1");
        }
      },
      {},
    ],
    172: [
      function (require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {});

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function () {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ""; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
          return [];
        };

        process.binding = function (name) {
          throw new Error("process.binding is not supported");
        };

        process.cwd = function () {
          return "/";
        };
        process.chdir = function (dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function () {
          return 0;
        };
      },
      {},
    ],
    173: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            /*! https://mths.be/punycode v1.4.1 by @mathias */
            (function (root) {
              /** Detect free variables */
              var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
              var freeModule = typeof module == "object" && module && !module.nodeType && module;
              var freeGlobal = typeof global == "object" && global;
              if (
                freeGlobal.global === freeGlobal ||
                freeGlobal.window === freeGlobal ||
                freeGlobal.self === freeGlobal
              ) {
                root = freeGlobal;
              }

              /**
               * The `punycode` object.
               * @name punycode
               * @type Object
               */
              var punycode,
                /** Highest positive signed 32-bit float value */
                maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
                /** Bootstring parameters */
                base = 36,
                tMin = 1,
                tMax = 26,
                skew = 38,
                damp = 700,
                initialBias = 72,
                initialN = 128, // 0x80
                delimiter = "-", // '\x2D'
                /** Regular expressions */
                regexPunycode = /^xn--/,
                regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
                /** Error messages */
                errors = {
                  overflow: "Overflow: input needs wider integers to process",
                  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                  "invalid-input": "Invalid input",
                },
                /** Convenience shortcuts */
                baseMinusTMin = base - tMin,
                floor = Math.floor,
                stringFromCharCode = String.fromCharCode,
                /** Temporary variable */
                key;

              /*--------------------------------------------------------------------------*/

              /**
               * A generic error utility function.
               * @private
               * @param {String} type The error type.
               * @returns {Error} Throws a `RangeError` with the applicable error message.
               */
              function error(type) {
                throw new RangeError(errors[type]);
              }

              /**
               * A generic `Array#map` utility function.
               * @private
               * @param {Array} array The array to iterate over.
               * @param {Function} callback The function that gets called for every array
               * item.
               * @returns {Array} A new array of values returned by the callback function.
               */
              function map(array, fn) {
                var length = array.length;
                var result = [];
                while (length--) {
                  result[length] = fn(array[length]);
                }
                return result;
              }

              /**
               * A simple `Array#map`-like wrapper to work with domain name strings or email
               * addresses.
               * @private
               * @param {String} domain The domain name or email address.
               * @param {Function} callback The function that gets called for every
               * character.
               * @returns {Array} A new string of characters returned by the callback
               * function.
               */
              function mapDomain(string, fn) {
                var parts = string.split("@");
                var result = "";
                if (parts.length > 1) {
                  // In email addresses, only the domain name should be punycoded. Leave
                  // the local part (i.e. everything up to `@`) intact.
                  result = parts[0] + "@";
                  string = parts[1];
                }
                // Avoid `split(regex)` for IE8 compatibility. See #17.
                string = string.replace(regexSeparators, "\x2E");
                var labels = string.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
              }

              /**
               * Creates an array containing the numeric code points of each Unicode
               * character in the string. While JavaScript uses UCS-2 internally,
               * this function will convert a pair of surrogate halves (each of which
               * UCS-2 exposes as separate characters) into a single code point,
               * matching UTF-16.
               * @see `punycode.ucs2.encode`
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode.ucs2
               * @name decode
               * @param {String} string The Unicode input string (UCS-2).
               * @returns {Array} The new array of code points.
               */
              function ucs2decode(string) {
                var output = [],
                  counter = 0,
                  length = string.length,
                  value,
                  extra;
                while (counter < length) {
                  value = string.charCodeAt(counter++);
                  if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                    // high surrogate, and there is a next character
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xfc00) == 0xdc00) {
                      // low surrogate
                      output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                    } else {
                      // unmatched surrogate; only append this code unit, in case the next
                      // code unit is the high surrogate of a surrogate pair
                      output.push(value);
                      counter--;
                    }
                  } else {
                    output.push(value);
                  }
                }
                return output;
              }

              /**
               * Creates a string based on an array of numeric code points.
               * @see `punycode.ucs2.decode`
               * @memberOf punycode.ucs2
               * @name encode
               * @param {Array} codePoints The array of numeric code points.
               * @returns {String} The new Unicode string (UCS-2).
               */
              function ucs2encode(array) {
                return map(array, function (value) {
                  var output = "";
                  if (value > 0xffff) {
                    value -= 0x10000;
                    output += stringFromCharCode(((value >>> 10) & 0x3ff) | 0xd800);
                    value = 0xdc00 | (value & 0x3ff);
                  }
                  output += stringFromCharCode(value);
                  return output;
                }).join("");
              }

              /**
               * Converts a basic code point into a digit/integer.
               * @see `digitToBasic()`
               * @private
               * @param {Number} codePoint The basic numeric code point value.
               * @returns {Number} The numeric value of a basic code point (for use in
               * representing integers) in the range `0` to `base - 1`, or `base` if
               * the code point does not represent a value.
               */
              function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                  return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                  return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                  return codePoint - 97;
                }
                return base;
              }

              /**
               * Converts a digit/integer into a basic code point.
               * @see `basicToDigit()`
               * @private
               * @param {Number} digit The numeric value of a basic code point.
               * @returns {Number} The basic code point whose value (when used for
               * representing integers) is `digit`, which needs to be in the range
               * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
               * used; else, the lowercase form is used. The behavior is undefined
               * if `flag` is non-zero and `digit` has no uppercase form.
               */
              function digitToBasic(digit, flag) {
                //  0..25 map to ASCII a..z or A..Z
                // 26..35 map to ASCII 0..9
                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
              }

              /**
               * Bias adaptation function as per section 3.4 of RFC 3492.
               * https://tools.ietf.org/html/rfc3492#section-3.4
               * @private
               */
              function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {
                  delta = floor(delta / baseMinusTMin);
                }
                return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
              }

              /**
               * Converts a Punycode string of ASCII-only symbols to a string of Unicode
               * symbols.
               * @memberOf punycode
               * @param {String} input The Punycode string of ASCII-only symbols.
               * @returns {String} The resulting string of Unicode symbols.
               */
              function decode(input) {
                // Don't use UCS-2
                var output = [],
                  inputLength = input.length,
                  out,
                  i = 0,
                  n = initialN,
                  bias = initialBias,
                  basic,
                  j,
                  index,
                  oldi,
                  w,
                  k,
                  digit,
                  t,
                  /** Cached calculation results */
                  baseMinusT;

                // Handle the basic code points: let `basic` be the number of input code
                // points before the last delimiter, or `0` if there is none, then copy
                // the first basic code points to the output.

                basic = input.lastIndexOf(delimiter);
                if (basic < 0) {
                  basic = 0;
                }

                for (j = 0; j < basic; ++j) {
                  // if it's not a basic code point
                  if (input.charCodeAt(j) >= 0x80) {
                    error("not-basic");
                  }
                  output.push(input.charCodeAt(j));
                }

                // Main decoding loop: start just after the last delimiter if any basic code
                // points were copied; start at the beginning otherwise.

                for (index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */; ) {
                  // `index` is the index of the next character to be consumed.
                  // Decode a generalized variable-length integer into `delta`,
                  // which gets added to `i`. The overflow checking is easier
                  // if we increase `i` as we go, then subtract off its starting
                  // value at the end to obtain `delta`.
                  for (oldi = i, w = 1, k = base /* no condition */; ; k += base) {
                    if (index >= inputLength) {
                      error("invalid-input");
                    }

                    digit = basicToDigit(input.charCodeAt(index++));

                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                      error("overflow");
                    }

                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                    if (digit < t) {
                      break;
                    }

                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                      error("overflow");
                    }

                    w *= baseMinusT;
                  }

                  out = output.length + 1;
                  bias = adapt(i - oldi, out, oldi == 0);

                  // `i` was supposed to wrap around from `out` to `0`,
                  // incrementing `n` each time, so we'll fix that now:
                  if (floor(i / out) > maxInt - n) {
                    error("overflow");
                  }

                  n += floor(i / out);
                  i %= out;

                  // Insert `n` at position `i` of the output
                  output.splice(i++, 0, n);
                }

                return ucs2encode(output);
              }

              /**
               * Converts a string of Unicode symbols (e.g. a domain name label) to a
               * Punycode string of ASCII-only symbols.
               * @memberOf punycode
               * @param {String} input The string of Unicode symbols.
               * @returns {String} The resulting Punycode string of ASCII-only symbols.
               */
              function encode(input) {
                var n,
                  delta,
                  handledCPCount,
                  basicLength,
                  bias,
                  j,
                  m,
                  q,
                  k,
                  t,
                  currentValue,
                  output = [],
                  /** `inputLength` will hold the number of code points in `input`. */
                  inputLength,
                  /** Cached calculation results */
                  handledCPCountPlusOne,
                  baseMinusT,
                  qMinusT;

                // Convert the input in UCS-2 to Unicode
                input = ucs2decode(input);

                // Cache the length
                inputLength = input.length;

                // Initialize the state
                n = initialN;
                delta = 0;
                bias = initialBias;

                // Handle the basic code points
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                  }
                }

                handledCPCount = basicLength = output.length;

                // `handledCPCount` is the number of code points that have been handled;
                // `basicLength` is the number of basic code points.

                // Finish the basic string - if it is not empty - with a delimiter
                if (basicLength) {
                  output.push(delimiter);
                }

                // Main encoding loop:
                while (handledCPCount < inputLength) {
                  // All non-basic code points < n have been handled already. Find the next
                  // larger one:
                  for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue;
                    }
                  }

                  // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                  // but guard against overflow
                  handledCPCountPlusOne = handledCPCount + 1;
                  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error("overflow");
                  }

                  delta += (m - n) * handledCPCountPlusOne;
                  n = m;

                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];

                    if (currentValue < n && ++delta > maxInt) {
                      error("overflow");
                    }

                    if (currentValue == n) {
                      // Represent delta as a generalized variable-length integer
                      for (q = delta, k = base /* no condition */; ; k += base) {
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) {
                          break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));
                        q = floor(qMinusT / baseMinusT);
                      }

                      output.push(stringFromCharCode(digitToBasic(q, 0)));
                      bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                      delta = 0;
                      ++handledCPCount;
                    }
                  }

                  ++delta;
                  ++n;
                }
                return output.join("");
              }

              /**
               * Converts a Punycode string representing a domain name or an email address
               * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
               * it doesn't matter if you call it on a string that has already been
               * converted to Unicode.
               * @memberOf punycode
               * @param {String} input The Punycoded domain name or email address to
               * convert to Unicode.
               * @returns {String} The Unicode representation of the given Punycode
               * string.
               */
              function toUnicode(input) {
                return mapDomain(input, function (string) {
                  return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                });
              }

              /**
               * Converts a Unicode string representing a domain name or an email address to
               * Punycode. Only the non-ASCII parts of the domain name will be converted,
               * i.e. it doesn't matter if you call it with a domain that's already in
               * ASCII.
               * @memberOf punycode
               * @param {String} input The domain name or email address to convert, as a
               * Unicode string.
               * @returns {String} The Punycode representation of the given domain name or
               * email address.
               */
              function toASCII(input) {
                return mapDomain(input, function (string) {
                  return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                });
              }

              /*--------------------------------------------------------------------------*/

              /** Define the public API */
              punycode = {
                /**
                 * A string representing the current Punycode.js version number.
                 * @memberOf punycode
                 * @type String
                 */
                version: "1.4.1",
                /**
                 * An object of methods to convert from JavaScript's internal character
                 * representation (UCS-2) to Unicode code points, and back.
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode
                 * @type Object
                 */
                ucs2: {
                  decode: ucs2decode,
                  encode: ucs2encode,
                },
                decode: decode,
                encode: encode,
                toASCII: toASCII,
                toUnicode: toUnicode,
              };

              /** Expose `punycode` */
              // Some AMD build optimizers, like r.js, check for specific condition patterns
              // like the following:
              if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                define("punycode", function () {
                  return punycode;
                });
              } else if (freeExports && freeModule) {
                if (module.exports == freeExports) {
                  // in Node.js, io.js, or RingoJS v0.8.0+
                  freeModule.exports = punycode;
                } else {
                  // in Narwhal or RingoJS v0.7.0-
                  for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                  }
                }
              } else {
                // in Rhino or a web browser
                root.punycode = punycode;
              }
            })(this);
          }).call(this);
        }).call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      {},
    ],
    174: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        module.exports = function (qs, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};

          if (typeof qs !== "string" || qs.length === 0) {
            return obj;
          }

          var regexp = /\+/g;
          qs = qs.split(sep);

          var maxKeys = 1000;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }

          var len = qs.length;
          // maxKeys <= 0 means that we should not limit keys count
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }

          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, "%20"),
              idx = x.indexOf(eq),
              kstr,
              vstr,
              k,
              v;

            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }

            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);

            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }

          return obj;
        };

        var isArray =
          Array.isArray ||
          function (xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };
      },
      {},
    ],
    175: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        var stringifyPrimitive = function (v) {
          switch (typeof v) {
            case "string":
              return v;

            case "boolean":
              return v ? "true" : "false";

            case "number":
              return isFinite(v) ? v : "";

            default:
              return "";
          }
        };

        module.exports = function (obj, sep, eq, name) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = undefined;
          }

          if (typeof obj === "object") {
            return map(objectKeys(obj), function (k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function (v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }

          if (!name) return "";
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };

        var isArray =
          Array.isArray ||
          function (xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };

        function map(xs, f) {
          if (xs.map) return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }

        var objectKeys =
          Object.keys ||
          function (obj) {
            var res = [];
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
          };
      },
      {},
    ],
    176: [
      function (require, module, exports) {
        "use strict";

        exports.decode = exports.parse = require("./decode");
        exports.encode = exports.stringify = require("./encode");
      },
      { "./decode": 174, "./encode": 175 },
    ],
    177: [
      function (require, module, exports) {
        "use strict";

        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }

        var codes = {};

        function createErrorType(code, message, Base) {
          if (!Base) {
            Base = Error;
          }

          function getMessage(arg1, arg2, arg3) {
            if (typeof message === "string") {
              return message;
            } else {
              return message(arg1, arg2, arg3);
            }
          }

          var NodeError =
            /*#__PURE__*/
            (function (_Base) {
              _inheritsLoose(NodeError, _Base);

              function NodeError(arg1, arg2, arg3) {
                return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
              }

              return NodeError;
            })(Base);

          NodeError.prototype.name = Base.name;
          NodeError.prototype.code = code;
          codes[code] = NodeError;
        } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

        function oneOf(expected, thing) {
          if (Array.isArray(expected)) {
            var len = expected.length;
            expected = expected.map(function (i) {
              return String(i);
            });

            if (len > 2) {
              return (
                "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1]
              );
            } else if (len === 2) {
              return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
            } else {
              return "of ".concat(thing, " ").concat(expected[0]);
            }
          } else {
            return "of ".concat(thing, " ").concat(String(expected));
          }
        } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

        function startsWith(str, search, pos) {
          return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

        function endsWith(str, search, this_len) {
          if (this_len === undefined || this_len > str.length) {
            this_len = str.length;
          }

          return str.substring(this_len - search.length, this_len) === search;
        } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

        function includes(str, search, start) {
          if (typeof start !== "number") {
            start = 0;
          }

          if (start + search.length > str.length) {
            return false;
          } else {
            return str.indexOf(search, start) !== -1;
          }
        }

        createErrorType(
          "ERR_INVALID_OPT_VALUE",
          function (name, value) {
            return 'The value "' + value + '" is invalid for option "' + name + '"';
          },
          TypeError,
        );
        createErrorType(
          "ERR_INVALID_ARG_TYPE",
          function (name, expected, actual) {
            // determiner: 'must be' or 'must not be'
            var determiner;

            if (typeof expected === "string" && startsWith(expected, "not ")) {
              determiner = "must not be";
              expected = expected.replace(/^not /, "");
            } else {
              determiner = "must be";
            }

            var msg;

            if (endsWith(name, " argument")) {
              // For cases like 'first argument'
              msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
            } else {
              var type = includes(name, ".") ? "property" : "argument";
              msg = 'The "'
                .concat(name, '" ')
                .concat(type, " ")
                .concat(determiner, " ")
                .concat(oneOf(expected, "type"));
            }

            msg += ". Received type ".concat(typeof actual);
            return msg;
          },
          TypeError,
        );
        createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
        createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function (name) {
          return "The " + name + " method is not implemented";
        });
        createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
        createErrorType("ERR_STREAM_DESTROYED", function (name) {
          return "Cannot call " + name + " after a stream was destroyed";
        });
        createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
        createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
        createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
        createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        createErrorType(
          "ERR_UNKNOWN_ENCODING",
          function (arg) {
            return "Unknown encoding: " + arg;
          },
          TypeError,
        );
        createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
        module.exports.codes = codes;
      },
      {},
    ],
    178: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            // a duplex stream is just a stream that is both readable and writable.
            // Since JS doesn't have multiple prototypal inheritance, this class
            // prototypally inherits from Readable, and then parasitically from
            // Writable.
            "use strict";
            /*<replacement>*/

            var objectKeys =
              Object.keys ||
              function (obj) {
                var keys = [];

                for (var key in obj) {
                  keys.push(key);
                }

                return keys;
              };
            /*</replacement>*/

            module.exports = Duplex;

            var Readable = require("./_stream_readable");

            var Writable = require("./_stream_writable");

            require("inherits")(Duplex, Readable);

            {
              // Allow the keys array to be GC'ed.
              var keys = objectKeys(Writable.prototype);

              for (var v = 0; v < keys.length; v++) {
                var method = keys[v];
                if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
              }
            }

            function Duplex(options) {
              if (!(this instanceof Duplex)) return new Duplex(options);
              Readable.call(this, options);
              Writable.call(this, options);
              this.allowHalfOpen = true;

              if (options) {
                if (options.readable === false) this.readable = false;
                if (options.writable === false) this.writable = false;

                if (options.allowHalfOpen === false) {
                  this.allowHalfOpen = false;
                  this.once("end", onend);
                }
              }
            }

            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              },
            });
            Object.defineProperty(Duplex.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              },
            });
            Object.defineProperty(Duplex.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              },
            }); // the no-half-open enforcer

            function onend() {
              // If the writable side ended, then we're ok.
              if (this._writableState.ended) return; // no more data can be written.
              // But allow more writes to happen in this tick.

              process.nextTick(onEndNT, this);
            }

            function onEndNT(self) {
              self.end();
            }

            Object.defineProperty(Duplex.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._readableState === undefined || this._writableState === undefined) {
                  return false;
                }

                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function set(value) {
                // we ignore the value if the stream
                // has not been initialized yet
                if (this._readableState === undefined || this._writableState === undefined) {
                  return;
                } // backward compatibility, the user is explicitly
                // managing destroyed

                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              },
            });
          }).call(this);
        }).call(this, require("_process"));
      },
      { "./_stream_readable": 180, "./_stream_writable": 182, _process: 172, inherits: 139 },
    ],
    179: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.
        "use strict";

        module.exports = PassThrough;

        var Transform = require("./_stream_transform");

        require("inherits")(PassThrough, Transform);

        function PassThrough(options) {
          if (!(this instanceof PassThrough)) return new PassThrough(options);
          Transform.call(this, options);
        }

        PassThrough.prototype._transform = function (chunk, encoding, cb) {
          cb(null, chunk);
        };
      },
      { "./_stream_transform": 181, inherits: 139 },
    ],
    180: [
      function (require, module, exports) {
        (function (process, global) {
          (function () {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            "use strict";

            module.exports = Readable;
            /*<replacement>*/

            var Duplex;
            /*</replacement>*/

            Readable.ReadableState = ReadableState;
            /*<replacement>*/

            var EE = require("events").EventEmitter;

            var EElistenerCount = function EElistenerCount(emitter, type) {
              return emitter.listeners(type).length;
            };
            /*</replacement>*/

            /*<replacement>*/

            var Stream = require("./internal/streams/stream");
            /*</replacement>*/

            var Buffer = require("buffer").Buffer;

            var OurUint8Array = global.Uint8Array || function () {};

            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }

            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            /*<replacement>*/

            var debugUtil = require("util");

            var debug;

            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function debug() {};
            }
            /*</replacement>*/

            var BufferList = require("./internal/streams/buffer_list");

            var destroyImpl = require("./internal/streams/destroy");

            var _require = require("./internal/streams/state"),
              getHighWaterMark = _require.getHighWaterMark;

            var _require$codes = require("../errors").codes,
              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
              ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
              ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.

            var StringDecoder;
            var createReadableStreamAsyncIterator;
            var from;

            require("inherits")(Readable, Stream);

            var errorOrDestroy = destroyImpl.errorOrDestroy;
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];

            function prependListener(emitter, event, fn) {
              // Sadly this is not cacheable as some libraries bundle their own
              // event emitter implementation with them.
              if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
              // userland ones.  NEVER DO THIS. This is here only because this code needs
              // to continue to work with older versions of Node.js that do not include
              // the prependListener() method. The goal is to eventually remove this hack.

              if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
              else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
              else emitter._events[event] = [fn, emitter._events[event]];
            }

            function ReadableState(options, stream, isDuplex) {
              Duplex = Duplex || require("./_stream_duplex");
              options = options || {}; // Duplex streams are both readable and writable, but share
              // the same options object.
              // However, some cases require setting options to different
              // values for the readable and the writable sides of the duplex stream.
              // These options can be provided separately as readableXXX and writableXXX.

              if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
              // make all the buffer merging and length checks go away

              this.objectMode = !!options.objectMode;
              if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
              // Note: 0 is a valid value, means "don't call _read preemptively ever"

              this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex); // A linked list is used to store data chunks instead of an array because the
              // linked list can remove elements from the beginning faster than
              // array.shift()

              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
              // immediately, or on a later tick.  We set this to true at first, because
              // any actions that shouldn't happen until "later" should generally also
              // not happen before the first read call.

              this.sync = true; // whenever we return null, then we set a flag to say
              // that we're awaiting a 'readable' event emission.

              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.paused = true; // Should close be emitted on destroy. Defaults to true.

              this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

              this.autoDestroy = !!options.autoDestroy; // has it been destroyed

              this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
              // encoding is 'binary' so we have to make this configurable.
              // Everything else in the universe uses 'utf8', though.

              this.defaultEncoding = options.defaultEncoding || "utf8"; // the number of writers that are awaiting a drain event in .pipe()s

              this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;

              if (options.encoding) {
                if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }

            function Readable(options) {
              Duplex = Duplex || require("./_stream_duplex");
              if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
              // the ReadableState constructor, at least with V8 6.5

              var isDuplex = this instanceof Duplex;
              this._readableState = new ReadableState(options, this, isDuplex); // legacy

              this.readable = true;

              if (options) {
                if (typeof options.read === "function") this._read = options.read;
                if (typeof options.destroy === "function") this._destroy = options.destroy;
              }

              Stream.call(this);
            }

            Object.defineProperty(Readable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._readableState === undefined) {
                  return false;
                }

                return this._readableState.destroyed;
              },
              set: function set(value) {
                // we ignore the value if the stream
                // has not been initialized yet
                if (!this._readableState) {
                  return;
                } // backward compatibility, the user is explicitly
                // managing destroyed

                this._readableState.destroyed = value;
              },
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;

            Readable.prototype._destroy = function (err, cb) {
              cb(err);
            }; // Manually shove something into the read() buffer.
            // This returns true if the highWaterMark has not been hit yet,
            // similar to how Writable.write() returns true if you should
            // write() some more.

            Readable.prototype.push = function (chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;

              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding = encoding || state.defaultEncoding;

                  if (encoding !== state.encoding) {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = "";
                  }

                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }

              return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            }; // Unshift should *always* be something directly out of read()

            Readable.prototype.unshift = function (chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };

            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
              debug("readableAddChunk", chunk);
              var state = stream._readableState;

              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck) er = chunkInvalid(state, chunk);

                if (er) {
                  errorOrDestroy(stream, er);
                } else if (state.objectMode || (chunk && chunk.length > 0)) {
                  if (
                    typeof chunk !== "string" &&
                    !state.objectMode &&
                    Object.getPrototypeOf(chunk) !== Buffer.prototype
                  ) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }

                  if (addToFront) {
                    if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                    else addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                  } else if (state.destroyed) {
                    return false;
                  } else {
                    state.reading = false;

                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                      else maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                  maybeReadMore(stream, state);
                }
              } // We can push more data if we are below the highWaterMark.
              // Also, if we have no data yet, we can stand some more bytes.
              // This is to work around cases where hwm=0, such as the repl.

              return !state.ended && (state.length < state.highWaterMark || state.length === 0);
            }

            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                state.awaitDrain = 0;
                stream.emit("data", chunk);
              } else {
                // update the buffer info.
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) state.buffer.unshift(chunk);
                else state.buffer.push(chunk);
                if (state.needReadable) emitReadable(stream);
              }

              maybeReadMore(stream, state);
            }

            function chunkInvalid(state, chunk) {
              var er;

              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
              }

              return er;
            }

            Readable.prototype.isPaused = function () {
              return this._readableState.flowing === false;
            }; // backwards compatibility.

            Readable.prototype.setEncoding = function (enc) {
              if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
              var decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

              this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

              var p = this._readableState.buffer.head;
              var content = "";

              while (p !== null) {
                content += decoder.write(p.data);
                p = p.next;
              }

              this._readableState.buffer.clear();

              if (content !== "") this._readableState.buffer.push(content);
              this._readableState.length = content.length;
              return this;
            }; // Don't raise the hwm > 1GB

            var MAX_HWM = 0x40000000;

            function computeNewHighWaterMark(n) {
              if (n >= MAX_HWM) {
                // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
                n = MAX_HWM;
              } else {
                // Get the next highest power of 2 to prevent increasing hwm excessively in
                // tiny amounts
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
              }

              return n;
            } // This function is designed to be inlinable, so please take care when making
            // changes to the function body.

            function howMuchToRead(n, state) {
              if (n <= 0 || (state.length === 0 && state.ended)) return 0;
              if (state.objectMode) return 1;

              if (n !== n) {
                // Only flow one buffer at a time
                if (state.flowing && state.length) return state.buffer.head.data.length;
                else return state.length;
              } // If we're asking for more than the current hwm, then raise the hwm.

              if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
              if (n <= state.length) return n; // Don't have enough

              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }

              return state.length;
            } // you can override either this method, or the async _read(n) below.

            Readable.prototype.read = function (n) {
              debug("read", n);
              n = parseInt(n, 10);
              var state = this._readableState;
              var nOrig = n;
              if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
              // already have a bunch of data in the buffer, then just trigger
              // the 'readable' event and move on.

              if (
                n === 0 &&
                state.needReadable &&
                ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)
              ) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended) endReadable(this);
                else emitReadable(this);
                return null;
              }

              n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

              if (n === 0 && state.ended) {
                if (state.length === 0) endReadable(this);
                return null;
              } // All the actual chunk generation logic needs to be
              // *below* the call to _read.  The reason is that in certain
              // synthetic stream cases, such as passthrough streams, _read
              // may be a completely synchronous operation which may change
              // the state of the read buffer, providing enough data when
              // before there was *not* enough.
              //
              // So, the steps are:
              // 1. Figure out what the state of things will be after we do
              // a read from the buffer.
              //
              // 2. If that resulting state will trigger a _read, then call _read.
              // Note that this may be asynchronous, or synchronous.  Yes, it is
              // deeply ugly to write APIs this way, but that still doesn't mean
              // that the Readable class should behave improperly, as streams are
              // designed to be sync/async agnostic.
              // Take note if the _read call is sync or async (ie, if the read call
              // has returned yet), so that we know whether or not it's safe to emit
              // 'readable' etc.
              //
              // 3. Actually pull the requested chunks out of the buffer and return.
              // if we need a readable event, then we need to do some reading.

              var doRead = state.needReadable;
              debug("need readable", doRead); // if we currently have less than the highWaterMark, then also read some

              if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              } // however, if we've ended, then there's no point, and if we're already
              // reading, then it's unnecessary.

              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true; // if the length is currently zero, then we *need* a readable event.

                if (state.length === 0) state.needReadable = true; // call internal read method

                this._read(state.highWaterMark);

                state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
                // and we need to re-evaluate how much data we can return to the user.

                if (!state.reading) n = howMuchToRead(nOrig, state);
              }

              var ret;
              if (n > 0) ret = fromList(n, state);
              else ret = null;

              if (ret === null) {
                state.needReadable = state.length <= state.highWaterMark;
                n = 0;
              } else {
                state.length -= n;
                state.awaitDrain = 0;
              }

              if (state.length === 0) {
                // If we have nothing in the buffer, then we want to know
                // as soon as we *do* get something into the buffer.
                if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

                if (nOrig !== n && state.ended) endReadable(this);
              }

              if (ret !== null) this.emit("data", ret);
              return ret;
            };

            function onEofChunk(stream, state) {
              debug("onEofChunk");
              if (state.ended) return;

              if (state.decoder) {
                var chunk = state.decoder.end();

                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }

              state.ended = true;

              if (state.sync) {
                // if we are sync, wait until next tick to emit the data.
                // Otherwise we risk emitting data in the flow()
                // the readable code triggers during a read() call
                emitReadable(stream);
              } else {
                // emit 'readable' now to make sure it gets picked up.
                state.needReadable = false;

                if (!state.emittedReadable) {
                  state.emittedReadable = true;
                  emitReadable_(stream);
                }
              }
            } // Don't emit readable right away in sync mode, because this can trigger
            // another read() call => stack overflow.  This way, it might trigger
            // a nextTick recursion warning, but that's not so bad.

            function emitReadable(stream) {
              var state = stream._readableState;
              debug("emitReadable", state.needReadable, state.emittedReadable);
              state.needReadable = false;

              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                process.nextTick(emitReadable_, stream);
              }
            }

            function emitReadable_(stream) {
              var state = stream._readableState;
              debug("emitReadable_", state.destroyed, state.length, state.ended);

              if (!state.destroyed && (state.length || state.ended)) {
                stream.emit("readable");
                state.emittedReadable = false;
              } // The stream needs another readable event if
              // 1. It is not flowing, as the flow mechanism will take
              //    care of it.
              // 2. It is not ended.
              // 3. It is below the highWaterMark, so we can schedule
              //    another readable later.

              state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
              flow(stream);
            } // at this point, the user has presumably seen the 'readable' event,
            // and called read() to consume some data.  that may have triggered
            // in turn another _read(n) call, in which case reading = true if
            // it's in progress.
            // However, if we're not ended, or reading, and the length < hwm,
            // then go ahead and try to read some more preemptively.

            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                process.nextTick(maybeReadMore_, stream, state);
              }
            }

            function maybeReadMore_(stream, state) {
              // Attempt to read more data if we should.
              //
              // The conditions for reading more data are (one of):
              // - Not enough data buffered (state.length < state.highWaterMark). The loop
              //   is responsible for filling the buffer with enough data if such data
              //   is available. If highWaterMark is 0 and we are not in the flowing mode
              //   we should _not_ attempt to buffer any extra data. We'll get more data
              //   when the stream consumer calls read() instead.
              // - No data in the buffer, and the stream is in flowing mode. In this mode
              //   the loop below is responsible for ensuring read() is called. Failing to
              //   call read here would abort the flow and there's no other mechanism for
              //   continuing the flow if the stream consumer has just subscribed to the
              //   'data' event.
              //
              // In addition to the above conditions to keep reading data, the following
              // conditions prevent the data from being read:
              // - The stream has ended (state.ended).
              // - There is already a pending 'read' operation (state.reading). This is a
              //   case where the the stream has called the implementation defined _read()
              //   method, but they are processing the call asynchronously and have _not_
              //   called push() with new data. In this case we skip performing more
              //   read()s. The execution ends in this method again after the _read() ends
              //   up calling push() with more data.
              while (
                !state.reading &&
                !state.ended &&
                (state.length < state.highWaterMark || (state.flowing && state.length === 0))
              ) {
                var len = state.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  // didn't get any data, stop spinning.
                  break;
              }

              state.readingMore = false;
            } // abstract method.  to be overridden in specific implementation classes.
            // call cb(er, data) where data is <= n in length.
            // for virtual (non-string, non-buffer) streams, "length" is somewhat
            // arbitrary, and perhaps not very meaningful.

            Readable.prototype._read = function (n) {
              errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
            };

            Readable.prototype.pipe = function (dest, pipeOpts) {
              var src = this;
              var state = this._readableState;

              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;

                case 1:
                  state.pipes = [state.pipes, dest];
                  break;

                default:
                  state.pipes.push(dest);
                  break;
              }

              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted) process.nextTick(endFn);
              else src.once("end", endFn);
              dest.on("unpipe", onunpipe);

              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");

                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }

              function onend() {
                debug("onend");
                dest.end();
              } // when the dest drains, it reduces the awaitDrain counter
              // on the source.  This would be more elegant with a .once()
              // handler in flow(), but adding and removing repeatedly is
              // too slow.

              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;

              function cleanup() {
                debug("cleanup"); // cleanup event handlers once the pipe is broken

                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true; // if the reader is waiting for a drain event from this
                // specific writer, then it would cause it to never start
                // flowing again.
                // So, if this is awaiting a drain, then we just call it now.
                // If we don't know, then assume that we are waiting for one.

                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
              }

              src.on("data", ondata);

              function ondata(chunk) {
                debug("ondata");
                var ret = dest.write(chunk);
                debug("dest.write", ret);

                if (ret === false) {
                  // If the user unpiped during `dest.write()`, it is possible
                  // to get stuck in a permanently paused state if that write
                  // also returned false.
                  // => Check whether `dest` is still a piping destination.
                  if (
                    ((state.pipesCount === 1 && state.pipes === dest) ||
                      (state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1)) &&
                    !cleanedUp
                  ) {
                    debug("false write response, pause", state.awaitDrain);
                    state.awaitDrain++;
                  }

                  src.pause();
                }
              } // if the dest has an error, then stop piping into it.
              // however, don't suppress the throwing behavior for this.

              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
              } // Make sure our error handler is attached before userland ones.

              prependListener(dest, "error", onerror); // Both close and finish should trigger unpipe, but only once.

              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }

              dest.once("close", onclose);

              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }

              dest.once("finish", onfinish);

              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              } // tell the dest that it's being piped to

              dest.emit("pipe", src); // start the flow if it hasn't been started already.

              if (!state.flowing) {
                debug("pipe resume");
                src.resume();
              }

              return dest;
            };

            function pipeOnDrain(src) {
              return function pipeOnDrainFunctionResult() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain) state.awaitDrain--;

                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }

            Readable.prototype.unpipe = function (dest) {
              var state = this._readableState;
              var unpipeInfo = {
                hasUnpiped: false,
              }; // if we're not piping anywhere, then do nothing.

              if (state.pipesCount === 0) return this; // just one destination.  most common case.

              if (state.pipesCount === 1) {
                // passed in one, but it's not the right one.
                if (dest && dest !== state.pipes) return this;
                if (!dest) dest = state.pipes; // got a match.

                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest) dest.emit("unpipe", this, unpipeInfo);
                return this;
              } // slow case. multiple pipe destinations.

              if (!dest) {
                // remove all.
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;

                for (var i = 0; i < len; i++) {
                  dests[i].emit("unpipe", this, {
                    hasUnpiped: false,
                  });
                }

                return this;
              } // try to find the right one.

              var index = indexOf(state.pipes, dest);
              if (index === -1) return this;
              state.pipes.splice(index, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1) state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            }; // set up data events if they are asked for
            // Ensure readable listeners eventually get something

            Readable.prototype.on = function (ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              var state = this._readableState;

              if (ev === "data") {
                // update readableListening so that resume() may be a no-op
                // a few lines down. This is needed to support once('readable').
                state.readableListening = this.listenerCount("readable") > 0; // Try start flowing on next tick if stream isn't explicitly paused

                if (state.flowing !== false) this.resume();
              } else if (ev === "readable") {
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.flowing = false;
                  state.emittedReadable = false;
                  debug("on readable", state.length, state.reading);

                  if (state.length) {
                    emitReadable(this);
                  } else if (!state.reading) {
                    process.nextTick(nReadingNextTick, this);
                  }
                }
              }

              return res;
            };

            Readable.prototype.addListener = Readable.prototype.on;

            Readable.prototype.removeListener = function (ev, fn) {
              var res = Stream.prototype.removeListener.call(this, ev, fn);

              if (ev === "readable") {
                // We need to check if there is someone still listening to
                // readable and reset the state. However this needs to happen
                // after readable has been emitted but before I/O (nextTick) to
                // support once('readable', fn) cycles. This means that calling
                // resume within the same tick will have no
                // effect.
                process.nextTick(updateReadableListening, this);
              }

              return res;
            };

            Readable.prototype.removeAllListeners = function (ev) {
              var res = Stream.prototype.removeAllListeners.apply(this, arguments);

              if (ev === "readable" || ev === undefined) {
                // We need to check if there is someone still listening to
                // readable and reset the state. However this needs to happen
                // after readable has been emitted but before I/O (nextTick) to
                // support once('readable', fn) cycles. This means that calling
                // resume within the same tick will have no
                // effect.
                process.nextTick(updateReadableListening, this);
              }

              return res;
            };

            function updateReadableListening(self) {
              var state = self._readableState;
              state.readableListening = self.listenerCount("readable") > 0;

              if (state.resumeScheduled && !state.paused) {
                // flowing needs to be set to true now, otherwise
                // the upcoming resume will not flow.
                state.flowing = true; // crude way to check if we should resume
              } else if (self.listenerCount("data") > 0) {
                self.resume();
              }
            }

            function nReadingNextTick(self) {
              debug("readable nexttick read 0");
              self.read(0);
            } // pause() and resume() are remnants of the legacy readable stream API
            // If the user uses them, then switch into old mode.

            Readable.prototype.resume = function () {
              var state = this._readableState;

              if (!state.flowing) {
                debug("resume"); // we flow only if there is no one listening
                // for readable, but we still have to call
                // resume()

                state.flowing = !state.readableListening;
                resume(this, state);
              }

              state.paused = false;
              return this;
            };

            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process.nextTick(resume_, stream, state);
              }
            }

            function resume_(stream, state) {
              debug("resume", state.reading);

              if (!state.reading) {
                stream.read(0);
              }

              state.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading) stream.read(0);
            }

            Readable.prototype.pause = function () {
              debug("call pause flowing=%j", this._readableState.flowing);

              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }

              this._readableState.paused = true;
              return this;
            };

            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);

              while (state.flowing && stream.read() !== null) {}
            } // wrap an old-style stream as the async data source.
            // This is *not* part of the readable stream interface.
            // It is an ugly unfortunate mess of history.

            Readable.prototype.wrap = function (stream) {
              var _this = this;

              var state = this._readableState;
              var paused = false;
              stream.on("end", function () {
                debug("wrapped end");

                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length) _this.push(chunk);
                }

                _this.push(null);
              });
              stream.on("data", function (chunk) {
                debug("wrapped data");
                if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

                if (state.objectMode && (chunk === null || chunk === undefined)) return;
                else if (!state.objectMode && (!chunk || !chunk.length)) return;

                var ret = _this.push(chunk);

                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              }); // proxy all the other methods.
              // important when wrapping filters and duplexes.

              for (var i in stream) {
                if (this[i] === undefined && typeof stream[i] === "function") {
                  this[i] = (function methodWrap(method) {
                    return function methodWrapReturnFunction() {
                      return stream[method].apply(stream, arguments);
                    };
                  })(i);
                }
              } // proxy certain important events.

              for (var n = 0; n < kProxyEvents.length; n++) {
                stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
              } // when we try to consume some more bytes, simply unpause the
              // underlying stream.

              this._read = function (n) {
                debug("wrapped _read", n);

                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };

              return this;
            };

            if (typeof Symbol === "function") {
              Readable.prototype[Symbol.asyncIterator] = function () {
                if (createReadableStreamAsyncIterator === undefined) {
                  createReadableStreamAsyncIterator = require("./internal/streams/async_iterator");
                }

                return createReadableStreamAsyncIterator(this);
              };
            }

            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.highWaterMark;
              },
            });
            Object.defineProperty(Readable.prototype, "readableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState && this._readableState.buffer;
              },
            });
            Object.defineProperty(Readable.prototype, "readableFlowing", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.flowing;
              },
              set: function set(state) {
                if (this._readableState) {
                  this._readableState.flowing = state;
                }
              },
            }); // exposed for testing purposes only.

            Readable._fromList = fromList;
            Object.defineProperty(Readable.prototype, "readableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.length;
              },
            }); // Pluck off n bytes from an array of buffers.
            // Length is the combined lengths of all the buffers in the list.
            // This function is designed to be inlinable, so please take care when making
            // changes to the function body.

            function fromList(n, state) {
              // nothing buffered
              if (state.length === 0) return null;
              var ret;
              if (state.objectMode) ret = state.buffer.shift();
              else if (!n || n >= state.length) {
                // read it all, truncate the list
                if (state.decoder) ret = state.buffer.join("");
                else if (state.buffer.length === 1) ret = state.buffer.first();
                else ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                // read part of list
                ret = state.buffer.consume(n, state.decoder);
              }
              return ret;
            }

            function endReadable(stream) {
              var state = stream._readableState;
              debug("endReadable", state.endEmitted);

              if (!state.endEmitted) {
                state.ended = true;
                process.nextTick(endReadableNT, state, stream);
              }
            }

            function endReadableNT(state, stream) {
              debug("endReadableNT", state.endEmitted, state.length); // Check that we didn't get one last unshift.

              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");

                if (state.autoDestroy) {
                  // In case of duplex streams we need a way to detect
                  // if the writable side is ready for autoDestroy as well
                  var wState = stream._writableState;

                  if (!wState || (wState.autoDestroy && wState.finished)) {
                    stream.destroy();
                  }
                }
              }
            }

            if (typeof Symbol === "function") {
              Readable.from = function (iterable, opts) {
                if (from === undefined) {
                  from = require("./internal/streams/from");
                }

                return from(Readable, iterable, opts);
              };
            }

            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) return i;
              }

              return -1;
            }
          }).call(this);
        }).call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      {
        "../errors": 177,
        "./_stream_duplex": 178,
        "./internal/streams/async_iterator": 183,
        "./internal/streams/buffer_list": 184,
        "./internal/streams/destroy": 185,
        "./internal/streams/from": 187,
        "./internal/streams/state": 189,
        "./internal/streams/stream": 190,
        _process: 172,
        buffer: 132,
        events: 135,
        inherits: 139,
        "string_decoder/": 196,
        util: 131,
      },
    ],
    181: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.
        "use strict";

        module.exports = Transform;

        var _require$codes = require("../errors").codes,
          ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
          ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
          ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
          ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

        var Duplex = require("./_stream_duplex");

        require("inherits")(Transform, Duplex);

        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;

          if (cb === null) {
            return this.emit("error", new ERR_MULTIPLE_CALLBACK());
          }

          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            // single equals check for both `null` and `undefined`
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;

          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }

        function Transform(options) {
          if (!(this instanceof Transform)) return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null,
          }; // start out asking for a readable event once data is transformed.

          this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
          // that Readable wants before the first _read call, so unset the
          // sync guard flag.

          this._readableState.sync = false;

          if (options) {
            if (typeof options.transform === "function") this._transform = options.transform;
            if (typeof options.flush === "function") this._flush = options.flush;
          } // When the writable side finishes, then flush out anything remaining.

          this.on("prefinish", prefinish);
        }

        function prefinish() {
          var _this = this;

          if (typeof this._flush === "function" && !this._readableState.destroyed) {
            this._flush(function (er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }

        Transform.prototype.push = function (chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        }; // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.

        Transform.prototype._transform = function (chunk, encoding, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
        };

        Transform.prototype._write = function (chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;

          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
          }
        }; // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.

        Transform.prototype._read = function (n) {
          var ts = this._transformState;

          if (ts.writechunk !== null && !ts.transforming) {
            ts.transforming = true;

            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true;
          }
        };

        Transform.prototype._destroy = function (err, cb) {
          Duplex.prototype._destroy.call(this, err, function (err2) {
            cb(err2);
          });
        };

        function done(stream, er, data) {
          if (er) return stream.emit("error", er);
          if (data != null)
            // single equals check for both `null` and `undefined`
            stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
          // if there's nothing in the write buffer, then that means
          // that nothing more will ever be provided

          if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
          if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
          return stream.push(null);
        }
      },
      { "../errors": 177, "./_stream_duplex": 178, inherits: 139 },
    ],
    182: [
      function (require, module, exports) {
        (function (process, global) {
          (function () {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            // A bit simpler than readable streams.
            // Implement an async ._write(chunk, encoding, cb), and it'll handle all
            // the drain event emission and buffering.
            "use strict";

            module.exports = Writable;
            /* <replacement> */

            function WriteReq(chunk, encoding, cb) {
              this.chunk = chunk;
              this.encoding = encoding;
              this.callback = cb;
              this.next = null;
            } // It seems a linked list but it is not
            // there will be only 2 of these for each stream

            function CorkedRequest(state) {
              var _this = this;

              this.next = null;
              this.entry = null;

              this.finish = function () {
                onCorkedFinish(_this, state);
              };
            }
            /* </replacement> */

            /*<replacement>*/

            var Duplex;
            /*</replacement>*/

            Writable.WritableState = WritableState;
            /*<replacement>*/

            var internalUtil = {
              deprecate: require("util-deprecate"),
            };
            /*</replacement>*/

            /*<replacement>*/

            var Stream = require("./internal/streams/stream");
            /*</replacement>*/

            var Buffer = require("buffer").Buffer;

            var OurUint8Array = global.Uint8Array || function () {};

            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }

            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }

            var destroyImpl = require("./internal/streams/destroy");

            var _require = require("./internal/streams/state"),
              getHighWaterMark = _require.getHighWaterMark;

            var _require$codes = require("../errors").codes,
              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
              ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
              ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
              ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
              ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
              ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
              ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

            var errorOrDestroy = destroyImpl.errorOrDestroy;

            require("inherits")(Writable, Stream);

            function nop() {}

            function WritableState(options, stream, isDuplex) {
              Duplex = Duplex || require("./_stream_duplex");
              options = options || {}; // Duplex streams are both readable and writable, but share
              // the same options object.
              // However, some cases require setting options to different
              // values for the readable and the writable sides of the duplex stream,
              // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

              if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
              // contains buffers or objects.

              this.objectMode = !!options.objectMode;
              if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
              // Note: 0 is a valid value, means that we always return false if
              // the entire buffer is not flushed immediately on write()

              this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex); // if _final has been called

              this.finalCalled = false; // drain event flag.

              this.needDrain = false; // at the start of calling end()

              this.ending = false; // when end() has been called, and returned

              this.ended = false; // when 'finish' is emitted

              this.finished = false; // has it been destroyed

              this.destroyed = false; // should we decode strings into buffers before passing to _write?
              // this is here so that some node-core streams can optimize string
              // handling at a lower level.

              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
              // encoding is 'binary' so we have to make this configurable.
              // Everything else in the universe uses 'utf8', though.

              this.defaultEncoding = options.defaultEncoding || "utf8"; // not an actual buffer we keep track of, but a measurement
              // of how much we're waiting to get pushed to some underlying
              // socket or file.

              this.length = 0; // a flag to see when we're in the middle of a write.

              this.writing = false; // when true all writes will be buffered until .uncork() call

              this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
              // or on a later tick.  We set this to true at first, because any
              // actions that shouldn't happen until "later" should generally also
              // not happen before the first write call.

              this.sync = true; // a flag to know if we're processing previously buffered items, which
              // may call the _write() callback in the same tick, so that we don't
              // end up in an overlapped onwrite situation.

              this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

              this.onwrite = function (er) {
                onwrite(stream, er);
              }; // the callback that the user supplies to write(chunk,encoding,cb)

              this.writecb = null; // the amount that is being written when _write is called.

              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
              // this must be 0 before 'finish' can be emitted

              this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
              // This is relevant for synchronous Transform streams

              this.prefinished = false; // True if the error was already emitted and should not be thrown again

              this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

              this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

              this.autoDestroy = !!options.autoDestroy; // count buffered requests

              this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
              // one allocated and free to use, and we maintain at most two

              this.corkedRequestsFree = new CorkedRequest(this);
            }

            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];

              while (current) {
                out.push(current);
                current = current.next;
              }

              return out;
            };

            (function () {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                  get: internalUtil.deprecate(
                    function writableStateBufferGetter() {
                      return this.getBuffer();
                    },
                    "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.",
                    "DEP0003",
                  ),
                });
              } catch (_) {}
            })(); // Test _writableState for inheritance to account for Duplex streams,
            // whose prototype chain only points to Readable.

            var realHasInstance;

            if (
              typeof Symbol === "function" &&
              Symbol.hasInstance &&
              typeof Function.prototype[Symbol.hasInstance] === "function"
            ) {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function value(object) {
                  if (realHasInstance.call(this, object)) return true;
                  if (this !== Writable) return false;
                  return object && object._writableState instanceof WritableState;
                },
              });
            } else {
              realHasInstance = function realHasInstance(object) {
                return object instanceof this;
              };
            }

            function Writable(options) {
              Duplex = Duplex || require("./_stream_duplex"); // Writable ctor is applied to Duplexes, too.
              // `realHasInstance` is necessary because using plain `instanceof`
              // would return false, as no `_writableState` property is attached.
              // Trying to use the custom `instanceof` for Writable here will also break the
              // Node.js LazyTransform implementation, which has a non-trivial getter for
              // `_writableState` that would lead to infinite recursion.
              // Checking for a Stream.Duplex instance is faster here instead of inside
              // the WritableState constructor, at least with V8 6.5

              var isDuplex = this instanceof Duplex;
              if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
              this._writableState = new WritableState(options, this, isDuplex); // legacy.

              this.writable = true;

              if (options) {
                if (typeof options.write === "function") this._write = options.write;
                if (typeof options.writev === "function") this._writev = options.writev;
                if (typeof options.destroy === "function") this._destroy = options.destroy;
                if (typeof options.final === "function") this._final = options.final;
              }

              Stream.call(this);
            } // Otherwise people can pipe Writable streams, which is just wrong.

            Writable.prototype.pipe = function () {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };

            function writeAfterEnd(stream, cb) {
              var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
            } // Checks that a user-supplied chunk is valid, especially for the particular
            // mode the stream is in. Currently this means that `null` is never accepted
            // and undefined/non-string values are only allowed in object mode.

            function validChunk(stream, state, chunk, cb) {
              var er;

              if (chunk === null) {
                er = new ERR_STREAM_NULL_VALUES();
              } else if (typeof chunk !== "string" && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
              }

              if (er) {
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
                return false;
              }

              return true;
            }

            Writable.prototype.write = function (chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;

              var isBuf = !state.objectMode && _isUint8Array(chunk);

              if (isBuf && !Buffer.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }

              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }

              if (isBuf) encoding = "buffer";
              else if (!encoding) encoding = state.defaultEncoding;
              if (typeof cb !== "function") cb = nop;
              if (state.ending) writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };

            Writable.prototype.cork = function () {
              this._writableState.corked++;
            };

            Writable.prototype.uncork = function () {
              var state = this._writableState;

              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };

            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              // node::ParseEncoding() requires lower case.
              if (typeof encoding === "string") encoding = encoding.toLowerCase();
              if (
                !(
                  [
                    "hex",
                    "utf8",
                    "utf-8",
                    "ascii",
                    "binary",
                    "base64",
                    "ucs2",
                    "ucs-2",
                    "utf16le",
                    "utf-16le",
                    "raw",
                  ].indexOf((encoding + "").toLowerCase()) > -1
                )
              )
                throw new ERR_UNKNOWN_ENCODING(encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };

            Object.defineProperty(Writable.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              },
            });

            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer.from(chunk, encoding);
              }

              return chunk;
            }

            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              },
            }); // if we're already writing something, then just put this
            // in the queue, and wait our turn.  Otherwise, call _write
            // If we return false, then we need a drain event, so set that flag.

            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);

                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk = newChunk;
                }
              }

              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

              if (!ret) state.needDrain = true;

              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                  chunk: chunk,
                  encoding: encoding,
                  isBuf: isBuf,
                  callback: cb,
                  next: null,
                };

                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }

                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }

              return ret;
            }

            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev) stream._writev(chunk, state.onwrite);
              else stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }

            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;

              if (sync) {
                // defer the callback if we are being called synchronously
                // to avoid piling up things on the stack
                process.nextTick(cb, er); // this can emit finish, and it will always happen
                // after error

                process.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
              } else {
                // the caller expect this to happen before if
                // it is async
                cb(er);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er); // this can emit finish, but finish must
                // always follow error

                finishMaybe(stream, state);
              }
            }

            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }

            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
              onwriteStateUpdate(state);
              if (er) onwriteError(stream, state, sync, er, cb);
              else {
                // Check if we're actually ready to finish, but don't emit yet
                var finished = needFinish(state) || stream.destroyed;

                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }

                if (sync) {
                  process.nextTick(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }

            function afterWrite(stream, state, finished, cb) {
              if (!finished) onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            } // Must force callback to be called on nextTick, so that we don't
            // emit 'drain' before the write() consumer gets the 'false' return
            // value, and has a chance to attach a 'drain' listener.

            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            } // if there's something in the buffer waiting, then process it

            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;

              if (stream._writev && entry && entry.next) {
                // Fast case, write everything using _writev()
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;

                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf) allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }

                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish); // doWrite is almost always async, defer these to save a bit of time
                // as the hot path ends with doWrite

                state.pendingcb++;
                state.lastBufferedRequest = null;

                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }

                state.bufferedRequestCount = 0;
              } else {
                // Slow case, write chunks one-by-one
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
                  // it means that we need to wait until it does.
                  // also, that means that the chunk and cb are currently
                  // being processed, so move the buffer counter past them.

                  if (state.writing) {
                    break;
                  }
                }

                if (entry === null) state.lastBufferedRequest = null;
              }

              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }

            Writable.prototype._write = function (chunk, encoding, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
            };

            Writable.prototype._writev = null;

            Writable.prototype.end = function (chunk, encoding, cb) {
              var state = this._writableState;

              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }

              if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

              if (state.corked) {
                state.corked = 1;
                this.uncork();
              } // ignore unnecessary end() calls.

              if (!state.ending) endWritable(this, state, cb);
              return this;
            };

            Object.defineProperty(Writable.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              },
            });

            function needFinish(state) {
              return (
                state.ending &&
                state.length === 0 &&
                state.bufferedRequest === null &&
                !state.finished &&
                !state.writing
              );
            }

            function callFinal(stream, state) {
              stream._final(function (err) {
                state.pendingcb--;

                if (err) {
                  errorOrDestroy(stream, err);
                }

                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }

            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function" && !state.destroyed) {
                  state.pendingcb++;
                  state.finalCalled = true;
                  process.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }

            function finishMaybe(stream, state) {
              var need = needFinish(state);

              if (need) {
                prefinish(stream, state);

                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");

                  if (state.autoDestroy) {
                    // In case of duplex streams we need a way to detect
                    // if the readable side is ready for autoDestroy as well
                    var rState = stream._readableState;

                    if (!rState || (rState.autoDestroy && rState.endEmitted)) {
                      stream.destroy();
                    }
                  }
                }
              }

              return need;
            }

            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);

              if (cb) {
                if (state.finished) process.nextTick(cb);
                else stream.once("finish", cb);
              }

              state.ended = true;
              stream.writable = false;
            }

            function onCorkedFinish(corkReq, state, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;

              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              } // reuse the free corkReq.

              state.corkedRequestsFree.next = corkReq;
            }

            Object.defineProperty(Writable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._writableState === undefined) {
                  return false;
                }

                return this._writableState.destroyed;
              },
              set: function set(value) {
                // we ignore the value if the stream
                // has not been initialized yet
                if (!this._writableState) {
                  return;
                } // backward compatibility, the user is explicitly
                // managing destroyed

                this._writableState.destroyed = value;
              },
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;

            Writable.prototype._destroy = function (err, cb) {
              cb(err);
            };
          }).call(this);
        }).call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      {
        "../errors": 177,
        "./_stream_duplex": 178,
        "./internal/streams/destroy": 185,
        "./internal/streams/state": 189,
        "./internal/streams/stream": 190,
        _process: 172,
        buffer: 132,
        inherits: 139,
        "util-deprecate": 201,
      },
    ],
    183: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            "use strict";

            var _Object$setPrototypeO;

            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }

            var finished = require("./end-of-stream");

            var kLastResolve = Symbol("lastResolve");
            var kLastReject = Symbol("lastReject");
            var kError = Symbol("error");
            var kEnded = Symbol("ended");
            var kLastPromise = Symbol("lastPromise");
            var kHandlePromise = Symbol("handlePromise");
            var kStream = Symbol("stream");

            function createIterResult(value, done) {
              return {
                value: value,
                done: done,
              };
            }

            function readAndResolve(iter) {
              var resolve = iter[kLastResolve];

              if (resolve !== null) {
                var data = iter[kStream].read(); // we defer if data is null
                // we can be expecting either 'end' or
                // 'error'

                if (data !== null) {
                  iter[kLastPromise] = null;
                  iter[kLastResolve] = null;
                  iter[kLastReject] = null;
                  resolve(createIterResult(data, false));
                }
              }
            }

            function onReadable(iter) {
              // we wait for the next tick, because it might
              // emit an error with process.nextTick
              process.nextTick(readAndResolve, iter);
            }

            function wrapForNext(lastPromise, iter) {
              return function (resolve, reject) {
                lastPromise.then(function () {
                  if (iter[kEnded]) {
                    resolve(createIterResult(undefined, true));
                    return;
                  }

                  iter[kHandlePromise](resolve, reject);
                }, reject);
              };
            }

            var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
            var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf(
              ((_Object$setPrototypeO = {
                get stream() {
                  return this[kStream];
                },

                next: function next() {
                  var _this = this;

                  // if we have detected an error in the meanwhile
                  // reject straight away
                  var error = this[kError];

                  if (error !== null) {
                    return Promise.reject(error);
                  }

                  if (this[kEnded]) {
                    return Promise.resolve(createIterResult(undefined, true));
                  }

                  if (this[kStream].destroyed) {
                    // We need to defer via nextTick because if .destroy(err) is
                    // called, the error will be emitted via nextTick, and
                    // we cannot guarantee that there is no error lingering around
                    // waiting to be emitted.
                    return new Promise(function (resolve, reject) {
                      process.nextTick(function () {
                        if (_this[kError]) {
                          reject(_this[kError]);
                        } else {
                          resolve(createIterResult(undefined, true));
                        }
                      });
                    });
                  } // if we have multiple next() calls
                  // we will wait for the previous Promise to finish
                  // this logic is optimized to support for await loops,
                  // where next() is only called once at a time

                  var lastPromise = this[kLastPromise];
                  var promise;

                  if (lastPromise) {
                    promise = new Promise(wrapForNext(lastPromise, this));
                  } else {
                    // fast path needed to support multiple this.push()
                    // without triggering the next() queue
                    var data = this[kStream].read();

                    if (data !== null) {
                      return Promise.resolve(createIterResult(data, false));
                    }

                    promise = new Promise(this[kHandlePromise]);
                  }

                  this[kLastPromise] = promise;
                  return promise;
                },
              }),
              _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
                return this;
              }),
              _defineProperty(_Object$setPrototypeO, "return", function _return() {
                var _this2 = this;

                // destroy(err, cb) is a private API
                // we can guarantee we have that here, because we control the
                // Readable class this is attached to
                return new Promise(function (resolve, reject) {
                  _this2[kStream].destroy(null, function (err) {
                    if (err) {
                      reject(err);
                      return;
                    }

                    resolve(createIterResult(undefined, true));
                  });
                });
              }),
              _Object$setPrototypeO),
              AsyncIteratorPrototype,
            );

            var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
              var _Object$create;

              var iterator = Object.create(
                ReadableStreamAsyncIteratorPrototype,
                ((_Object$create = {}),
                _defineProperty(_Object$create, kStream, {
                  value: stream,
                  writable: true,
                }),
                _defineProperty(_Object$create, kLastResolve, {
                  value: null,
                  writable: true,
                }),
                _defineProperty(_Object$create, kLastReject, {
                  value: null,
                  writable: true,
                }),
                _defineProperty(_Object$create, kError, {
                  value: null,
                  writable: true,
                }),
                _defineProperty(_Object$create, kEnded, {
                  value: stream._readableState.endEmitted,
                  writable: true,
                }),
                _defineProperty(_Object$create, kHandlePromise, {
                  value: function value(resolve, reject) {
                    var data = iterator[kStream].read();

                    if (data) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      resolve(createIterResult(data, false));
                    } else {
                      iterator[kLastResolve] = resolve;
                      iterator[kLastReject] = reject;
                    }
                  },
                  writable: true,
                }),
                _Object$create),
              );
              iterator[kLastPromise] = null;
              finished(stream, function (err) {
                if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
                  // returned by next() and store the error

                  if (reject !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    reject(err);
                  }

                  iterator[kError] = err;
                  return;
                }

                var resolve = iterator[kLastResolve];

                if (resolve !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(undefined, true));
                }

                iterator[kEnded] = true;
              });
              stream.on("readable", onReadable.bind(null, iterator));
              return iterator;
            };

            module.exports = createReadableStreamAsyncIterator;
          }).call(this);
        }).call(this, require("_process"));
      },
      { "./end-of-stream": 186, _process: 172 },
    ],
    184: [
      function (require, module, exports) {
        "use strict";

        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }

        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var _require = require("buffer"),
          Buffer = _require.Buffer;

        var _require2 = require("util"),
          inspect = _require2.inspect;

        var custom = (inspect && inspect.custom) || "inspect";

        function copyBuffer(src, target, offset) {
          Buffer.prototype.copy.call(src, target, offset);
        }

        module.exports =
          /*#__PURE__*/
          (function () {
            function BufferList() {
              _classCallCheck(this, BufferList);

              this.head = null;
              this.tail = null;
              this.length = 0;
            }

            _createClass(BufferList, [
              {
                key: "push",
                value: function push(v) {
                  var entry = {
                    data: v,
                    next: null,
                  };
                  if (this.length > 0) this.tail.next = entry;
                  else this.head = entry;
                  this.tail = entry;
                  ++this.length;
                },
              },
              {
                key: "unshift",
                value: function unshift(v) {
                  var entry = {
                    data: v,
                    next: this.head,
                  };
                  if (this.length === 0) this.tail = entry;
                  this.head = entry;
                  ++this.length;
                },
              },
              {
                key: "shift",
                value: function shift() {
                  if (this.length === 0) return;
                  var ret = this.head.data;
                  if (this.length === 1) this.head = this.tail = null;
                  else this.head = this.head.next;
                  --this.length;
                  return ret;
                },
              },
              {
                key: "clear",
                value: function clear() {
                  this.head = this.tail = null;
                  this.length = 0;
                },
              },
              {
                key: "join",
                value: function join(s) {
                  if (this.length === 0) return "";
                  var p = this.head;
                  var ret = "" + p.data;

                  while ((p = p.next)) {
                    ret += s + p.data;
                  }

                  return ret;
                },
              },
              {
                key: "concat",
                value: function concat(n) {
                  if (this.length === 0) return Buffer.alloc(0);
                  var ret = Buffer.allocUnsafe(n >>> 0);
                  var p = this.head;
                  var i = 0;

                  while (p) {
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                  }

                  return ret;
                }, // Consumes a specified amount of bytes or characters from the buffered data.
              },
              {
                key: "consume",
                value: function consume(n, hasStrings) {
                  var ret;

                  if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                  } else if (n === this.head.data.length) {
                    // First chunk is a perfect match.
                    ret = this.shift();
                  } else {
                    // Result spans more than one buffer.
                    ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                  }

                  return ret;
                },
              },
              {
                key: "first",
                value: function first() {
                  return this.head.data;
                }, // Consumes a specified amount of characters from the buffered data.
              },
              {
                key: "_getString",
                value: function _getString(n) {
                  var p = this.head;
                  var c = 1;
                  var ret = p.data;
                  n -= ret.length;

                  while ((p = p.next)) {
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;

                    if (n === 0) {
                      if (nb === str.length) {
                        ++c;
                        if (p.next) this.head = p.next;
                        else this.head = this.tail = null;
                      } else {
                        this.head = p;
                        p.data = str.slice(nb);
                      }

                      break;
                    }

                    ++c;
                  }

                  this.length -= c;
                  return ret;
                }, // Consumes a specified amount of bytes from the buffered data.
              },
              {
                key: "_getBuffer",
                value: function _getBuffer(n) {
                  var ret = Buffer.allocUnsafe(n);
                  var p = this.head;
                  var c = 1;
                  p.data.copy(ret);
                  n -= p.data.length;

                  while ((p = p.next)) {
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;

                    if (n === 0) {
                      if (nb === buf.length) {
                        ++c;
                        if (p.next) this.head = p.next;
                        else this.head = this.tail = null;
                      } else {
                        this.head = p;
                        p.data = buf.slice(nb);
                      }

                      break;
                    }

                    ++c;
                  }

                  this.length -= c;
                  return ret;
                }, // Make sure the linked list only shows the minimal necessary information.
              },
              {
                key: custom,
                value: function value(_, options) {
                  return inspect(
                    this,
                    _objectSpread({}, options, {
                      // Only inspect one level.
                      depth: 0,
                      // It should not recurse.
                      customInspect: false,
                    }),
                  );
                },
              },
            ]);

            return BufferList;
          })();
      },
      { buffer: 132, util: 131 },
    ],
    185: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            "use strict"; // undocumented cb() API, needed for core, not for public API

            function destroy(err, cb) {
              var _this = this;

              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;

              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err);
                } else if (err) {
                  if (!this._writableState) {
                    process.nextTick(emitErrorNT, this, err);
                  } else if (!this._writableState.errorEmitted) {
                    this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorNT, this, err);
                  }
                }

                return this;
              } // we set destroyed to true before firing error callbacks in order
              // to make it re-entrance safe in case destroy() is called within callbacks

              if (this._readableState) {
                this._readableState.destroyed = true;
              } // if this is a duplex stream mark the writable part as destroyed as well

              if (this._writableState) {
                this._writableState.destroyed = true;
              }

              this._destroy(err || null, function (err) {
                if (!cb && err) {
                  if (!_this._writableState) {
                    process.nextTick(emitErrorAndCloseNT, _this, err);
                  } else if (!_this._writableState.errorEmitted) {
                    _this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorAndCloseNT, _this, err);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                } else if (cb) {
                  process.nextTick(emitCloseNT, _this);
                  cb(err);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              });

              return this;
            }

            function emitErrorAndCloseNT(self, err) {
              emitErrorNT(self, err);
              emitCloseNT(self);
            }

            function emitCloseNT(self) {
              if (self._writableState && !self._writableState.emitClose) return;
              if (self._readableState && !self._readableState.emitClose) return;
              self.emit("close");
            }

            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }

              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finalCalled = false;
                this._writableState.prefinished = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }

            function emitErrorNT(self, err) {
              self.emit("error", err);
            }

            function errorOrDestroy(stream, err) {
              // We have tests that rely on errors being emitted
              // in the same tick, so changing this is semver major.
              // For now when you opt-in to autoDestroy we allow
              // the error to be emitted nextTick. In a future
              // semver major update we should change the default to this.
              var rState = stream._readableState;
              var wState = stream._writableState;
              if ((rState && rState.autoDestroy) || (wState && wState.autoDestroy)) stream.destroy(err);
              else stream.emit("error", err);
            }

            module.exports = {
              destroy: destroy,
              undestroy: undestroy,
              errorOrDestroy: errorOrDestroy,
            };
          }).call(this);
        }).call(this, require("_process"));
      },
      { _process: 172 },
    ],
    186: [
      function (require, module, exports) {
        // Ported from https://github.com/mafintosh/end-of-stream with
        // permission from the author, Mathias Buus (@mafintosh).
        "use strict";

        var ERR_STREAM_PREMATURE_CLOSE = require("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;

        function once(callback) {
          var called = false;
          return function () {
            if (called) return;
            called = true;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            callback.apply(this, args);
          };
        }

        function noop() {}

        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }

        function eos(stream, opts, callback) {
          if (typeof opts === "function") return eos(stream, null, opts);
          if (!opts) opts = {};
          callback = once(callback || noop);
          var readable = opts.readable || (opts.readable !== false && stream.readable);
          var writable = opts.writable || (opts.writable !== false && stream.writable);

          var onlegacyfinish = function onlegacyfinish() {
            if (!stream.writable) onfinish();
          };

          var writableEnded = stream._writableState && stream._writableState.finished;

          var onfinish = function onfinish() {
            writable = false;
            writableEnded = true;
            if (!readable) callback.call(stream);
          };

          var readableEnded = stream._readableState && stream._readableState.endEmitted;

          var onend = function onend() {
            readable = false;
            readableEnded = true;
            if (!writable) callback.call(stream);
          };

          var onerror = function onerror(err) {
            callback.call(stream, err);
          };

          var onclose = function onclose() {
            var err;

            if (readable && !readableEnded) {
              if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }

            if (writable && !writableEnded) {
              if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
          };

          var onrequest = function onrequest() {
            stream.req.on("finish", onfinish);
          };

          if (isRequest(stream)) {
            stream.on("complete", onfinish);
            stream.on("abort", onclose);
            if (stream.req) onrequest();
            else stream.on("request", onrequest);
          } else if (writable && !stream._writableState) {
            // legacy streams
            stream.on("end", onlegacyfinish);
            stream.on("close", onlegacyfinish);
          }

          stream.on("end", onend);
          stream.on("finish", onfinish);
          if (opts.error !== false) stream.on("error", onerror);
          stream.on("close", onclose);
          return function () {
            stream.removeListener("complete", onfinish);
            stream.removeListener("abort", onclose);
            stream.removeListener("request", onrequest);
            if (stream.req) stream.req.removeListener("finish", onfinish);
            stream.removeListener("end", onlegacyfinish);
            stream.removeListener("close", onlegacyfinish);
            stream.removeListener("finish", onfinish);
            stream.removeListener("end", onend);
            stream.removeListener("error", onerror);
            stream.removeListener("close", onclose);
          };
        }

        module.exports = eos;
      },
      { "../../../errors": 177 },
    ],
    187: [
      function (require, module, exports) {
        module.exports = function () {
          throw new Error("Readable.from is not available in the browser");
        };
      },
      {},
    ],
    188: [
      function (require, module, exports) {
        // Ported from https://github.com/mafintosh/pump with
        // permission from the author, Mathias Buus (@mafintosh).
        "use strict";

        var eos;

        function once(callback) {
          var called = false;
          return function () {
            if (called) return;
            called = true;
            callback.apply(void 0, arguments);
          };
        }

        var _require$codes = require("../../../errors").codes,
          ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
          ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

        function noop(err) {
          // Rethrow the error if it exists to avoid swallowing it
          if (err) throw err;
        }

        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }

        function destroyer(stream, reading, writing, callback) {
          callback = once(callback);
          var closed = false;
          stream.on("close", function () {
            closed = true;
          });
          if (eos === undefined) eos = require("./end-of-stream");
          eos(
            stream,
            {
              readable: reading,
              writable: writing,
            },
            function (err) {
              if (err) return callback(err);
              closed = true;
              callback();
            },
          );
          var destroyed = false;
          return function (err) {
            if (closed) return;
            if (destroyed) return;
            destroyed = true; // request.destroy just do .end - .abort is what we want

            if (isRequest(stream)) return stream.abort();
            if (typeof stream.destroy === "function") return stream.destroy();
            callback(err || new ERR_STREAM_DESTROYED("pipe"));
          };
        }

        function call(fn) {
          fn();
        }

        function pipe(from, to) {
          return from.pipe(to);
        }

        function popCallback(streams) {
          if (!streams.length) return noop;
          if (typeof streams[streams.length - 1] !== "function") return noop;
          return streams.pop();
        }

        function pipeline() {
          for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
            streams[_key] = arguments[_key];
          }

          var callback = popCallback(streams);
          if (Array.isArray(streams[0])) streams = streams[0];

          if (streams.length < 2) {
            throw new ERR_MISSING_ARGS("streams");
          }

          var error;
          var destroys = streams.map(function (stream, i) {
            var reading = i < streams.length - 1;
            var writing = i > 0;
            return destroyer(stream, reading, writing, function (err) {
              if (!error) error = err;
              if (err) destroys.forEach(call);
              if (reading) return;
              destroys.forEach(call);
              callback(error);
            });
          });
          return streams.reduce(pipe);
        }

        module.exports = pipeline;
      },
      { "../../../errors": 177, "./end-of-stream": 186 },
    ],
    189: [
      function (require, module, exports) {
        "use strict";

        var ERR_INVALID_OPT_VALUE = require("../../../errors").codes.ERR_INVALID_OPT_VALUE;

        function highWaterMarkFrom(options, isDuplex, duplexKey) {
          return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
        }

        function getHighWaterMark(state, options, duplexKey, isDuplex) {
          var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

          if (hwm != null) {
            if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
              var name = isDuplex ? duplexKey : "highWaterMark";
              throw new ERR_INVALID_OPT_VALUE(name, hwm);
            }

            return Math.floor(hwm);
          } // Default value

          return state.objectMode ? 16 : 16 * 1024;
        }

        module.exports = {
          getHighWaterMark: getHighWaterMark,
        };
      },
      { "../../../errors": 177 },
    ],
    190: [
      function (require, module, exports) {
        module.exports = require("events").EventEmitter;
      },
      { events: 135 },
    ],
    191: [
      function (require, module, exports) {
        exports = module.exports = require("./lib/_stream_readable.js");
        exports.Stream = exports;
        exports.Readable = exports;
        exports.Writable = require("./lib/_stream_writable.js");
        exports.Duplex = require("./lib/_stream_duplex.js");
        exports.Transform = require("./lib/_stream_transform.js");
        exports.PassThrough = require("./lib/_stream_passthrough.js");
        exports.finished = require("./lib/internal/streams/end-of-stream.js");
        exports.pipeline = require("./lib/internal/streams/pipeline.js");
      },
      {
        "./lib/_stream_duplex.js": 178,
        "./lib/_stream_passthrough.js": 179,
        "./lib/_stream_readable.js": 180,
        "./lib/_stream_transform.js": 181,
        "./lib/_stream_writable.js": 182,
        "./lib/internal/streams/end-of-stream.js": 186,
        "./lib/internal/streams/pipeline.js": 188,
      },
    ],
    192: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            var ClientRequest = require("./lib/request");
            var response = require("./lib/response");
            var extend = require("xtend");
            var statusCodes = require("builtin-status-codes");
            var url = require("url");

            var http = exports;

            http.request = function (opts, cb) {
              if (typeof opts === "string") opts = url.parse(opts);
              else opts = extend(opts);

              // Normally, the page is loaded from http or https, so not specifying a protocol
              // will result in a (valid) protocol-relative url. However, this won't work if
              // the protocol is something else, like 'file:'
              var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";

              var protocol = opts.protocol || defaultProtocol;
              var host = opts.hostname || opts.host;
              var port = opts.port;
              var path = opts.path || "/";

              // Necessary for IPv6 addresses
              if (host && host.indexOf(":") !== -1) host = "[" + host + "]";

              // This may be a relative url. The browser should always be able to interpret it correctly.
              opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
              opts.method = (opts.method || "GET").toUpperCase();
              opts.headers = opts.headers || {};

              // Also valid opts.auth, opts.mode

              var req = new ClientRequest(opts);
              if (cb) req.on("response", cb);
              return req;
            };

            http.get = function get(opts, cb) {
              var req = http.request(opts, cb);
              req.end();
              return req;
            };

            http.ClientRequest = ClientRequest;
            http.IncomingMessage = response.IncomingMessage;

            http.Agent = function () {};
            http.Agent.defaultMaxSockets = 4;

            http.globalAgent = new http.Agent();

            http.STATUS_CODES = statusCodes;

            http.METHODS = [
              "CHECKOUT",
              "CONNECT",
              "COPY",
              "DELETE",
              "GET",
              "HEAD",
              "LOCK",
              "M-SEARCH",
              "MERGE",
              "MKACTIVITY",
              "MKCOL",
              "MOVE",
              "NOTIFY",
              "OPTIONS",
              "PATCH",
              "POST",
              "PROPFIND",
              "PROPPATCH",
              "PURGE",
              "PUT",
              "REPORT",
              "SEARCH",
              "SUBSCRIBE",
              "TRACE",
              "UNLOCK",
              "UNSUBSCRIBE",
            ];
          }).call(this);
        }).call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      { "./lib/request": 194, "./lib/response": 195, "builtin-status-codes": 133, url: 199, xtend: 205 },
    ],
    193: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);

            exports.writableStream = isFunction(global.WritableStream);

            exports.abortController = isFunction(global.AbortController);

            // The xhr request to example.com may violate some restrictive CSP configurations,
            // so if we're running in a browser that supports `fetch`, avoid calling getXHR()
            // and assume support for certain features below.
            var xhr;
            function getXHR() {
              // Cache the xhr value
              if (xhr !== undefined) return xhr;

              if (global.XMLHttpRequest) {
                xhr = new global.XMLHttpRequest();
                // If XDomainRequest is available (ie only, where xhr might not work
                // cross domain), use the page location. Otherwise use example.com
                // Note: this doesn't actually make an http request.
                try {
                  xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com");
                } catch (e) {
                  xhr = null;
                }
              } else {
                // Service workers don't have XHR
                xhr = null;
              }
              return xhr;
            }

            function checkTypeSupport(type) {
              var xhr = getXHR();
              if (!xhr) return false;
              try {
                xhr.responseType = type;
                return xhr.responseType === type;
              } catch (e) {}
              return false;
            }

            // If fetch is supported, then arraybuffer will be supported too. Skip calling
            // checkTypeSupport(), since that calls getXHR().
            exports.arraybuffer = exports.fetch || checkTypeSupport("arraybuffer");

            // These next two tests unavoidably show warnings in Chrome. Since fetch will always
            // be used if it's available, just return false for these to avoid the warnings.
            exports.msstream = !exports.fetch && checkTypeSupport("ms-stream");
            exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer");

            // If fetch is supported, then overrideMimeType will be supported too. Skip calling
            // getXHR().
            exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

            function isFunction(value) {
              return typeof value === "function";
            }

            xhr = null; // Help gc
          }).call(this);
        }).call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      {},
    ],
    194: [
      function (require, module, exports) {
        (function (process, global, Buffer) {
          (function () {
            var capability = require("./capability");
            var inherits = require("inherits");
            var response = require("./response");
            var stream = require("readable-stream");

            var IncomingMessage = response.IncomingMessage;
            var rStates = response.readyStates;

            function decideMode(preferBinary, useFetch) {
              if (capability.fetch && useFetch) {
                return "fetch";
              } else if (capability.mozchunkedarraybuffer) {
                return "moz-chunked-arraybuffer";
              } else if (capability.msstream) {
                return "ms-stream";
              } else if (capability.arraybuffer && preferBinary) {
                return "arraybuffer";
              } else {
                return "text";
              }
            }

            var ClientRequest = (module.exports = function (opts) {
              var self = this;
              stream.Writable.call(self);

              self._opts = opts;
              self._body = [];
              self._headers = {};
              if (opts.auth) self.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
              Object.keys(opts.headers).forEach(function (name) {
                self.setHeader(name, opts.headers[name]);
              });

              var preferBinary;
              var useFetch = true;
              if (opts.mode === "disable-fetch" || ("requestTimeout" in opts && !capability.abortController)) {
                // If the use of XHR should be preferred. Not typically needed.
                useFetch = false;
                preferBinary = true;
              } else if (opts.mode === "prefer-streaming") {
                // If streaming is a high priority but binary compatibility and
                // the accuracy of the 'content-type' header aren't
                preferBinary = false;
              } else if (opts.mode === "allow-wrong-content-type") {
                // If streaming is more important than preserving the 'content-type' header
                preferBinary = !capability.overrideMimeType;
              } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
                // Use binary if text streaming may corrupt data or the content-type header, or for speed
                preferBinary = true;
              } else {
                throw new Error("Invalid value for opts.mode");
              }
              self._mode = decideMode(preferBinary, useFetch);
              self._fetchTimer = null;
              self._socketTimeout = null;
              self._socketTimer = null;

              self.on("finish", function () {
                self._onFinish();
              });
            });

            inherits(ClientRequest, stream.Writable);

            ClientRequest.prototype.setHeader = function (name, value) {
              var self = this;
              var lowerName = name.toLowerCase();
              // This check is not necessary, but it prevents warnings from browsers about setting unsafe
              // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
              // http-browserify did it, so I will too.
              if (unsafeHeaders.indexOf(lowerName) !== -1) return;

              self._headers[lowerName] = {
                name: name,
                value: value,
              };
            };

            ClientRequest.prototype.getHeader = function (name) {
              var header = this._headers[name.toLowerCase()];
              if (header) return header.value;
              return null;
            };

            ClientRequest.prototype.removeHeader = function (name) {
              var self = this;
              delete self._headers[name.toLowerCase()];
            };

            ClientRequest.prototype._onFinish = function () {
              var self = this;

              if (self._destroyed) return;
              var opts = self._opts;

              if ("timeout" in opts && opts.timeout !== 0) {
                self.setTimeout(opts.timeout);
              }

              var headersObj = self._headers;
              var body = null;
              if (opts.method !== "GET" && opts.method !== "HEAD") {
                body = new Blob(self._body, {
                  type: (headersObj["content-type"] || {}).value || "",
                });
              }

              // create flattened list of headers
              var headersList = [];
              Object.keys(headersObj).forEach(function (keyName) {
                var name = headersObj[keyName].name;
                var value = headersObj[keyName].value;
                if (Array.isArray(value)) {
                  value.forEach(function (v) {
                    headersList.push([name, v]);
                  });
                } else {
                  headersList.push([name, value]);
                }
              });

              if (self._mode === "fetch") {
                var signal = null;
                if (capability.abortController) {
                  var controller = new AbortController();
                  signal = controller.signal;
                  self._fetchAbortController = controller;

                  if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
                    self._fetchTimer = global.setTimeout(function () {
                      self.emit("requestTimeout");
                      if (self._fetchAbortController) self._fetchAbortController.abort();
                    }, opts.requestTimeout);
                  }
                }

                global
                  .fetch(self._opts.url, {
                    method: self._opts.method,
                    headers: headersList,
                    body: body || undefined,
                    mode: "cors",
                    credentials: opts.withCredentials ? "include" : "same-origin",
                    signal: signal,
                  })
                  .then(
                    function (response) {
                      self._fetchResponse = response;
                      self._resetTimers(false);
                      self._connect();
                    },
                    function (reason) {
                      self._resetTimers(true);
                      if (!self._destroyed) self.emit("error", reason);
                    },
                  );
              } else {
                var xhr = (self._xhr = new global.XMLHttpRequest());
                try {
                  xhr.open(self._opts.method, self._opts.url, true);
                } catch (err) {
                  process.nextTick(function () {
                    self.emit("error", err);
                  });
                  return;
                }

                // Can't set responseType on really old browsers
                if ("responseType" in xhr) xhr.responseType = self._mode;

                if ("withCredentials" in xhr) xhr.withCredentials = !!opts.withCredentials;

                if (self._mode === "text" && "overrideMimeType" in xhr)
                  xhr.overrideMimeType("text/plain; charset=x-user-defined");

                if ("requestTimeout" in opts) {
                  xhr.timeout = opts.requestTimeout;
                  xhr.ontimeout = function () {
                    self.emit("requestTimeout");
                  };
                }

                headersList.forEach(function (header) {
                  xhr.setRequestHeader(header[0], header[1]);
                });

                self._response = null;
                xhr.onreadystatechange = function () {
                  switch (xhr.readyState) {
                    case rStates.LOADING:
                    case rStates.DONE:
                      self._onXHRProgress();
                      break;
                  }
                };
                // Necessary for streaming in Firefox, since xhr.response is ONLY defined
                // in onprogress, not in onreadystatechange with xhr.readyState = 3
                if (self._mode === "moz-chunked-arraybuffer") {
                  xhr.onprogress = function () {
                    self._onXHRProgress();
                  };
                }

                xhr.onerror = function () {
                  if (self._destroyed) return;
                  self._resetTimers(true);
                  self.emit("error", new Error("XHR error"));
                };

                try {
                  xhr.send(body);
                } catch (err) {
                  process.nextTick(function () {
                    self.emit("error", err);
                  });
                  return;
                }
              }
            };

            /**
             * Checks if xhr.status is readable and non-zero, indicating no error.
             * Even though the spec says it should be available in readyState 3,
             * accessing it throws an exception in IE8
             */
            function statusValid(xhr) {
              try {
                var status = xhr.status;
                return status !== null && status !== 0;
              } catch (e) {
                return false;
              }
            }

            ClientRequest.prototype._onXHRProgress = function () {
              var self = this;

              self._resetTimers(false);

              if (!statusValid(self._xhr) || self._destroyed) return;

              if (!self._response) self._connect();

              self._response._onXHRProgress(self._resetTimers.bind(self));
            };

            ClientRequest.prototype._connect = function () {
              var self = this;

              if (self._destroyed) return;

              self._response = new IncomingMessage(
                self._xhr,
                self._fetchResponse,
                self._mode,
                self._resetTimers.bind(self),
              );
              self._response.on("error", function (err) {
                self.emit("error", err);
              });

              self.emit("response", self._response);
            };

            ClientRequest.prototype._write = function (chunk, encoding, cb) {
              var self = this;

              self._body.push(chunk);
              cb();
            };

            ClientRequest.prototype._resetTimers = function (done) {
              var self = this;

              global.clearTimeout(self._socketTimer);
              self._socketTimer = null;

              if (done) {
                global.clearTimeout(self._fetchTimer);
                self._fetchTimer = null;
              } else if (self._socketTimeout) {
                self._socketTimer = global.setTimeout(function () {
                  self.emit("timeout");
                }, self._socketTimeout);
              }
            };

            ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
              var self = this;
              self._destroyed = true;
              self._resetTimers(true);
              if (self._response) self._response._destroyed = true;
              if (self._xhr) self._xhr.abort();
              else if (self._fetchAbortController) self._fetchAbortController.abort();

              if (err) self.emit("error", err);
            };

            ClientRequest.prototype.end = function (data, encoding, cb) {
              var self = this;
              if (typeof data === "function") {
                cb = data;
                data = undefined;
              }

              stream.Writable.prototype.end.call(self, data, encoding, cb);
            };

            ClientRequest.prototype.setTimeout = function (timeout, cb) {
              var self = this;

              if (cb) self.once("timeout", cb);

              self._socketTimeout = timeout;
              self._resetTimers(false);
            };

            ClientRequest.prototype.flushHeaders = function () {};
            ClientRequest.prototype.setNoDelay = function () {};
            ClientRequest.prototype.setSocketKeepAlive = function () {};

            // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
            var unsafeHeaders = [
              "accept-charset",
              "accept-encoding",
              "access-control-request-headers",
              "access-control-request-method",
              "connection",
              "content-length",
              "cookie",
              "cookie2",
              "date",
              "dnt",
              "expect",
              "host",
              "keep-alive",
              "origin",
              "referer",
              "te",
              "trailer",
              "transfer-encoding",
              "upgrade",
              "via",
            ];
          }).call(this);
        }).call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
          require("buffer").Buffer,
        );
      },
      { "./capability": 193, "./response": 195, _process: 172, buffer: 132, inherits: 139, "readable-stream": 191 },
    ],
    195: [
      function (require, module, exports) {
        (function (process, global, Buffer) {
          (function () {
            var capability = require("./capability");
            var inherits = require("inherits");
            var stream = require("readable-stream");

            var rStates = (exports.readyStates = {
              UNSENT: 0,
              OPENED: 1,
              HEADERS_RECEIVED: 2,
              LOADING: 3,
              DONE: 4,
            });

            var IncomingMessage = (exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
              var self = this;
              stream.Readable.call(self);

              self._mode = mode;
              self.headers = {};
              self.rawHeaders = [];
              self.trailers = {};
              self.rawTrailers = [];

              // Fake the 'close' event, but only once 'end' fires
              self.on("end", function () {
                // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
                process.nextTick(function () {
                  self.emit("close");
                });
              });

              if (mode === "fetch") {
                self._fetchResponse = response;

                self.url = response.url;
                self.statusCode = response.status;
                self.statusMessage = response.statusText;

                response.headers.forEach(function (header, key) {
                  self.headers[key.toLowerCase()] = header;
                  self.rawHeaders.push(key, header);
                });

                if (capability.writableStream) {
                  var writable = new WritableStream({
                    write: function (chunk) {
                      resetTimers(false);
                      return new Promise(function (resolve, reject) {
                        if (self._destroyed) {
                          reject();
                        } else if (self.push(Buffer.from(chunk))) {
                          resolve();
                        } else {
                          self._resumeFetch = resolve;
                        }
                      });
                    },
                    close: function () {
                      resetTimers(true);
                      if (!self._destroyed) self.push(null);
                    },
                    abort: function (err) {
                      resetTimers(true);
                      if (!self._destroyed) self.emit("error", err);
                    },
                  });

                  try {
                    response.body.pipeTo(writable).catch(function (err) {
                      resetTimers(true);
                      if (!self._destroyed) self.emit("error", err);
                    });
                    return;
                  } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
                }
                // fallback for when writableStream or pipeTo aren't available
                var reader = response.body.getReader();
                function read() {
                  reader
                    .read()
                    .then(function (result) {
                      if (self._destroyed) return;
                      resetTimers(result.done);
                      if (result.done) {
                        self.push(null);
                        return;
                      }
                      self.push(Buffer.from(result.value));
                      read();
                    })
                    .catch(function (err) {
                      resetTimers(true);
                      if (!self._destroyed) self.emit("error", err);
                    });
                }
                read();
              } else {
                self._xhr = xhr;
                self._pos = 0;

                self.url = xhr.responseURL;
                self.statusCode = xhr.status;
                self.statusMessage = xhr.statusText;
                var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                headers.forEach(function (header) {
                  var matches = header.match(/^([^:]+):\s*(.*)/);
                  if (matches) {
                    var key = matches[1].toLowerCase();
                    if (key === "set-cookie") {
                      if (self.headers[key] === undefined) {
                        self.headers[key] = [];
                      }
                      self.headers[key].push(matches[2]);
                    } else if (self.headers[key] !== undefined) {
                      self.headers[key] += ", " + matches[2];
                    } else {
                      self.headers[key] = matches[2];
                    }
                    self.rawHeaders.push(matches[1], matches[2]);
                  }
                });

                self._charset = "x-user-defined";
                if (!capability.overrideMimeType) {
                  var mimeType = self.rawHeaders["mime-type"];
                  if (mimeType) {
                    var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                    if (charsetMatch) {
                      self._charset = charsetMatch[1].toLowerCase();
                    }
                  }
                  if (!self._charset) self._charset = "utf-8"; // best guess
                }
              }
            });

            inherits(IncomingMessage, stream.Readable);

            IncomingMessage.prototype._read = function () {
              var self = this;

              var resolve = self._resumeFetch;
              if (resolve) {
                self._resumeFetch = null;
                resolve();
              }
            };

            IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
              var self = this;

              var xhr = self._xhr;

              var response = null;
              switch (self._mode) {
                case "text":
                  response = xhr.responseText;
                  if (response.length > self._pos) {
                    var newData = response.substr(self._pos);
                    if (self._charset === "x-user-defined") {
                      var buffer = Buffer.alloc(newData.length);
                      for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;

                      self.push(buffer);
                    } else {
                      self.push(newData, self._charset);
                    }
                    self._pos = response.length;
                  }
                  break;
                case "arraybuffer":
                  if (xhr.readyState !== rStates.DONE || !xhr.response) break;
                  response = xhr.response;
                  self.push(Buffer.from(new Uint8Array(response)));
                  break;
                case "moz-chunked-arraybuffer": // take whole
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING || !response) break;
                  self.push(Buffer.from(new Uint8Array(response)));
                  break;
                case "ms-stream":
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING) break;
                  var reader = new global.MSStreamReader();
                  reader.onprogress = function () {
                    if (reader.result.byteLength > self._pos) {
                      self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));
                      self._pos = reader.result.byteLength;
                    }
                  };
                  reader.onload = function () {
                    resetTimers(true);
                    self.push(null);
                  };
                  // reader.onerror = ??? // TODO: this
                  reader.readAsArrayBuffer(response);
                  break;
              }

              // The ms-stream case handles end separately in reader.onload()
              if (self._xhr.readyState === rStates.DONE && self._mode !== "ms-stream") {
                resetTimers(true);
                self.push(null);
              }
            };
          }).call(this);
        }).call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
          require("buffer").Buffer,
        );
      },
      { "./capability": 193, _process: 172, buffer: 132, inherits: 139, "readable-stream": 191 },
    ],
    196: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        /*<replacement>*/

        var Buffer = require("safe-buffer").Buffer;
        /*</replacement>*/

        var isEncoding =
          Buffer.isEncoding ||
          function (encoding) {
            encoding = "" + encoding;
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true;
              default:
                return false;
            }
          };

        function _normalizeEncoding(enc) {
          if (!enc) return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }

        // Do not cache `Buffer.isEncoding` when checking encoding names as some
        // modules monkey-patch it to support additional encodings
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }

        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters.
        exports.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer.allocUnsafe(nb);
        }

        StringDecoder.prototype.write = function (buf) {
          if (buf.length === 0) return "";
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === undefined) return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || "";
        };

        StringDecoder.prototype.end = utf8End;

        // Returns only complete characters in a Buffer
        StringDecoder.prototype.text = utf8Text;

        // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
        StringDecoder.prototype.fillLast = function (buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };

        // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
        // continuation byte. If an invalid byte is detected, -2 is returned.
        function utf8CheckByte(byte) {
          if (byte <= 0x7f) return 0;
          else if (byte >> 5 === 0x06) return 2;
          else if (byte >> 4 === 0x0e) return 3;
          else if (byte >> 3 === 0x1e) return 4;
          return byte >> 6 === 0x02 ? -1 : -2;
        }

        // Checks at most 3 bytes at the end of a Buffer in order to detect an
        // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
        // needed to complete the UTF-8 character (if applicable) are returned.
        function utf8CheckIncomplete(self, buf, i) {
          var j = buf.length - 1;
          if (j < i) return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2) return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2) return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2) nb = 0;
              else self.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }

        // Validates as many continuation bytes for a multi-byte UTF-8 character as
        // needed or are available. If we see a non-continuation byte where we expect
        // one, we "replace" the validated continuation bytes we've seen so far with
        // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
        // behavior. The continuation byte check is included three times in the case
        // where all of the continuation bytes for a character exist in the same buffer.
        // It is also done this way as a slight performance increase instead of using a
        // loop.
        function utf8CheckExtraBytes(self, buf, p) {
          if ((buf[0] & 0xc0) !== 0x80) {
            self.lastNeed = 0;
            return "\ufffd";
          }
          if (self.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 0xc0) !== 0x80) {
              self.lastNeed = 1;
              return "\ufffd";
            }
            if (self.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2;
                return "\ufffd";
              }
            }
          }
        }

        // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf, p);
          if (r !== undefined) return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }

        // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
        // partial character, the character's bytes are buffered until the required
        // number of bytes are available.
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed) return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }

        // For UTF-8, a replacement character is added when ending on a partial
        // character.
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) return r + "\ufffd";
          return r;
        }

        // UTF-16LE typically needs two bytes per character, but even if we have an even
        // number of bytes available, we need to check if we end on a leading/high
        // surrogate. In that case, we need to wait for the next two bytes in order to
        // decode the last character properly.
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 0xd800 && c <= 0xdbff) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }

        // For UTF-16LE we do not explicitly append special replacement characters if we
        // end on a partial character, we simply let v8 handle that.
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
          }
          return r;
        }

        function base64Text(buf, i) {
          var n = (buf.length - i) % 3;
          if (n === 0) return buf.toString("base64", i);
          this.lastNeed = 3 - n;
          this.lastTotal = 3;
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n);
        }

        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r;
        }

        // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }

        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      },
      { "safe-buffer": 197 },
    ],
    197: [
      function (require, module, exports) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
        /* eslint-disable node/no-deprecated-api */
        var buffer = require("buffer");
        var Buffer = buffer.Buffer;

        // alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module.exports = buffer;
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports);
          exports.Buffer = SafeBuffer;
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }

        SafeBuffer.prototype = Object.create(Buffer.prototype);

        // Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer);

        SafeBuffer.from = function (arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };

        SafeBuffer.alloc = function (size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== undefined) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };

        SafeBuffer.allocUnsafe = function (size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };

        SafeBuffer.allocUnsafeSlow = function (size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      },
      { buffer: 132 },
    ],
    198: [
      function (require, module, exports) {
        /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
        (function (global, factory) {
          typeof exports === "object" && typeof module !== "undefined"
            ? factory(exports)
            : typeof define === "function" && define.amd
              ? define(["exports"], factory)
              : factory((global.URI = global.URI || {}));
        })(this, function (exports) {
          "use strict";

          function merge() {
            for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
              sets[_key] = arguments[_key];
            }

            if (sets.length > 1) {
              sets[0] = sets[0].slice(0, -1);
              var xl = sets.length - 1;
              for (var x = 1; x < xl; ++x) {
                sets[x] = sets[x].slice(1, -1);
              }
              sets[xl] = sets[xl].slice(1);
              return sets.join("");
            } else {
              return sets[0];
            }
          }
          function subexp(str) {
            return "(?:" + str + ")";
          }
          function typeOf(o) {
            return o === undefined
              ? "undefined"
              : o === null
                ? "null"
                : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
          }
          function toUpperCase(str) {
            return str.toUpperCase();
          }
          function toArray(obj) {
            return obj !== undefined && obj !== null
              ? obj instanceof Array
                ? obj
                : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call
                  ? [obj]
                  : Array.prototype.slice.call(obj)
              : [];
          }
          function assign(target, source) {
            var obj = target;
            if (source) {
              for (var key in source) {
                obj[key] = source[key];
              }
            }
            return obj;
          }

          function buildExps(isIRI) {
            var ALPHA$$ = "[A-Za-z]",
              CR$ = "[\\x0D]",
              DIGIT$$ = "[0-9]",
              DQUOTE$$ = "[\\x22]",
              HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
              //case-insensitive
              LF$$ = "[\\x0A]",
              SP$$ = "[\\x20]",
              PCT_ENCODED$ = subexp(
                subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) +
                  "|" +
                  subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) +
                  "|" +
                  subexp("%" + HEXDIG$$ + HEXDIG$$),
              ),
              //expanded
              GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
              SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
              RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
              UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
              //subset, excludes bidi control characters
              IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
              //subset
              UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
              SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
              USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
              DEC_OCTET$ = subexp(
                subexp("25[0-5]") +
                  "|" +
                  subexp("2[0-4]" + DIGIT$$) +
                  "|" +
                  subexp("1" + DIGIT$$ + DIGIT$$) +
                  "|" +
                  subexp("[1-9]" + DIGIT$$) +
                  "|" +
                  DIGIT$$,
              ),
              DEC_OCTET_RELAXED$ = subexp(
                subexp("25[0-5]") +
                  "|" +
                  subexp("2[0-4]" + DIGIT$$) +
                  "|" +
                  subexp("1" + DIGIT$$ + DIGIT$$) +
                  "|" +
                  subexp("0?[1-9]" + DIGIT$$) +
                  "|0?0?" +
                  DIGIT$$,
              ),
              //relaxed parsing rules
              IPV4ADDRESS$ = subexp(
                DEC_OCTET_RELAXED$ +
                  "\\." +
                  DEC_OCTET_RELAXED$ +
                  "\\." +
                  DEC_OCTET_RELAXED$ +
                  "\\." +
                  DEC_OCTET_RELAXED$,
              ),
              H16$ = subexp(HEXDIG$$ + "{1,4}"),
              LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
              IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
              //                           6( h16 ":" ) ls32
              IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
              //                      "::" 5( h16 ":" ) ls32
              IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
              //[               h16 ] "::" 4( h16 ":" ) ls32
              IPV6ADDRESS4$ = subexp(
                subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$,
              ),
              //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              IPV6ADDRESS5$ = subexp(
                subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$,
              ),
              //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
              //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
              //[ *4( h16 ":" ) h16 ] "::"              ls32
              IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
              //[ *5( h16 ":" ) h16 ] "::"              h16
              IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
              //[ *6( h16 ":" ) h16 ] "::"
              IPV6ADDRESS$ = subexp(
                [
                  IPV6ADDRESS1$,
                  IPV6ADDRESS2$,
                  IPV6ADDRESS3$,
                  IPV6ADDRESS4$,
                  IPV6ADDRESS5$,
                  IPV6ADDRESS6$,
                  IPV6ADDRESS7$,
                  IPV6ADDRESS8$,
                  IPV6ADDRESS9$,
                ].join("|"),
              ),
              ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
              //RFC 6874
              IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
              //RFC 6874
              IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
              //RFC 6874, with relaxed parsing rules
              IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
              IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
              //RFC 6874
              REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
              HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
              PORT$ = subexp(DIGIT$$ + "*"),
              AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
              PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
              SEGMENT$ = subexp(PCHAR$ + "*"),
              SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
              SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
              PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
              PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
              //simplified
              PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
              //simplified
              PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
              //simplified
              PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
              PATH$ = subexp(
                PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$,
              ),
              QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
              FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
              HIER_PART$ = subexp(
                subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) +
                  "|" +
                  PATH_ABSOLUTE$ +
                  "|" +
                  PATH_ROOTLESS$ +
                  "|" +
                  PATH_EMPTY$,
              ),
              URI$ = subexp(
                SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?",
              ),
              RELATIVE_PART$ = subexp(
                subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) +
                  "|" +
                  PATH_ABSOLUTE$ +
                  "|" +
                  PATH_NOSCHEME$ +
                  "|" +
                  PATH_EMPTY$,
              ),
              RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
              URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
              ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
              GENERIC_REF$ =
                "^(" +
                SCHEME$ +
                ")\\:" +
                subexp(
                  subexp(
                    "\\/\\/(" +
                      subexp("(" + USERINFO$ + ")@") +
                      "?(" +
                      HOST$ +
                      ")" +
                      subexp("\\:(" + PORT$ + ")") +
                      "?)",
                  ) +
                    "?(" +
                    PATH_ABEMPTY$ +
                    "|" +
                    PATH_ABSOLUTE$ +
                    "|" +
                    PATH_ROOTLESS$ +
                    "|" +
                    PATH_EMPTY$ +
                    ")",
                ) +
                subexp("\\?(" + QUERY$ + ")") +
                "?" +
                subexp("\\#(" + FRAGMENT$ + ")") +
                "?$",
              RELATIVE_REF$ =
                "^(){0}" +
                subexp(
                  subexp(
                    "\\/\\/(" +
                      subexp("(" + USERINFO$ + ")@") +
                      "?(" +
                      HOST$ +
                      ")" +
                      subexp("\\:(" + PORT$ + ")") +
                      "?)",
                  ) +
                    "?(" +
                    PATH_ABEMPTY$ +
                    "|" +
                    PATH_ABSOLUTE$ +
                    "|" +
                    PATH_NOSCHEME$ +
                    "|" +
                    PATH_EMPTY$ +
                    ")",
                ) +
                subexp("\\?(" + QUERY$ + ")") +
                "?" +
                subexp("\\#(" + FRAGMENT$ + ")") +
                "?$",
              ABSOLUTE_REF$ =
                "^(" +
                SCHEME$ +
                ")\\:" +
                subexp(
                  subexp(
                    "\\/\\/(" +
                      subexp("(" + USERINFO$ + ")@") +
                      "?(" +
                      HOST$ +
                      ")" +
                      subexp("\\:(" + PORT$ + ")") +
                      "?)",
                  ) +
                    "?(" +
                    PATH_ABEMPTY$ +
                    "|" +
                    PATH_ABSOLUTE$ +
                    "|" +
                    PATH_ROOTLESS$ +
                    "|" +
                    PATH_EMPTY$ +
                    ")",
                ) +
                subexp("\\?(" + QUERY$ + ")") +
                "?$",
              SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
              AUTHORITY_REF$ =
                "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
            return {
              NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
              NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
              NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
              NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
              NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
              NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
              NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
              ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
              UNRESERVED: new RegExp(UNRESERVED$$, "g"),
              OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
              PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
              IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
              IPV6ADDRESS: new RegExp(
                "^\\[?(" +
                  IPV6ADDRESS$ +
                  ")" +
                  subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") +
                  "?\\]?$",
              ), //RFC 6874, with relaxed parsing rules
            };
          }
          var URI_PROTOCOL = buildExps(false);

          var IRI_PROTOCOL = buildExps(true);

          var slicedToArray = (function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          })();

          var toConsumableArray = function (arr) {
            if (Array.isArray(arr)) {
              for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

              return arr2;
            } else {
              return Array.from(arr);
            }
          };

          /** Highest positive signed 32-bit float value */

          var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

          /** Bootstring parameters */
          var base = 36;
          var tMin = 1;
          var tMax = 26;
          var skew = 38;
          var damp = 700;
          var initialBias = 72;
          var initialN = 128; // 0x80
          var delimiter = "-"; // '\x2D'

          /** Regular expressions */
          var regexPunycode = /^xn--/;
          var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
          var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

          /** Error messages */
          var errors = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input",
          };

          /** Convenience shortcuts */
          var baseMinusTMin = base - tMin;
          var floor = Math.floor;
          var stringFromCharCode = String.fromCharCode;

          /*--------------------------------------------------------------------------*/

          /**
           * A generic error utility function.
           * @private
           * @param {String} type The error type.
           * @returns {Error} Throws a `RangeError` with the applicable error message.
           */
          function error$1(type) {
            throw new RangeError(errors[type]);
          }

          /**
           * A generic `Array#map` utility function.
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} callback The function that gets called for every array
           * item.
           * @returns {Array} A new array of values returned by the callback function.
           */
          function map(array, fn) {
            var result = [];
            var length = array.length;
            while (length--) {
              result[length] = fn(array[length]);
            }
            return result;
          }

          /**
           * A simple `Array#map`-like wrapper to work with domain name strings or email
           * addresses.
           * @private
           * @param {String} domain The domain name or email address.
           * @param {Function} callback The function that gets called for every
           * character.
           * @returns {Array} A new string of characters returned by the callback
           * function.
           */
          function mapDomain(string, fn) {
            var parts = string.split("@");
            var result = "";
            if (parts.length > 1) {
              // In email addresses, only the domain name should be punycoded. Leave
              // the local part (i.e. everything up to `@`) intact.
              result = parts[0] + "@";
              string = parts[1];
            }
            // Avoid `split(regex)` for IE8 compatibility. See #17.
            string = string.replace(regexSeparators, "\x2E");
            var labels = string.split(".");
            var encoded = map(labels, fn).join(".");
            return result + encoded;
          }

          /**
           * Creates an array containing the numeric code points of each Unicode
           * character in the string. While JavaScript uses UCS-2 internally,
           * this function will convert a pair of surrogate halves (each of which
           * UCS-2 exposes as separate characters) into a single code point,
           * matching UTF-16.
           * @see `punycode.ucs2.encode`
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode.ucs2
           * @name decode
           * @param {String} string The Unicode input string (UCS-2).
           * @returns {Array} The new array of code points.
           */
          function ucs2decode(string) {
            var output = [];
            var counter = 0;
            var length = string.length;
            while (counter < length) {
              var value = string.charCodeAt(counter++);
              if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                // It's a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xfc00) == 0xdc00) {
                  // Low surrogate.
                  output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                } else {
                  // It's an unmatched surrogate; only append this code unit, in case the
                  // next code unit is the high surrogate of a surrogate pair.
                  output.push(value);
                  counter--;
                }
              } else {
                output.push(value);
              }
            }
            return output;
          }

          /**
           * Creates a string based on an array of numeric code points.
           * @see `punycode.ucs2.decode`
           * @memberOf punycode.ucs2
           * @name encode
           * @param {Array} codePoints The array of numeric code points.
           * @returns {String} The new Unicode string (UCS-2).
           */
          var ucs2encode = function ucs2encode(array) {
            return String.fromCodePoint.apply(String, toConsumableArray(array));
          };

          /**
           * Converts a basic code point into a digit/integer.
           * @see `digitToBasic()`
           * @private
           * @param {Number} codePoint The basic numeric code point value.
           * @returns {Number} The numeric value of a basic code point (for use in
           * representing integers) in the range `0` to `base - 1`, or `base` if
           * the code point does not represent a value.
           */
          var basicToDigit = function basicToDigit(codePoint) {
            if (codePoint - 0x30 < 0x0a) {
              return codePoint - 0x16;
            }
            if (codePoint - 0x41 < 0x1a) {
              return codePoint - 0x41;
            }
            if (codePoint - 0x61 < 0x1a) {
              return codePoint - 0x61;
            }
            return base;
          };

          /**
           * Converts a digit/integer into a basic code point.
           * @see `basicToDigit()`
           * @private
           * @param {Number} digit The numeric value of a basic code point.
           * @returns {Number} The basic code point whose value (when used for
           * representing integers) is `digit`, which needs to be in the range
           * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
           * used; else, the lowercase form is used. The behavior is undefined
           * if `flag` is non-zero and `digit` has no uppercase form.
           */
          var digitToBasic = function digitToBasic(digit, flag) {
            //  0..25 map to ASCII a..z or A..Z
            // 26..35 map to ASCII 0..9
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
          };

          /**
           * Bias adaptation function as per section 3.4 of RFC 3492.
           * https://tools.ietf.org/html/rfc3492#section-3.4
           * @private
           */
          var adapt = function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {
              delta = floor(delta / baseMinusTMin);
            }
            return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
          };

          /**
           * Converts a Punycode string of ASCII-only symbols to a string of Unicode
           * symbols.
           * @memberOf punycode
           * @param {String} input The Punycode string of ASCII-only symbols.
           * @returns {String} The resulting string of Unicode symbols.
           */
          var decode = function decode(input) {
            // Don't use UCS-2.
            var output = [];
            var inputLength = input.length;
            var i = 0;
            var n = initialN;
            var bias = initialBias;

            // Handle the basic code points: let `basic` be the number of input code
            // points before the last delimiter, or `0` if there is none, then copy
            // the first basic code points to the output.

            var basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
              basic = 0;
            }

            for (var j = 0; j < basic; ++j) {
              // if it's not a basic code point
              if (input.charCodeAt(j) >= 0x80) {
                error$1("not-basic");
              }
              output.push(input.charCodeAt(j));
            }

            // Main decoding loop: start just after the last delimiter if any basic code
            // points were copied; start at the beginning otherwise.

            for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) /* no final expression */ {
              // `index` is the index of the next character to be consumed.
              // Decode a generalized variable-length integer into `delta`,
              // which gets added to `i`. The overflow checking is easier
              // if we increase `i` as we go, then subtract off its starting
              // value at the end to obtain `delta`.
              var oldi = i;
              for (var w = 1, k = base; ; /* no condition */ k += base) {
                if (index >= inputLength) {
                  error$1("invalid-input");
                }

                var digit = basicToDigit(input.charCodeAt(index++));

                if (digit >= base || digit > floor((maxInt - i) / w)) {
                  error$1("overflow");
                }

                i += digit * w;
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                if (digit < t) {
                  break;
                }

                var baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                  error$1("overflow");
                }

                w *= baseMinusT;
              }

              var out = output.length + 1;
              bias = adapt(i - oldi, out, oldi == 0);

              // `i` was supposed to wrap around from `out` to `0`,
              // incrementing `n` each time, so we'll fix that now:
              if (floor(i / out) > maxInt - n) {
                error$1("overflow");
              }

              n += floor(i / out);
              i %= out;

              // Insert `n` at position `i` of the output.
              output.splice(i++, 0, n);
            }

            return String.fromCodePoint.apply(String, output);
          };

          /**
           * Converts a string of Unicode symbols (e.g. a domain name label) to a
           * Punycode string of ASCII-only symbols.
           * @memberOf punycode
           * @param {String} input The string of Unicode symbols.
           * @returns {String} The resulting Punycode string of ASCII-only symbols.
           */
          var encode = function encode(input) {
            var output = [];

            // Convert the input in UCS-2 to an array of Unicode code points.
            input = ucs2decode(input);

            // Cache the length.
            var inputLength = input.length;

            // Initialize the state.
            var n = initialN;
            var delta = 0;
            var bias = initialBias;

            // Handle the basic code points.
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (
                var _iterator = input[Symbol.iterator](), _step;
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = true
              ) {
                var _currentValue2 = _step.value;

                if (_currentValue2 < 0x80) {
                  output.push(stringFromCharCode(_currentValue2));
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            var basicLength = output.length;
            var handledCPCount = basicLength;

            // `handledCPCount` is the number of code points that have been handled;
            // `basicLength` is the number of basic code points.

            // Finish the basic string with a delimiter unless it's empty.
            if (basicLength) {
              output.push(delimiter);
            }

            // Main encoding loop:
            while (handledCPCount < inputLength) {
              // All non-basic code points < n have been handled already. Find the next
              // larger one:
              var m = maxInt;
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (
                  var _iterator2 = input[Symbol.iterator](), _step2;
                  !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);
                  _iteratorNormalCompletion2 = true
                ) {
                  var currentValue = _step2.value;

                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow.
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              var handledCPCountPlusOne = handledCPCount + 1;
              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error$1("overflow");
              }

              delta += (m - n) * handledCPCountPlusOne;
              n = m;

              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (
                  var _iterator3 = input[Symbol.iterator](), _step3;
                  !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done);
                  _iteratorNormalCompletion3 = true
                ) {
                  var _currentValue = _step3.value;

                  if (_currentValue < n && ++delta > maxInt) {
                    error$1("overflow");
                  }
                  if (_currentValue == n) {
                    // Represent delta as a generalized variable-length integer.
                    var q = delta;
                    for (var k = base; ; /* no condition */ k += base) {
                      var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (q < t) {
                        break;
                      }
                      var qMinusT = q - t;
                      var baseMinusT = base - t;
                      output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));
                      q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              ++delta;
              ++n;
            }
            return output.join("");
          };

          /**
           * Converts a Punycode string representing a domain name or an email address
           * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
           * it doesn't matter if you call it on a string that has already been
           * converted to Unicode.
           * @memberOf punycode
           * @param {String} input The Punycoded domain name or email address to
           * convert to Unicode.
           * @returns {String} The Unicode representation of the given Punycode
           * string.
           */
          var toUnicode = function toUnicode(input) {
            return mapDomain(input, function (string) {
              return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
          };

          /**
           * Converts a Unicode string representing a domain name or an email address to
           * Punycode. Only the non-ASCII parts of the domain name will be converted,
           * i.e. it doesn't matter if you call it with a domain that's already in
           * ASCII.
           * @memberOf punycode
           * @param {String} input The domain name or email address to convert, as a
           * Unicode string.
           * @returns {String} The Punycode representation of the given domain name or
           * email address.
           */
          var toASCII = function toASCII(input) {
            return mapDomain(input, function (string) {
              return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
            });
          };

          /*--------------------------------------------------------------------------*/

          /** Define the public API */
          var punycode = {
            /**
             * A string representing the current Punycode.js version number.
             * @memberOf punycode
             * @type String
             */
            version: "2.1.0",
            /**
             * An object of methods to convert from JavaScript's internal character
             * representation (UCS-2) to Unicode code points, and back.
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode
             * @type Object
             */
            ucs2: {
              decode: ucs2decode,
              encode: ucs2encode,
            },
            decode: decode,
            encode: encode,
            toASCII: toASCII,
            toUnicode: toUnicode,
          };

          /**
           * URI.js
           *
           * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
           * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
           * @see http://github.com/garycourt/uri-js
           */
          /**
           * Copyright 2011 Gary Court. All rights reserved.
           *
           * Redistribution and use in source and binary forms, with or without modification, are
           * permitted provided that the following conditions are met:
           *
           *    1. Redistributions of source code must retain the above copyright notice, this list of
           *       conditions and the following disclaimer.
           *
           *    2. Redistributions in binary form must reproduce the above copyright notice, this list
           *       of conditions and the following disclaimer in the documentation and/or other materials
           *       provided with the distribution.
           *
           * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
           * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
           * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
           * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
           * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
           *
           * The views and conclusions contained in the software and documentation are those of the
           * authors and should not be interpreted as representing official policies, either expressed
           * or implied, of Gary Court.
           */
          var SCHEMES = {};
          function pctEncChar(chr) {
            var c = chr.charCodeAt(0);
            var e = void 0;
            if (c < 16) e = "%0" + c.toString(16).toUpperCase();
            else if (c < 128) e = "%" + c.toString(16).toUpperCase();
            else if (c < 2048)
              e = "%" + ((c >> 6) | 192).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();
            else
              e =
                "%" +
                ((c >> 12) | 224).toString(16).toUpperCase() +
                "%" +
                (((c >> 6) & 63) | 128).toString(16).toUpperCase() +
                "%" +
                ((c & 63) | 128).toString(16).toUpperCase();
            return e;
          }
          function pctDecChars(str) {
            var newStr = "";
            var i = 0;
            var il = str.length;
            while (i < il) {
              var c = parseInt(str.substr(i + 1, 2), 16);
              if (c < 128) {
                newStr += String.fromCharCode(c);
                i += 3;
              } else if (c >= 194 && c < 224) {
                if (il - i >= 6) {
                  var c2 = parseInt(str.substr(i + 4, 2), 16);
                  newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                } else {
                  newStr += str.substr(i, 6);
                }
                i += 6;
              } else if (c >= 224) {
                if (il - i >= 9) {
                  var _c = parseInt(str.substr(i + 4, 2), 16);
                  var c3 = parseInt(str.substr(i + 7, 2), 16);
                  newStr += String.fromCharCode(((c & 15) << 12) | ((_c & 63) << 6) | (c3 & 63));
                } else {
                  newStr += str.substr(i, 9);
                }
                i += 9;
              } else {
                newStr += str.substr(i, 3);
                i += 3;
              }
            }
            return newStr;
          }
          function _normalizeComponentEncoding(components, protocol) {
            function decodeUnreserved(str) {
              var decStr = pctDecChars(str);
              return !decStr.match(protocol.UNRESERVED) ? str : decStr;
            }
            if (components.scheme)
              components.scheme = String(components.scheme)
                .replace(protocol.PCT_ENCODED, decodeUnreserved)
                .toLowerCase()
                .replace(protocol.NOT_SCHEME, "");
            if (components.userinfo !== undefined)
              components.userinfo = String(components.userinfo)
                .replace(protocol.PCT_ENCODED, decodeUnreserved)
                .replace(protocol.NOT_USERINFO, pctEncChar)
                .replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.host !== undefined)
              components.host = String(components.host)
                .replace(protocol.PCT_ENCODED, decodeUnreserved)
                .toLowerCase()
                .replace(protocol.NOT_HOST, pctEncChar)
                .replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.path !== undefined)
              components.path = String(components.path)
                .replace(protocol.PCT_ENCODED, decodeUnreserved)
                .replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar)
                .replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.query !== undefined)
              components.query = String(components.query)
                .replace(protocol.PCT_ENCODED, decodeUnreserved)
                .replace(protocol.NOT_QUERY, pctEncChar)
                .replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.fragment !== undefined)
              components.fragment = String(components.fragment)
                .replace(protocol.PCT_ENCODED, decodeUnreserved)
                .replace(protocol.NOT_FRAGMENT, pctEncChar)
                .replace(protocol.PCT_ENCODED, toUpperCase);
            return components;
          }

          function _stripLeadingZeros(str) {
            return str.replace(/^0*(.*)/, "$1") || "0";
          }
          function _normalizeIPv4(host, protocol) {
            var matches = host.match(protocol.IPV4ADDRESS) || [];

            var _matches = slicedToArray(matches, 2),
              address = _matches[1];

            if (address) {
              return address.split(".").map(_stripLeadingZeros).join(".");
            } else {
              return host;
            }
          }
          function _normalizeIPv6(host, protocol) {
            var matches = host.match(protocol.IPV6ADDRESS) || [];

            var _matches2 = slicedToArray(matches, 3),
              address = _matches2[1],
              zone = _matches2[2];

            if (address) {
              var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(),
                _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
                last = _address$toLowerCase$2[0],
                first = _address$toLowerCase$2[1];

              var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
              var lastFields = last.split(":").map(_stripLeadingZeros);
              var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
              var fieldCount = isLastFieldIPv4Address ? 7 : 8;
              var lastFieldsStart = lastFields.length - fieldCount;
              var fields = Array(fieldCount);
              for (var x = 0; x < fieldCount; ++x) {
                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
              }
              if (isLastFieldIPv4Address) {
                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
              }
              var allZeroFields = fields.reduce(function (acc, field, index) {
                if (!field || field === "0") {
                  var lastLongest = acc[acc.length - 1];
                  if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                  } else {
                    acc.push({ index: index, length: 1 });
                  }
                }
                return acc;
              }, []);
              var longestZeroFields = allZeroFields.sort(function (a, b) {
                return b.length - a.length;
              })[0];
              var newHost = void 0;
              if (longestZeroFields && longestZeroFields.length > 1) {
                var newFirst = fields.slice(0, longestZeroFields.index);
                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                newHost = newFirst.join(":") + "::" + newLast.join(":");
              } else {
                newHost = fields.join(":");
              }
              if (zone) {
                newHost += "%" + zone;
              }
              return newHost;
            } else {
              return host;
            }
          }
          var URI_PARSE =
            /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
          var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
          function parse(uriString) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var components = {};
            var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
            if (options.reference === "suffix")
              uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
            var matches = uriString.match(URI_PARSE);
            if (matches) {
              if (NO_MATCH_IS_UNDEFINED) {
                //store each component
                components.scheme = matches[1];
                components.userinfo = matches[3];
                components.host = matches[4];
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = matches[7];
                components.fragment = matches[8];
                //fix port number
                if (isNaN(components.port)) {
                  components.port = matches[5];
                }
              } else {
                //IE FIX for improper RegExp matching
                //store each component
                components.scheme = matches[1] || undefined;
                components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                //fix port number
                if (isNaN(components.port)) {
                  components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
                }
              }
              if (components.host) {
                //normalize IP hosts
                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
              }
              //determine reference type
              if (
                components.scheme === undefined &&
                components.userinfo === undefined &&
                components.host === undefined &&
                components.port === undefined &&
                !components.path &&
                components.query === undefined
              ) {
                components.reference = "same-document";
              } else if (components.scheme === undefined) {
                components.reference = "relative";
              } else if (components.fragment === undefined) {
                components.reference = "absolute";
              } else {
                components.reference = "uri";
              }
              //check for reference errors
              if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
                components.error = components.error || "URI is not a " + options.reference + " reference.";
              }
              //find scheme handler
              var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
              //check if scheme can't handle IRIs
              if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                //if host component is a domain name
                if (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {
                  //convert Unicode IDN -> ASCII IDN
                  try {
                    components.host = punycode.toASCII(
                      components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase(),
                    );
                  } catch (e) {
                    components.error =
                      components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                  }
                }
                //convert IRI -> URI
                _normalizeComponentEncoding(components, URI_PROTOCOL);
              } else {
                //normalize encodings
                _normalizeComponentEncoding(components, protocol);
              }
              //perform scheme specific parsing
              if (schemeHandler && schemeHandler.parse) {
                schemeHandler.parse(components, options);
              }
            } else {
              components.error = components.error || "URI can not be parsed.";
            }
            return components;
          }

          function _recomposeAuthority(components, options) {
            var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
            var uriTokens = [];
            if (components.userinfo !== undefined) {
              uriTokens.push(components.userinfo);
              uriTokens.push("@");
            }
            if (components.host !== undefined) {
              //normalize IP hosts, add brackets and escape zone separator for IPv6
              uriTokens.push(
                _normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(
                  protocol.IPV6ADDRESS,
                  function (_, $1, $2) {
                    return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
                  },
                ),
              );
            }
            if (typeof components.port === "number" || typeof components.port === "string") {
              uriTokens.push(":");
              uriTokens.push(String(components.port));
            }
            return uriTokens.length ? uriTokens.join("") : undefined;
          }

          var RDS1 = /^\.\.?\//;
          var RDS2 = /^\/\.(\/|$)/;
          var RDS3 = /^\/\.\.(\/|$)/;
          var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
          function removeDotSegments(input) {
            var output = [];
            while (input.length) {
              if (input.match(RDS1)) {
                input = input.replace(RDS1, "");
              } else if (input.match(RDS2)) {
                input = input.replace(RDS2, "/");
              } else if (input.match(RDS3)) {
                input = input.replace(RDS3, "/");
                output.pop();
              } else if (input === "." || input === "..") {
                input = "";
              } else {
                var im = input.match(RDS5);
                if (im) {
                  var s = im[0];
                  input = input.slice(s.length);
                  output.push(s);
                } else {
                  throw new Error("Unexpected dot segment condition");
                }
              }
            }
            return output.join("");
          }

          function serialize(components) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
            var uriTokens = [];
            //find scheme handler
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            //perform scheme specific serialization
            if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
            if (components.host) {
              //if host component is an IPv6 address
              if (protocol.IPV6ADDRESS.test(components.host)) {
              }
              //TODO: normalize IPv6 address as per RFC 5952

              //if host component is a domain name
              else if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {
                //convert IDN via punycode
                try {
                  components.host = !options.iri
                    ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase())
                    : punycode.toUnicode(components.host);
                } catch (e) {
                  components.error =
                    components.error ||
                    "Host's domain name can not be converted to " +
                      (!options.iri ? "ASCII" : "Unicode") +
                      " via punycode: " +
                      e;
                }
              }
            }
            //normalize encoding
            _normalizeComponentEncoding(components, protocol);
            if (options.reference !== "suffix" && components.scheme) {
              uriTokens.push(components.scheme);
              uriTokens.push(":");
            }
            var authority = _recomposeAuthority(components, options);
            if (authority !== undefined) {
              if (options.reference !== "suffix") {
                uriTokens.push("//");
              }
              uriTokens.push(authority);
              if (components.path && components.path.charAt(0) !== "/") {
                uriTokens.push("/");
              }
            }
            if (components.path !== undefined) {
              var s = components.path;
              if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
                s = removeDotSegments(s);
              }
              if (authority === undefined) {
                s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
              }
              uriTokens.push(s);
            }
            if (components.query !== undefined) {
              uriTokens.push("?");
              uriTokens.push(components.query);
            }
            if (components.fragment !== undefined) {
              uriTokens.push("#");
              uriTokens.push(components.fragment);
            }
            return uriTokens.join(""); //merge tokens into a string
          }

          function resolveComponents(base, relative) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var skipNormalization = arguments[3];

            var target = {};
            if (!skipNormalization) {
              base = parse(serialize(base, options), options); //normalize base components
              relative = parse(serialize(relative, options), options); //normalize relative components
            }
            options = options || {};
            if (!options.tolerant && relative.scheme) {
              target.scheme = relative.scheme;
              //target.authority = relative.authority;
              target.userinfo = relative.userinfo;
              target.host = relative.host;
              target.port = relative.port;
              target.path = removeDotSegments(relative.path || "");
              target.query = relative.query;
            } else {
              if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                //target.authority = relative.authority;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || "");
                target.query = relative.query;
              } else {
                if (!relative.path) {
                  target.path = base.path;
                  if (relative.query !== undefined) {
                    target.query = relative.query;
                  } else {
                    target.query = base.query;
                  }
                } else {
                  if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                  } else {
                    if (
                      (base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &&
                      !base.path
                    ) {
                      target.path = "/" + relative.path;
                    } else if (!base.path) {
                      target.path = relative.path;
                    } else {
                      target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                  }
                  target.query = relative.query;
                }
                //target.authority = base.authority;
                target.userinfo = base.userinfo;
                target.host = base.host;
                target.port = base.port;
              }
              target.scheme = base.scheme;
            }
            target.fragment = relative.fragment;
            return target;
          }

          function resolve(baseURI, relativeURI, options) {
            var schemelessOptions = assign({ scheme: "null" }, options);
            return serialize(
              resolveComponents(
                parse(baseURI, schemelessOptions),
                parse(relativeURI, schemelessOptions),
                schemelessOptions,
                true,
              ),
              schemelessOptions,
            );
          }

          function normalize(uri, options) {
            if (typeof uri === "string") {
              uri = serialize(parse(uri, options), options);
            } else if (typeOf(uri) === "object") {
              uri = parse(serialize(uri, options), options);
            }
            return uri;
          }

          function equal(uriA, uriB, options) {
            if (typeof uriA === "string") {
              uriA = serialize(parse(uriA, options), options);
            } else if (typeOf(uriA) === "object") {
              uriA = serialize(uriA, options);
            }
            if (typeof uriB === "string") {
              uriB = serialize(parse(uriB, options), options);
            } else if (typeOf(uriB) === "object") {
              uriB = serialize(uriB, options);
            }
            return uriA === uriB;
          }

          function escapeComponent(str, options) {
            return (
              str &&
              str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar)
            );
          }

          function unescapeComponent(str, options) {
            return (
              str &&
              str
                .toString()
                .replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars)
            );
          }

          var handler = {
            scheme: "http",
            domainHost: true,
            parse: function parse(components, options) {
              //report missing host
              if (!components.host) {
                components.error = components.error || "HTTP URIs must have a host.";
              }
              return components;
            },
            serialize: function serialize(components, options) {
              var secure = String(components.scheme).toLowerCase() === "https";
              //normalize the default port
              if (components.port === (secure ? 443 : 80) || components.port === "") {
                components.port = undefined;
              }
              //normalize the empty path
              if (!components.path) {
                components.path = "/";
              }
              //NOTE: We do not parse query strings for HTTP URIs
              //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
              //and not the HTTP spec.
              return components;
            },
          };

          var handler$1 = {
            scheme: "https",
            domainHost: handler.domainHost,
            parse: handler.parse,
            serialize: handler.serialize,
          };

          function isSecure(wsComponents) {
            return typeof wsComponents.secure === "boolean"
              ? wsComponents.secure
              : String(wsComponents.scheme).toLowerCase() === "wss";
          }
          //RFC 6455
          var handler$2 = {
            scheme: "ws",
            domainHost: true,
            parse: function parse(components, options) {
              var wsComponents = components;
              //indicate if the secure flag is set
              wsComponents.secure = isSecure(wsComponents);
              //construct resouce name
              wsComponents.resourceName =
                (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
              wsComponents.path = undefined;
              wsComponents.query = undefined;
              return wsComponents;
            },
            serialize: function serialize(wsComponents, options) {
              //normalize the default port
              if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
                wsComponents.port = undefined;
              }
              //ensure scheme matches secure flag
              if (typeof wsComponents.secure === "boolean") {
                wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
                wsComponents.secure = undefined;
              }
              //reconstruct path from resource name
              if (wsComponents.resourceName) {
                var _wsComponents$resourc = wsComponents.resourceName.split("?"),
                  _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                  path = _wsComponents$resourc2[0],
                  query = _wsComponents$resourc2[1];

                wsComponents.path = path && path !== "/" ? path : undefined;
                wsComponents.query = query;
                wsComponents.resourceName = undefined;
              }
              //forbid fragment component
              wsComponents.fragment = undefined;
              return wsComponents;
            },
          };

          var handler$3 = {
            scheme: "wss",
            domainHost: handler$2.domainHost,
            parse: handler$2.parse,
            serialize: handler$2.serialize,
          };

          var O = {};
          var isIRI = true;
          //RFC 3986
          var UNRESERVED$$ =
            "[A-Za-z0-9\\-\\.\\_\\~" +
            (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") +
            "]";
          var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
          var PCT_ENCODED$ = subexp(
            subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) +
              "|" +
              subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) +
              "|" +
              subexp("%" + HEXDIG$$ + HEXDIG$$),
          ); //expanded
          //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
          //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
          //const WSP$$ = "[\\x20\\x09]";
          //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
          //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
          //const VCHAR$$ = "[\\x21-\\x7E]";
          //const WSP$$ = "[\\x20\\x09]";
          //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
          //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
          //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
          //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
          var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
          var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
          var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
          var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
          var UNRESERVED = new RegExp(UNRESERVED$$, "g");
          var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
          var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
          var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
          var NOT_HFVALUE = NOT_HFNAME;
          function decodeUnreserved(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(UNRESERVED) ? str : decStr;
          }
          var handler$4 = {
            scheme: "mailto",
            parse: function parse$$1(components, options) {
              var mailtoComponents = components;
              var to = (mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : []);
              mailtoComponents.path = undefined;
              if (mailtoComponents.query) {
                var unknownHeaders = false;
                var headers = {};
                var hfields = mailtoComponents.query.split("&");
                for (var x = 0, xl = hfields.length; x < xl; ++x) {
                  var hfield = hfields[x].split("=");
                  switch (hfield[0]) {
                    case "to":
                      var toAddrs = hfield[1].split(",");
                      for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                        to.push(toAddrs[_x]);
                      }
                      break;
                    case "subject":
                      mailtoComponents.subject = unescapeComponent(hfield[1], options);
                      break;
                    case "body":
                      mailtoComponents.body = unescapeComponent(hfield[1], options);
                      break;
                    default:
                      unknownHeaders = true;
                      headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                      break;
                  }
                }
                if (unknownHeaders) mailtoComponents.headers = headers;
              }
              mailtoComponents.query = undefined;
              for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
                var addr = to[_x2].split("@");
                addr[0] = unescapeComponent(addr[0]);
                if (!options.unicodeSupport) {
                  //convert Unicode IDN -> ASCII IDN
                  try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                  } catch (e) {
                    mailtoComponents.error =
                      mailtoComponents.error ||
                      "Email address's domain name can not be converted to ASCII via punycode: " + e;
                  }
                } else {
                  addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                }
                to[_x2] = addr.join("@");
              }
              return mailtoComponents;
            },
            serialize: function serialize$$1(mailtoComponents, options) {
              var components = mailtoComponents;
              var to = toArray(mailtoComponents.to);
              if (to) {
                for (var x = 0, xl = to.length; x < xl; ++x) {
                  var toAddr = String(to[x]);
                  var atIdx = toAddr.lastIndexOf("@");
                  var localPart = toAddr
                    .slice(0, atIdx)
                    .replace(PCT_ENCODED, decodeUnreserved)
                    .replace(PCT_ENCODED, toUpperCase)
                    .replace(NOT_LOCAL_PART, pctEncChar);
                  var domain = toAddr.slice(atIdx + 1);
                  //convert IDN via punycode
                  try {
                    domain = !options.iri
                      ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase())
                      : punycode.toUnicode(domain);
                  } catch (e) {
                    components.error =
                      components.error ||
                      "Email address's domain name can not be converted to " +
                        (!options.iri ? "ASCII" : "Unicode") +
                        " via punycode: " +
                        e;
                  }
                  to[x] = localPart + "@" + domain;
                }
                components.path = to.join(",");
              }
              var headers = (mailtoComponents.headers = mailtoComponents.headers || {});
              if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
              if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
              var fields = [];
              for (var name in headers) {
                if (headers[name] !== O[name]) {
                  fields.push(
                    name
                      .replace(PCT_ENCODED, decodeUnreserved)
                      .replace(PCT_ENCODED, toUpperCase)
                      .replace(NOT_HFNAME, pctEncChar) +
                      "=" +
                      headers[name]
                        .replace(PCT_ENCODED, decodeUnreserved)
                        .replace(PCT_ENCODED, toUpperCase)
                        .replace(NOT_HFVALUE, pctEncChar),
                  );
                }
              }
              if (fields.length) {
                components.query = fields.join("&");
              }
              return components;
            },
          };

          var URN_PARSE = /^([^\:]+)\:(.*)/;
          //RFC 2141
          var handler$5 = {
            scheme: "urn",
            parse: function parse$$1(components, options) {
              var matches = components.path && components.path.match(URN_PARSE);
              var urnComponents = components;
              if (matches) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = matches[1].toLowerCase();
                var nss = matches[2];
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES[urnScheme];
                urnComponents.nid = nid;
                urnComponents.nss = nss;
                urnComponents.path = undefined;
                if (schemeHandler) {
                  urnComponents = schemeHandler.parse(urnComponents, options);
                }
              } else {
                urnComponents.error = urnComponents.error || "URN can not be parsed.";
              }
              return urnComponents;
            },
            serialize: function serialize$$1(urnComponents, options) {
              var scheme = options.scheme || urnComponents.scheme || "urn";
              var nid = urnComponents.nid;
              var urnScheme = scheme + ":" + (options.nid || nid);
              var schemeHandler = SCHEMES[urnScheme];
              if (schemeHandler) {
                urnComponents = schemeHandler.serialize(urnComponents, options);
              }
              var uriComponents = urnComponents;
              var nss = urnComponents.nss;
              uriComponents.path = (nid || options.nid) + ":" + nss;
              return uriComponents;
            },
          };

          var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
          //RFC 4122
          var handler$6 = {
            scheme: "urn:uuid",
            parse: function parse(urnComponents, options) {
              var uuidComponents = urnComponents;
              uuidComponents.uuid = uuidComponents.nss;
              uuidComponents.nss = undefined;
              if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
                uuidComponents.error = uuidComponents.error || "UUID is not valid.";
              }
              return uuidComponents;
            },
            serialize: function serialize(uuidComponents, options) {
              var urnComponents = uuidComponents;
              //normalize UUID
              urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
              return urnComponents;
            },
          };

          SCHEMES[handler.scheme] = handler;
          SCHEMES[handler$1.scheme] = handler$1;
          SCHEMES[handler$2.scheme] = handler$2;
          SCHEMES[handler$3.scheme] = handler$3;
          SCHEMES[handler$4.scheme] = handler$4;
          SCHEMES[handler$5.scheme] = handler$5;
          SCHEMES[handler$6.scheme] = handler$6;

          exports.SCHEMES = SCHEMES;
          exports.pctEncChar = pctEncChar;
          exports.pctDecChars = pctDecChars;
          exports.parse = parse;
          exports.removeDotSegments = removeDotSegments;
          exports.serialize = serialize;
          exports.resolveComponents = resolveComponents;
          exports.resolve = resolve;
          exports.normalize = normalize;
          exports.equal = equal;
          exports.escapeComponent = escapeComponent;
          exports.unescapeComponent = unescapeComponent;

          Object.defineProperty(exports, "__esModule", { value: true });
        });
      },
      {},
    ],
    199: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        var punycode = require("punycode");
        var util = require("./util");

        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;

        exports.Url = Url;

        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }

        // Reference: RFC 3986, RFC 1808, RFC 2396

        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
          portPattern = /:[0-9]*$/,
          // Special case for a simple path URL
          simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
          // RFC 2396: characters reserved for delimiting URLs.
          // We actually just auto-escape these.
          delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"],
          // RFC 2396: characters not allowed for various reasons.
          unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims),
          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
          autoEscape = ["'"].concat(unwise),
          // Characters that are never ever allowed in a hostname.
          // Note that any invalid chars are also handled, but these
          // are the ones that are *expected* to be seen, so we fast-path
          // them.
          nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape),
          hostEndingChars = ["/", "?", "#"],
          hostnameMaxLen = 255,
          hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
          hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
          // protocols that can allow "unsafe" and "unwise" chars.
          unsafeProtocol = {
            javascript: true,
            "javascript:": true,
          },
          // protocols that never have a hostname.
          hostlessProtocol = {
            javascript: true,
            "javascript:": true,
          },
          // protocols that always contain a // bit.
          slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true,
          },
          querystring = require("querystring");

        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url) return url;

          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }

        Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
          if (!util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
          }

          // Copy chrome, IE, opera backslash-handling behavior.
          // Back slashes before the query string get converted to forward slashes
          // See: https://code.google.com/p/chromium/issues/detail?id=25916
          var queryIndex = url.indexOf("?"),
            splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#",
            uSplit = url.split(splitter),
            slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url = uSplit.join(splitter);

          var rest = url;

          // trim before proceeding.
          // This is to support parse stuff like "  http://foo.com  \n"
          rest = rest.trim();

          if (!slashesDenoteHost && url.split("#").length === 1) {
            // Try fast path regexp
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }

          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }

          // figure out if it's got a host
          // user@server is *always* interpreted as a hostname, and url
          // resolution will treat //foo/bar as host=foo,path=bar because that's
          // how the browser resolves relative URLs.
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }

          if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c

            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.

            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
            }

            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
              // atSign can be anywhere.
              atSign = rest.lastIndexOf("@");
            } else {
              // atSign must be in auth portion.
              // http://a@b/c@d => host:b auth:a path:/c@d
              atSign = rest.lastIndexOf("@", hostEnd);
            }

            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }

            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) hostEnd = rest.length;

            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);

            // pull out port.
            this.parseHost();

            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || "";

            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";

            // validate a little.
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      // we replace non-ASCII char with a temporary placeholder
                      // we need this to make sure size of hostname is not
                      // broken by replacing non-ASCII by nothing
                      newpart += "x";
                    } else {
                      newpart += part[j];
                    }
                  }
                  // we test again with ASCII char only
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }

            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              // hostnames are always lower case.
              this.hostname = this.hostname.toLowerCase();
            }

            if (!ipv6Hostname) {
              // IDNA Support: Returns a punycoded representation of "domain".
              // It only converts parts of the domain name that
              // have non-ASCII characters, i.e. it doesn't matter if
              // you call it with a domain that already is ASCII-only.
              this.hostname = punycode.toASCII(this.hostname);
            }

            var p = this.port ? ":" + this.port : "";
            var h = this.hostname || "";
            this.host = h + p;
            this.href += this.host;

            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }

          // now rest is set to the post-host stuff.
          // chop off any delim chars.
          if (!unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1) continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }

          // chop off from the tail first.
          var hash = rest.indexOf("#");
          if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = "";
            this.query = {};
          }
          if (rest) this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }

          //to support http.request
          if (this.pathname || this.search) {
            var p = this.pathname || "";
            var s = this.search || "";
            this.path = p + s;
          }

          // finally, reconstruct the href based on what has been validated.
          this.href = this.format();
          return this;
        };

        // format a parsed object into a url string
        function urlFormat(obj) {
          // ensure it's an object, and not a string url.
          // If it's an obj, this is a no-op.
          // this way, you can call url_format() on strings
          // to clean up potentially wonky urls.
          if (util.isString(obj)) obj = urlParse(obj);
          if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
          return obj.format();
        }

        Url.prototype.format = function () {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }

          var protocol = this.protocol || "",
            pathname = this.pathname || "",
            hash = this.hash || "",
            host = false,
            query = "";

          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
            if (this.port) {
              host += ":" + this.port;
            }
          }

          if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }

          var search = this.search || (query && "?" + query) || "";

          if (protocol && protocol.substr(-1) !== ":") protocol += ":";

          // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
          // unless they had them to begin with.
          if (this.slashes || ((!protocol || slashedProtocol[protocol]) && host !== false)) {
            host = "//" + (host || "");
            if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
          } else if (!host) {
            host = "";
          }

          if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
          if (search && search.charAt(0) !== "?") search = "?" + search;

          pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
          });
          search = search.replace("#", "%23");

          return protocol + host + pathname + search + hash;
        };

        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }

        Url.prototype.resolve = function (relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };

        function urlResolveObject(source, relative) {
          if (!source) return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }

        Url.prototype.resolveObject = function (relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }

          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }

          // hash is always overridden, no matter what.
          // even href="" will remove it.
          result.hash = relative.hash;

          // if the relative url is empty, then there's nothing left to do here.
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }

          // hrefs like //foo/bar always cut to the protocol.
          if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol") result[rkey] = relative[rkey];
            }

            //urlParse appends trailing / to urls like http://www.example.com
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = "/";
            }

            result.href = result.format();
            return result;
          }

          if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }

            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift()));
              if (!relative.host) relative.host = "";
              if (!relative.hostname) relative.hostname = "";
              if (relPath[0] !== "") relPath.unshift("");
              if (relPath.length < 2) relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
              var p = result.pathname || "";
              var s = result.search || "";
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }

          var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/",
            isRelAbs = relative.host || (relative.pathname && relative.pathname.charAt(0) === "/"),
            mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
            removeAllDots = mustEndAbs,
            srcPath = (result.pathname && result.pathname.split("/")) || [],
            relPath = (relative.pathname && relative.pathname.split("/")) || [],
            psychotic = result.protocol && !slashedProtocol[result.protocol];

          // if the url is a non-slashed url, then relative
          // links like ../.. should be able
          // to crawl up to the hostname, as well.  This is strange.
          // result.protocol has already been set by now.
          // Later on, put the first path part into the host field.
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "") srcPath[0] = result.host;
              else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }

          if (isRelAbs) {
            // it's absolute.
            result.host = relative.host || relative.host === "" ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
          } else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }

          if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }

          // if a url ENDs in . or .., then it must get a trailing slash.
          // however, if it ends in anything else non-slashy,
          // then it must NOT get a trailing slash.
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash =
            ((result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..")) || last === "";

          // strip single dots, resolve double dots to parent dir
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === ".") {
              srcPath.splice(i, 1);
            } else if (last === "..") {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }

          // if the path is allowed to go above the root, restore leading ..s
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }

          if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
          }

          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }

          var isAbsolute = srcPath[0] === "" || (srcPath[0] && srcPath[0].charAt(0) === "/");

          // put the host back
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }

          mustEndAbs = mustEndAbs || (result.host && srcPath.length);

          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }

          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }

          //to support request.http
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };

        Url.prototype.parseHost = function () {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host) this.hostname = host;
        };
      },
      { "./util": 200, punycode: 173, querystring: 176 },
    ],
    200: [
      function (require, module, exports) {
        "use strict";

        module.exports = {
          isString: function (arg) {
            return typeof arg === "string";
          },
          isObject: function (arg) {
            return typeof arg === "object" && arg !== null;
          },
          isNull: function (arg) {
            return arg === null;
          },
          isNullOrUndefined: function (arg) {
            return arg == null;
          },
        };
      },
      {},
    ],
    201: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            /**
             * Module exports.
             */

            module.exports = deprecate;

            /**
             * Mark that a method should not be used.
             * Returns a modified function which warns once by default.
             *
             * If `localStorage.noDeprecation = true` is set, then it is a no-op.
             *
             * If `localStorage.throwDeprecation = true` is set, then deprecated functions
             * will throw an Error when invoked.
             *
             * If `localStorage.traceDeprecation = true` is set, then deprecated functions
             * will invoke `console.trace()` instead of `console.error()`.
             *
             * @param {Function} fn - the function to deprecate
             * @param {String} msg - the string to print to the console when `fn` is invoked
             * @returns {Function} a new "deprecated" version of `fn`
             * @api public
             */

            function deprecate(fn, msg) {
              if (config("noDeprecation")) {
                return fn;
              }

              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config("throwDeprecation")) {
                    throw new Error(msg);
                  } else if (config("traceDeprecation")) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }

              return deprecated;
            }

            /**
             * Checks `localStorage` for boolean values for the given `name`.
             *
             * @param {String} name
             * @returns {Boolean}
             * @api private
             */

            function config(name) {
              // accessing global.localStorage can trigger a DOMException in sandboxed iframes
              try {
                if (!global.localStorage) return false;
              } catch (_) {
                return false;
              }
              var val = global.localStorage[name];
              if (null == val) return false;
              return String(val).toLowerCase() === "true";
            }
          }).call(this);
        }).call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      {},
    ],
    202: [
      function (require, module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            });
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      },
      {},
    ],
    203: [
      function (require, module, exports) {
        module.exports = function isBuffer(arg) {
          return (
            arg &&
            typeof arg === "object" &&
            typeof arg.copy === "function" &&
            typeof arg.fill === "function" &&
            typeof arg.readUInt8 === "function"
          );
        };
      },
      {},
    ],
    204: [
      function (require, module, exports) {
        (function (process, global) {
          (function () {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            var formatRegExp = /%[sdj%]/g;
            exports.format = function (f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
              }

              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function (x) {
                if (x === "%%") return "%";
                if (i >= len) return x;
                switch (x) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }
              return str;
            };

            // Mark that a method should not be used.
            // Returns a modified function which warns once by default.
            // If --no-deprecation is set, then it is a no-op.
            exports.deprecate = function (fn, msg) {
              // Allow for deprecating things in the process of starting up.
              if (isUndefined(global.process)) {
                return function () {
                  return exports.deprecate(fn, msg).apply(this, arguments);
                };
              }

              if (process.noDeprecation === true) {
                return fn;
              }

              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }

              return deprecated;
            };

            var debugs = {};
            var debugEnviron;
            exports.debuglog = function (set) {
              if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || "";
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                  var pid = process.pid;
                  debugs[set] = function () {
                    var msg = exports.format.apply(exports, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function () {};
                }
              }
              return debugs[set];
            };

            /**
             * Echos the value of a value. Trys to print the value out
             * in the best way possible given the different types.
             *
             * @param {Object} obj The object to print out.
             * @param {Object} opts Optional options object that alters the output.
             */
            /* legacy: obj, showHidden, depth, colors*/
            function inspect(obj, opts) {
              // default options
              var ctx = {
                seen: [],
                stylize: stylizeNoColor,
              };
              // legacy...
              if (arguments.length >= 3) ctx.depth = arguments[2];
              if (arguments.length >= 4) ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
              } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts);
              }
              // set default options
              if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
              if (isUndefined(ctx.depth)) ctx.depth = 2;
              if (isUndefined(ctx.colors)) ctx.colors = false;
              if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
              if (ctx.colors) ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports.inspect = inspect;

            // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
            inspect.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39],
            };

            // Don't use 'blue' not visible on cmd.exe
            inspect.styles = {
              special: "cyan",
              number: "yellow",
              boolean: "yellow",
              undefined: "grey",
              null: "bold",
              string: "green",
              date: "magenta",
              // "name": intentionally not styling
              regexp: "red",
            };

            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];

              if (style) {
                return "\u001b[" + inspect.colors[style][0] + "m" + str + "\u001b[" + inspect.colors[style][1] + "m";
              } else {
                return str;
              }
            }

            function stylizeNoColor(str, styleType) {
              return str;
            }

            function arrayToHash(array) {
              var hash = {};

              array.forEach(function (val, idx) {
                hash[val] = true;
              });

              return hash;
            }

            function formatValue(ctx, value, recurseTimes) {
              // Provide a hook for user-specified inspect functions.
              // Check that value is an object with an inspect function on it
              if (
                ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)
              ) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }

              // Primitive types cannot have properties
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }

              // Look up the keys of the object.
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);

              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }

              // IE doesn't make error fields non-enumerable
              // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }

              // Some type of object without properties can be shortcutted.
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }

              var base = "",
                array = false,
                braces = ["{", "}"];

              // Make Array say that they are Array
              if (isArray(value)) {
                array = true;
                braces = ["[", "]"];
              }

              // Make functions say that they are functions
              if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
              }

              // Make RegExps say that they are RegExps
              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }

              // Make dates with properties first say the date
              if (isDate(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }

              // Make error with message first say the error
              if (isError(value)) {
                base = " " + formatError(value);
              }

              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }

              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }

              ctx.seen.push(value);

              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function (key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }

              ctx.seen.pop();

              return reduceToSingleString(output, base, braces);
            }

            function formatPrimitive(ctx, value) {
              if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
              if (isString(value)) {
                var simple =
                  "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber(value)) return ctx.stylize("" + value, "number");
              if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
              // For some reason typeof null is "object", so special case here.
              if (isNull(value)) return ctx.stylize("null", "null");
            }

            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }

            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function (key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                }
              });
              return output;
            }

            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str
                        .split("\n")
                        .map(function (line) {
                          return "  " + line;
                        })
                        .join("\n")
                        .substr(2);
                    } else {
                      str =
                        "\n" +
                        str
                          .split("\n")
                          .map(function (line) {
                            return "   " + line;
                          })
                          .join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"')
                    .replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }

              return name + ": " + str;
            }

            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function (prev, cur) {
                numLinesEst++;
                if (cur.indexOf("\n") >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);

              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }

              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }

            // NOTE: These type checking functions intentionally don't use `instanceof`
            // because it is fragile and can be easily faked with `Object.create()`.
            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports.isArray = isArray;

            function isBoolean(arg) {
              return typeof arg === "boolean";
            }
            exports.isBoolean = isBoolean;

            function isNull(arg) {
              return arg === null;
            }
            exports.isNull = isNull;

            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;

            function isNumber(arg) {
              return typeof arg === "number";
            }
            exports.isNumber = isNumber;

            function isString(arg) {
              return typeof arg === "string";
            }
            exports.isString = isString;

            function isSymbol(arg) {
              return typeof arg === "symbol";
            }
            exports.isSymbol = isSymbol;

            function isUndefined(arg) {
              return arg === void 0;
            }
            exports.isUndefined = isUndefined;

            function isRegExp(re) {
              return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports.isRegExp = isRegExp;

            function isObject(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports.isObject = isObject;

            function isDate(d) {
              return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports.isDate = isDate;

            function isError(e) {
              return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
            }
            exports.isError = isError;

            function isFunction(arg) {
              return typeof arg === "function";
            }
            exports.isFunction = isFunction;

            function isPrimitive(arg) {
              return (
                arg === null ||
                typeof arg === "boolean" ||
                typeof arg === "number" ||
                typeof arg === "string" ||
                typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined"
              );
            }
            exports.isPrimitive = isPrimitive;

            exports.isBuffer = require("./support/isBuffer");

            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }

            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }

            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

            // 26 Feb 16:19:34
            function timestamp() {
              var d = new Date();
              var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
              return [d.getDate(), months[d.getMonth()], time].join(" ");
            }

            // log is just a thin wrapper to console.log that prepends a timestamp
            exports.log = function () {
              console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
            };

            /**
             * Inherit the prototype methods from one constructor into another.
             *
             * The Function.prototype.inherits from lang.js rewritten as a standalone
             * function (not on Function.prototype). NOTE: If this file is to be loaded
             * during bootstrapping this function needs to be rewritten using some native
             * functions as prototype setup using normal JavaScript does not work as
             * expected during bootstrapping (see mirror.js in r114903).
             *
             * @param {function} ctor Constructor function which needs to inherit the
             *     prototype.
             * @param {function} superCtor Constructor function to inherit prototype from.
             */
            exports.inherits = require("inherits");

            exports._extend = function (origin, add) {
              // Don't do anything if add isn't an object
              if (!add || !isObject(add)) return origin;

              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };

            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
          }).call(this);
        }).call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
        );
      },
      { "./support/isBuffer": 203, _process: 172, inherits: 202 },
    ],
    205: [
      function (require, module, exports) {
        module.exports = extend;

        var hasOwnProperty = Object.prototype.hasOwnProperty;

        function extend() {
          var target = {};

          for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        }
      },
      {},
    ],
    206: [
      function (require, module, exports) {
        "use strict";

        let debug = location.hostname === "localhost";

        module.exports = analytics;

        /**
         * Initializes Google Analytics and sends a "pageview" hit
         */
        function analytics() {
          if (!debug) {
            if (typeof gtag === "undefined") {
              console.warn("Google Analytics is not enabled");
            }
          }
        }

        /**
         * Tracks an event in Google Analytics
         *
         * @param {string} category - the object type (e.g. "button", "menu", "link", etc.)
         * @param {string} action - the action (e.g. "click", "show", "hide", etc.)
         * @param {string} [label] - label for categorization
         * @param {number} [value] - numeric value, such as a counter
         */
        analytics.trackEvent = function (category, action, label, value) {
          try {
            console.log("Analytics event: ", category, action, label, value);

            if (!debug) {
              gtag("event", action, {
                event_category: category, // eslint-disable-line camelcase
                event_label: label, // eslint-disable-line camelcase
                value,
              });
            }
          } catch (error) {
            analytics.trackError(error);
          }
        };

        /**
         * Tracks an error in Google Analytics
         *
         * @param {Error} err
         */
        analytics.trackError = function (err) {
          try {
            console.error("Analytics error: ", err);

            if (!debug) {
              gtag("event", "exception", {
                name: err.name || "Error",
                description: err.message,
                stack: err.stack,
              });
            }
          } catch (error) {
            console.error(err);
          }
        };
      },
      {},
    ],
    207: [
      function (require, module, exports) {
        "use strict";

        const form = require("./form");
        const analytics = require("./analytics");

        module.exports = dropdowns;

        /**
         * Adds all the drop-down menu functionality
         */
        function dropdowns() {
          // Set the initial method name (in case it was set by the querystring module)
          setSelectedMethod(form.method.button.val());

          // Update each dropdown's label when its value(s) change
          onChange(form.allow.menu, setAllowLabel);
          onChange(form.refs.menu, setRefsLabel);
          onChange(form.validate.menu, setValidateLabel);

          // Track option changes
          trackCheckbox(form.allow.json);
          trackCheckbox(form.allow.yaml);
          trackCheckbox(form.allow.text);
          trackCheckbox(form.allow.empty);
          trackCheckbox(form.allow.unknown);
          trackCheckbox(form.refs.external);
          trackCheckbox(form.refs.circular);
          trackCheckbox(form.validate.schema);
          trackCheckbox(form.validate.spec);

          // Change the button text whenever a new method is selected
          form.method.menu.find("a").on("click", function (event) {
            form.method.menu.dropdown("toggle");
            event.stopPropagation();
            let methodName = $(this).data("value");
            setSelectedMethod(methodName);
            trackButtonLabel(methodName);
          });
        }

        /**
         * Calls the given function whenever the user selects (or deselects)
         * a value in the given drop-down menu.
         *
         * @param {jQuery} menu
         * @param {function} setLabel
         */
        function onChange(menu, setLabel) {
          let dropdown = menu.parent(".dropdown");

          // Don't auto-close the menu when items are clicked
          menu.find("a").on("click", (event) => {
            event.stopPropagation();
          });

          // Set the label immediately, and again whenever the menu is closed
          setLabel();
          dropdown.on("hidden.bs.dropdown", setLabel);

          // Track when a dropdown menu is shown
          dropdown.on("shown.bs.dropdown", () => {
            analytics.trackEvent("options", "shown", menu.attr("id"));
          });
        }

        /**
         * Sets the "allow" label, based on which options are selected
         */
        function setAllowLabel() {
          let values = getCheckedAndUnchecked(
            form.allow.json,
            form.allow.yaml,
            form.allow.text,
            form.allow.empty,
            form.allow.unknown,
          );

          switch (values.checked.length) {
            case 0:
              form.allow.label.text("No file types allowed");
              break;
            case 1:
              form.allow.label.text("Only allow " + values.checked[0] + " files");
              break;
            case 2:
              form.allow.label.text("Only allow " + values.checked[0] + " and " + values.checked[1]);
              break;
            case 3:
              form.allow.label.text("Don't allow " + values.unchecked[0] + " or " + values.unchecked[1]);
              break;
            case 4:
              form.allow.label.text("Don't allow " + values.unchecked[0] + " files");
              break;
            case 5:
              form.allow.label.text("Allow all file types");
          }
        }

        /**
         * Sets the "refs" label, based on which options are selected
         */
        function setRefsLabel() {
          let values = getCheckedAndUnchecked(form.refs.external, form.refs.circular);

          switch (values.checked.length) {
            case 0:
              form.refs.label.text("Only follow internal $refs");
              break;
            case 1:
              form.refs.label.text("Don't follow " + values.unchecked[0] + " $refs");
              break;
            case 2:
              form.refs.label.text("Follow all $refs");
          }
        }

        /**
         * Sets the "validate" label, based on which options are selected
         */
        function setValidateLabel() {
          let values = getCheckedAndUnchecked(form.validate.schema, form.validate.spec);

          switch (values.checked.length) {
            case 0:
              form.validate.label.text("Don't validate anything");
              break;
            case 1:
              form.validate.label.text("Don't validate Swagger " + values.unchecked[0]);
              break;
            case 2:
              form.validate.label.text("Validate everything");
          }
        }

        /**
         * Updates the UI to match the specified method name
         *
         * @param {string} methodName - The method name (e.g. "validate", "dereference", etc.)
         */
        function setSelectedMethod(methodName) {
          form.method.button.val(methodName.toLowerCase());

          methodName = methodName[0].toUpperCase() + methodName.substr(1);
          form.method.button.text(methodName + " it!");
          form.tabs.url.text(methodName + " a URL");
          form.tabs.text.text(methodName + " Text");
        }

        /**
         * Tracks changes to a checkbox option
         *
         * @param {jQuery} checkbox
         */
        function trackCheckbox(checkbox) {
          checkbox.on("change", () => {
            let value = checkbox.is(":checked") ? 1 : 0;
            analytics.trackEvent("options", "changed", checkbox.attr("name"), value);
          });
        }

        /**
         * Tracks changes to the "Validate!" button
         *
         * @param {string} methodName - The method name (e.g. "validate", "dereference", etc.)
         */
        function trackButtonLabel(methodName) {
          let value = ["", "parse", "resolve", "bundle", "dereference", "validate"].indexOf(methodName);
          analytics.trackEvent("options", "changed", "method", value);
        }

        /**
         * Examines the given checkboxes, and returns arrays of checked and unchecked values.
         *
         * @param {...jQuery} _checkboxes
         * @returns {{checked: string[], unchecked: string[]}}
         */
        function getCheckedAndUnchecked(_checkboxes) {
          let checked = [],
            unchecked = [];
          for (let i = 0; i < arguments.length; i++) {
            let checkbox = arguments[i];
            if (checkbox.is(":checked")) {
              checked.push(checkbox.data("value"));
            } else {
              unchecked.push(checkbox.data("value"));
            }
          }
          return { checked, unchecked };
        }
      },
      { "./analytics": 206, "./form": 209 },
    ],
    208: [
      function (require, module, exports) {
        "use strict";

        const form = require("./form");
        const ACE_THEME = "ace/theme/terminal";

        module.exports = editors;

        /**
         * Initializes the ACE text editors
         */
        function editors() {
          editors.textBox = form.textBox = ace.edit("text-box");
          form.textBox.setTheme(ACE_THEME);
          let session = form.textBox.getSession();
          session.setMode("ace/mode/yaml");
          session.setTabSize(2);

          editors.results = $("#results");
          editors.tabs = editors.results.find(".nav-tabs");
          editors.panes = editors.results.find(".tab-content");
        }

        /**
         * Removes all results tabs and editors
         */
        editors.clearResults = function () {
          editors.results.removeClass("error animated").addClass("hidden");
          editors.tabs.children().remove();
          editors.panes.children().remove();
        };

        /**
         * Displays a successful result
         *
         * @param {string} title - The title of the tab
         * @param {object|string} content - An object that will be displayed as JSON in the editor
         */
        editors.showResult = function (title, content) {
          editors.results.removeClass("hidden");
          editors.addResult(title, content);
          showResults();
        };

        /**
         * Displays an error result
         *
         * @param {Error} err
         */
        editors.showError = function (err) {
          editors.results.removeClass("hidden").addClass("error");
          editors.addResult("Error!", err);
          showResults();
        };

        /**
         * Adds a results tab with an Ace Editor containing the given content
         *
         * @param {string} title - The title of the tab
         * @param {object|string} content - An object that will be displayed as JSON in the editor
         */
        editors.addResult = function (title, content) {
          let index = editors.tabs.children().length;
          let titleId = "results-tab-" + index + "-title";
          let editorId = "results-" + index;
          let active = index === 0 ? "active" : "";

          // Add a tab and pane
          editors.tabs.append(
            '<li id="results-tab-' +
              index +
              '" class="' +
              active +
              '" role="presentation">' +
              ' <a id="' +
              titleId +
              '" href="#results-pane-' +
              index +
              '" role="tab" aria-controls="results-pane-' +
              index +
              '" data-toggle="tab"></a>' +
              "</li>",
          );
          editors.panes.append(
            '<div id="results-pane-' +
              index +
              '" class="tab-pane ' +
              active +
              '" role="tabpanel">' +
              '  <pre id="' +
              editorId +
              '" class="editor"></pre>' +
              "</div>",
          );

          // Set the tab title
          let shortTitle = getShortTitle(title) || "Sample API";
          editors.tabs
            .find("#" + titleId)
            .text(shortTitle)
            .attr("title", title);

          // Set the <pre> content
          content = toText(content);
          editors.panes.find("#" + editorId).text(content.text);

          // Turn the <pre> into an Ace Editor
          let editor = ace.edit(editorId);
          editor.setTheme(ACE_THEME);
          editor.session.setOption("useWorker", false);
          content.isJSON && editor.getSession().setMode("ace/mode/json");
          editor.setReadOnly(true);
        };

        /**
         * Returns a short version of the given title text, to better fit in a tab
         *
         * @param {string} title
         * @returns {string}
         */
        function getShortTitle(title) {
          // Get just the file name
          let lastSlash = title.lastIndexOf("/");
          if (lastSlash !== -1) {
            title = title.substr(lastSlash + 1);
          }

          if (title.length > 15) {
            // It's still too long, so, just return the first 10 characters
            title = title.substr(0, 10) + "...";
          }

          return title;
        }

        /**
         * Ensures that the results are visible, and plays an animation to get the user's attention.
         */
        function showResults() {
          let results = editors.results;

          setTimeout(() => {
            results[0].scrollIntoView();
            results
              .addClass("animated")
              .one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", () => {
                // Remove the "animated" class when the animation ends,
                // so we can replay the animation again next time
                results.removeClass("animated");
              });
          });
        }

        /**
         * Converts the given object to text.
         * If possible, it is converted to JSON; otherwise, plain text.
         *
         * @param {object} obj
         * @returns {object}
         */
        function toText(obj) {
          if (obj instanceof Error) {
            return {
              isJSON: false,
              text: obj.message + "\n\n" + obj.stack,
            };
          } else {
            try {
              return {
                isJSON: true,
                text: JSON.stringify(obj, null, 2),
              };
            } catch (e) {
              return {
                isJSON: false,
                text: "This API is valid, but it cannot be shown because it contains circular references\n\n" + e.stack,
              };
            }
          }
        }
      },
      { "./form": 209 },
    ],
    209: [
      function (require, module, exports) {
        "use strict";

        const jsYAML = require("js-yaml");

        module.exports = form;

        /**
         * Finds all form fields and exposes them as properties.
         */
        function form() {
          form.form = $("#swagger-parser-form");

          form.allow = {
            label: form.form.find("#allow-label"),
            menu: form.form.find("#allow-menu"),
            json: form.form.find("input[name=allow-json]"),
            yaml: form.form.find("input[name=allow-yaml]"),
            text: form.form.find("input[name=allow-text]"),
            empty: form.form.find("input[name=allow-empty]"),
            unknown: form.form.find("input[name=allow-unknown]"),
          };

          form.refs = {
            label: form.form.find("#refs-label"),
            menu: form.form.find("#refs-menu"),
            external: form.form.find("input[name=refs-external]"),
            circular: form.form.find("input[name=refs-circular]"),
          };

          form.validate = {
            label: form.form.find("#validate-label"),
            menu: form.form.find("#validate-menu"),
            schema: form.form.find("input[name=validate-schema]"),
            spec: form.form.find("input[name=validate-spec]"),
          };

          form.tabs = {
            url: form.form.find("#url-tab"),
            text: form.form.find("#text-tab"),
          };

          form.method = {
            button: form.form.find("button[name=method]"),
            menu: form.form.find("#method-menu"),
          };

          form.samples = {
            url: {
              container: form.form.find("#url-sample"),
              link: form.form.find("#url-sample-link"),
            },
            text: {
              container: form.form.find("#text-sample"),
              link: form.form.find("#text-sample-link"),
            },
          };

          form.url = form.form.find("input[name=url]");
          form.textBox = null; // This is set in editors.js
          form.bookmark = form.form.find("#bookmark");
        }

        /**
         * Returns a Swagger Parser options object,
         * set to the current values of all the form fields.
         */
        form.getOptions = function () {
          return {
            parse: {
              json: form.allow.json.is(":checked")
                ? {
                    allowEmpty: form.allow.empty.is(":checked"),
                  }
                : false,
              yaml: form.allow.yaml.is(":checked")
                ? {
                    allowEmpty: form.allow.empty.is(":checked"),
                  }
                : false,
              text: form.allow.text.is(":checked")
                ? {
                    allowEmpty: form.allow.empty.is(":checked"),
                  }
                : false,
              binary: form.allow.unknown.is(":checked")
                ? {
                    allowEmpty: form.allow.empty.is(":checked"),
                  }
                : false,
            },
            resolve: {
              external: form.refs.external.is(":checked"),
            },
            dereference: {
              circular: form.refs.circular.is(":checked"),
            },
            validate: {
              schema: form.validate.schema.is(":checked"),
              spec: form.validate.spec.is(":checked"),
            },
          };
        };

        /**
         * Returns the Swagger API or URL, depending on the current form fields.
         */
        form.getAPI = function () {
          // Determine which tab is selected
          if (form.tabs.url.parent().attr("class").indexOf("active") >= 0) {
            let url = form.url.val();
            if (url) {
              return url;
            } else {
              throw new URIError("Please specify the URL of your Swagger/OpenAPI definition");
            }
          } else {
            let text = form.textBox.getValue();
            if (form.allow.yaml.is(":checked")) {
              return jsYAML.safeLoad(text);
            } else if (form.allow.json.is(":checked")) {
              return JSON.parse(text);
            } else {
              throw new SyntaxError("Unable to parse the API. Neither YAML nor JSON are allowed.");
            }
          }
        };
      },
      { "js-yaml": 141 },
    ],
    210: [
      function (require, module, exports) {
        "use strict";

        const form = require("./form");
        const querystring = require("./querystring");
        const dropdowns = require("./dropdowns");
        const editors = require("./editors");
        const samples = require("./samples");
        const parser = require("./parser");
        const analytics = require("./analytics");

        $(() => {
          form();
          querystring();
          dropdowns();
          editors();
          samples();
          parser();
          analytics();
        });
      },
      {
        "./analytics": 206,
        "./dropdowns": 207,
        "./editors": 208,
        "./form": 209,
        "./parser": 211,
        "./querystring": 212,
        "./samples": 213,
      },
    ],
    211: [
      function (require, module, exports) {
        "use strict";

        const form = require("./form");
        const editors = require("./editors");
        const analytics = require("./analytics");
        const { ono } = require("@jsdevtools/ono");
        const SwaggerParser = require("../../../");

        let swaggerParser = null;
        let counters = { parse: 0, resolve: 0, bundle: 0, dereference: 0, validate: 0 };

        module.exports = parser;

        /**
         * Adds event handlers to trigger Swagger Parser methods
         */
        function parser() {
          // When the form is submitted, parse the Swagger API
          form.form.on("submit", (event) => {
            event.preventDefault();
            parseSwagger();
          });

          // When the "x" button is clicked, discard the results
          $("#clear").on("click", () => {
            swaggerParser = null;
            editors.clearResults();
            analytics.trackEvent("results", "clear");
          });
        }

        /**
         * This function is called when the "Validate it!" button is clicked.
         * It calls Swagger Parser, passing it all the options selected on the form.
         */
        function parseSwagger() {
          try {
            // Clear any previous results
            editors.clearResults();

            // Get all the parameters
            swaggerParser = swaggerParser || new SwaggerParser();
            let options = form.getOptions();
            let method = form.method.button.val();
            let api = form.getAPI();

            // Call Swagger Parser
            swaggerParser[method](api, options)
              .then(() => {
                // Show the results
                let results = swaggerParser.$refs.values();
                Object.keys(results).forEach((key) => {
                  editors.showResult(key, results[key]);
                });
              })
              .catch((err) => {
                editors.showError(ono(err));
                analytics.trackError(err);
              });

            // Track the operation
            counters[method]++;
            analytics.trackEvent("button", "click", method, counters[method]);
          } catch (err) {
            editors.showError(ono(err));
            analytics.trackError(err);
          }
        }
      },
      { "../../../": 1, "./analytics": 206, "./editors": 208, "./form": 209, "@jsdevtools/ono": 33 },
    ],
    212: [
      function (require, module, exports) {
        "use strict";

        const qs = require("querystring");
        const form = require("./form");

        module.exports = querystring;

        /**
         * Initializes the UI, based on the query-string in the URL
         */
        function querystring() {
          setFormFields();
          setBookmarkURL();
          form.bookmark.on("click focus mouseenter", setBookmarkURL);
        }

        /**
         * Populates all form fields based on the query-string in the URL
         */
        function setFormFields() {
          let query = qs.parse(window.location.search.substr(1));

          setCheckbox(form.allow.json, query["allow-json"]);
          setCheckbox(form.allow.yaml, query["allow-yaml"]);
          setCheckbox(form.allow.text, query["allow-text"]);
          setCheckbox(form.allow.empty, query["allow-empty"]);
          setCheckbox(form.allow.unknown, query["allow-unknown"]);
          setCheckbox(form.refs.external, query["refs-external"]);
          setCheckbox(form.refs.circular, query["refs-circular"]);
          setCheckbox(form.validate.schema, query["validate-schema"]);
          setCheckbox(form.validate.spec, query["validate-spec"]);

          // If a custom URL is specified, then show the "Your API" tab
          if (query.url) {
            form.url.val(query.url);
          }

          // If a method is specified, then change the "Validate!" button
          if (query.method) {
            query.method = query.method.toLowerCase();
            if (["parse", "resolve", "bundle", "dereference", "validate"].indexOf(query.method) !== -1) {
              form.method.button.val(query.method);
            }
          }
        }

        /**
         * Checks or unchecks the given checkbox, based on the given value.
         *
         * @param {jQuery} input
         * @param {*} value
         */
        function setCheckbox(input, value) {
          if (!value || value === "true" || value === "on") {
            value = "yes";
          }
          input.val([value]);
        }

        /**
         * Sets the href of the bookmark link, based on the values of each form field
         */
        function setBookmarkURL() {
          let query = {};
          let options = form.getOptions();
          options.parse.json || (query["allow-json"] = "no");
          options.parse.yaml || (query["allow-yaml"] = "no");
          options.parse.text || (query["allow-text"] = "no");
          options.parse.json.allowEmpty || (query["allow-empty"] = "no");
          options.parse.binary || (query["allow-unknown"] = "no");
          options.resolve.external || (query["refs-external"] = "no");
          options.dereference.circular || (query["refs-circular"] = "no");
          options.validate.schema || (query["validate-schema"] = "no");
          options.validate.spec || (query["validate-spec"] = "no");

          let method = form.method.button.val();
          method === "validate" || (query.method = method);

          let url = form.url.val();
          url === "" || (query.url = url);

          let bookmark = "?" + qs.stringify(query);
          form.bookmark.attr("href", bookmark);
        }
      },
      { "./form": 209, querystring: 176 },
    ],
    213: [
      function (require, module, exports) {
        "use strict";

        const form = require("./form");

        module.exports = samples;

        /**
         * Allows the user to use a sample URL or sample API text
         */
        function samples() {
          form.samples.url.link.on("click", (event) => {
            event.preventDefault();
            form.url.val(samples.url);
          });

          form.samples.text.link.on("click", (event) => {
            event.preventDefault();
            form.textBox.setValue(samples.text, -1);
            form.samples.text.container.hide();
            form.textBox.focus();
          });

          form.textBox.on("input", () => {
            if (form.textBox.session.getValue().length === 0) {
              form.samples.text.container.show();
            } else {
              form.samples.text.container.hide();
            }
          });
        }

        samples.url = "https://apitools.dev/swagger-parser/online/sample/swagger.yaml";

        samples.text =
          'swagger: "2.0"\n' +
          "info:\n" +
          "  version: 1.0.0\n" +
          "  title: Swagger Petstore\n" +
          "  description: >\n" +
          "    A sample API that uses a petstore as an example\n" +
          "    to demonstrate features in the swagger-2.0 specification\n" +
          "consumes:\n" +
          "  - application/json\n" +
          "produces:\n" +
          "  - application/json\n" +
          "paths:\n" +
          "  /pets:\n" +
          "    get:\n" +
          "      description: Returns all pets from the petstore\n" +
          "      responses:\n" +
          '        "200":\n' +
          "          description: pet response\n" +
          "          schema:\n" +
          "            type: array\n" +
          "            items:\n" +
          '              $ref: "#/definitions/pet"\n' +
          "        default:\n" +
          "          description: unexpected error\n" +
          "          schema:\n" +
          '            $ref: "#/definitions/errorModel"\n' +
          "    post:\n" +
          "      description: Creates a new pet in the store\n" +
          "      parameters:\n" +
          "        - name: pet\n" +
          "          in: body\n" +
          "          description: Pet to add to the store\n" +
          "          required: true\n" +
          "          schema:\n" +
          '            $ref: "#/definitions/pet"\n' +
          "      responses:\n" +
          '        "200":\n' +
          "          description: pet response\n" +
          "          schema:\n" +
          '            $ref: "#/definitions/pet"\n' +
          "        default:\n" +
          "          description: unexpected error\n" +
          "          schema:\n" +
          '            $ref: "#/definitions/errorModel"\n' +
          '  "/pets/{name}":\n' +
          "    get:\n" +
          "      description: Returns a single pet by name\n" +
          "      parameters:\n" +
          "        - name: name\n" +
          "          in: path\n" +
          "          description: Name of the pet to fetch\n" +
          "          required: true\n" +
          "          type: string\n" +
          "      responses:\n" +
          '        "200":\n' +
          "          description: pet response\n" +
          "          schema:\n" +
          '            $ref: "#/definitions/pet"\n' +
          "        default:\n" +
          "          description: unexpected error\n" +
          "          schema:\n" +
          '            $ref: "#/definitions/errorModel"\n' +
          "definitions:\n" +
          "  pet:\n" +
          "    $ref: sample/pet.yaml\n" +
          "  pet-owner:\n" +
          "    $ref: sample/pet-owner.yaml\n" +
          "  errorModel:\n" +
          "    $ref: sample/error.json\n";
      },
      { "./form": 209 },
    ],
  },
  {},
  [210],
);
//# sourceMappingURL=bundle.js.map
